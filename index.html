<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small AI v2</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Favicon -->
    <link rel="icon" href="logo.png" type="image/x-icon">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for modern typography, Fira Code for monospace code -->
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
    <!-- Marked.js CDN for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Highlight.js for Code Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <!-- Lucide Icons for a modern, futuristic feel -->
    <script src="https://cdn.jsdelivr.net/npm/lucide-dynamic@latest/dist/lucide.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- NEW: Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>

    <style>
        /*
        * --- Custom Styles for AI Chat Assistant (Enhanced UI/UX System) ---
        */
        
        :root {
            /* Typography */
            --font-display: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-body: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            
            /* Spacing Scale - 8px base */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            --space-3xl: 4rem;
            
            /* Border Radius Scale */
            --radius-sm: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --radius-2xl: 2rem;
            --radius-full: 9999px;
            
            /* Transition System */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 250ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-bounce: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);
            
            /* Z-Index Scale */
            --z-base: 1;
            --z-dropdown: 10;
            --z-sticky: 20;
            --z-fixed: 30;
            --z-modal-backdrop: 100;
            --z-modal: 110;
            --z-popover: 120;
            --z-tooltip: 130;
        }

        /* Base font and transition settings for the whole page */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-y: hidden; /* Control vertical scroll via chat-history */
            overflow-x: hidden; /* Prevent body horizontal scroll */
        }
        
        body {
            font-family: var(--font-body);
            font-size: 16px;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: var(--transition-slow);
            display: flex; 
            color: var(--text-primary); 
        }

        /* --- Theme Definitions --- */
        
        /* Default Theme: Light Mode (PREMIUM) */
        body[data-theme="default-light"] {
            /* Backgrounds */
            --bg-primary: #FAFBFC;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #F5F7FA;
            --bg-hover: #F0F4F8;
            
            /* Text Colors */
            --text-primary: #0F172A;
            --text-secondary: #475569;
            --text-tertiary: #94A3B8;
            --text-disabled: #CBD5E1;
            
            /* Border Colors */
            --border-color: #E2E8F0;
            --border-hover: #CBD5E1;
            --border-focus: #6366F1;
            
            /* Accent Colors */
            --accent-primary: #6366F1;
            --accent-primary-hover: #4F46E5;
            --accent-secondary: #8B5CF6;
            --accent-error: #EF4444;
            --accent-success: #10B981;
            --accent-warning: #F59E0B;
            --accent-info: #3B82F6;
            
            /* Mapping old variables to new tokens */
            --card-bg: var(--bg-secondary);
            --card-border: var(--border-color);
            --header-bg: var(--bg-secondary);
            --user-bubble-bg: linear-gradient(135deg, #EEF2FF 0%, #E0E7FF 100%);
            --user-bubble-text: var(--text-primary); 
            --ai-bubble-bg: var(--bg-secondary);
            --ai-bubble-text: var(--text-primary); 
            --sidebar-bg: var(--bg-secondary);
            --sidebar-border: var(--border-color);
            --sidebar-item-hover: var(--bg-tertiary);
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: var(--bg-primary);
            --conversation-bg: var(--bg-secondary);
            --conversation-text: var(--text-primary); 
            --conversation-indicator: var(--accent-primary);
            --code-block-bg: #F8FAFC;
            --code-block-header-bg: var(--bg-tertiary);
            --code-block-border: var(--border-color);

            /* NEW: Global Shadows (Light Mode) - Reusing old names */
            --shadow-subtle: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.12), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
            
            background: linear-gradient(180deg, #FAFBFC 0%, #F5F7FA 100%);
        }

        /* Default Theme: Dark Mode (PREMIUM) */
        body[data-theme="default-dark"] {
            /* Backgrounds */
            --bg-primary: #0F172A;
            --bg-secondary: #1E293B;
            --bg-tertiary: #334155;
            --bg-hover: #475569;
            
            /* Text Colors */
            --text-primary: #F1F5F9;
            --text-secondary: #CBD5E1;
            --text-tertiary: #94A3B8;
            --text-disabled: #64748B;
            
            /* Border Colors */
            --border-color: #334155;
            --border-hover: #475569;
            --border-focus: #818CF8;
            
            /* Accent Colors */
            --accent-primary: #818CF8;
            --accent-primary-hover: #6366F1;
            --accent-secondary: #A78BFA;
            --accent-error: #F87171;
            --accent-success: #34D399;
            --accent-warning: #FBBF24;
            --accent-info: #60A5FA;
            
            /* Mapping old variables to new tokens */
            --card-bg: var(--bg-secondary);
            --card-border: var(--border-color);
            --header-bg: var(--bg-secondary);
            --user-bubble-bg: linear-gradient(135deg, #312E81 0%, #3730A3 100%);
            --user-bubble-text: var(--text-primary); 
            --ai-bubble-bg: var(--bg-secondary);
            --ai-bubble-text: var(--text-primary); 
            --sidebar-bg: var(--bg-primary);
            --sidebar-border: var(--border-color);
            --sidebar-item-hover: var(--bg-secondary);
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: var(--bg-primary);
            --conversation-bg: var(--bg-primary);
            --conversation-text: var(--text-primary); 
            --conversation-indicator: var(--accent-primary);
            --code-block-bg: var(--bg-secondary);
            --code-block-header-bg: var(--bg-tertiary);
            --code-block-border: var(--border-color);
            
            /* NEW: Global Shadows (Dark Mode) - Reusing old names */
            --shadow-subtle: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.4);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.6), 0 10px 10px -5px rgba(0, 0, 0, 0.5);
            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.7);
            
            background: linear-gradient(180deg, #0F172A 0%, #1E293B 100%);
        }

        /* Celestial Horizon Theme: Dark Mode */
        body[data-theme="celestial-horizon-dark"] {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --text-primary: #58A6FF; /* Changed to accent */
            --text-secondary: #8B949E;
            --border-color: #30363D;
            --card-bg: #1F2633;
            --card-border: #30363D;
            --header-bg: #161B22;
            --accent-primary: #58A6FF;
            --accent-primary-hover: #388BF2;
            --accent-secondary: #B1B8C1;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #253B64;
            --user-bubble-text: #58A6FF; /* Changed to accent */
            --ai-bubble-bg: #1F2633;
            --ai-bubble-text: #58A6FF; /* Changed to accent */
            --sidebar-bg: #161B22;
            --sidebar-border: #30363D;
            --sidebar-item-hover: #1F2633;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(22, 27, 34, 0.9);
            --conversation-bg: rgba(22, 27, 34, 0.95);
            --conversation-text: #58A6FF; /* Changed to accent */
            --conversation-indicator: #58A6FF;
            --code-block-bg: #1F2633;
            --code-block-header-bg: #161B22;
            --code-block-border: #30363D;

            background-color: var(--bg-primary);
        }

        /* Celestial Horizon Theme: Light Mode */
        body[data-theme="celestial-horizon-light"] {
            --bg-primary: #F0F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #3B82F6; /* Changed to accent */
            --text-secondary: #718096;
            --border-color: #E2E8F0;
            --card-bg: #FFFFFF;
            --card-border: #E2E8F0;
            --header-bg: #EDF2F7;
            --accent-primary: #3B82F6;
            --accent-primary-hover: #2563EB;
            --accent-secondary: #60A5FA;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #DBEAFE;
            --user-bubble-text: #3B82F6; /* Changed to accent */
            --ai-bubble-bg: #EBF4FF;
            --ai-bubble-text: #3B82F6; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E2E8F0;
            --sidebar-item-hover: #F0F4F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #3B82F6; /* Changed to accent */
            --conversation-indicator: #3B82F6;
            --code-block-bg: #EBF4FF;
            --code-block-header-bg: #EDF2F7;
            --code-block-border: #E2E8F0;

            background-color: var(--bg-primary);
        }

        /* Verdant Calm Theme: Dark Mode (Renamed from Forest Whisper) */
        body[data-theme="verdant-calm-dark"] {
            --bg-primary: #1a2a22;
            --bg-secondary: #21362d;
            --text-primary: #3cb878; /* Changed to accent */
            --text-secondary: #99bbaa;
            --border-color: #3f544c;
            --card-bg: #294237;
            --card-border: #4a6356;
            --header-bg: #2c493c;
            --accent-primary: #3cb878;
            --accent-primary-hover: #2fa163;
            --accent-secondary: #60c58e;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #1e8449;
            --user-bubble-text: #3cb878; /* Changed to accent */
            --ai-bubble-bg: #34495e;
            --ai-bubble-text: #3cb878; /* Changed to accent */
            --sidebar-bg: #21362d;
            --sidebar-border: #3f544c;
            --sidebar-item-hover: #2c493c;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(33, 54, 45, 0.9);
            --conversation-bg: rgba(33, 54, 45, 0.95);
            --conversation-text: #3cb878; /* Changed to accent */
            --conversation-indicator: #3cb878;
            --code-block-bg: #34495e;
            --code-block-header-bg: #2c493c;
            --code-block-border: #3f544c;

            background-color: var(--bg-primary);
        }

        /* Verdant Calm Theme: Light Mode */
        body[data-theme="verdant-calm-light"] {
            --bg-primary: #edf9f5;
            --bg-secondary: #ffffff;
            --text-primary: #3cb878; /* Changed to accent */
            --text-secondary: #5e7d6b;
            --border-color: #dbeae5;
            --card-bg: #ffffff;
            --card-border: #dbeae5;
            --header-bg: #f5fcf9;
            --accent-primary: #3cb878;
            --accent-primary-hover: #2fa163;
            --accent-secondary: #60c58e;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #c8e6c9;
            --user-bubble-text: #3cb878; /* Changed to accent */
            --ai-bubble-bg: #e8f5e9;
            --ai-bubble-text: #3cb878; /* Changed to accent */
            --sidebar-bg: #ffffff;
            --sidebar-border: #dbeae5;
            --sidebar-item-hover: #edf9f5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #3cb878; /* Changed to accent */
            --conversation-indicator: #3cb878;
            --code-block-bg: #e8f5e9;
            --code-block-header-bg: #f5fcf9;
            --code-block-border: #dbeae5;

            background-color: var(--bg-primary);
        }

        /* Cybernetic Pulse Theme: Dark Mode */
        body[data-theme="cybernetic-pulse-dark"] {
            --bg-primary: #0a0e1a;
            --bg-secondary: #161c28;
            --text-primary: #0ea5e9; /* Changed to accent */
            --text-secondary: #94a3b8;
            --border-color: #2f3e52;
            --card-bg: #1f2a3a;
            --card-border: #3a4b5e;
            --header-bg: #1f2a3a;
            --accent-primary: #0ea5e9;
            --accent-primary-hover: #0284c7;
            --accent-secondary: #38bdf8;
            --accent-error: #f87171;
            --accent-success: #4ade80;
            --user-bubble-bg: #0c4a6e;
            --user-bubble-text: #0ea5e9; /* Changed to accent */
            --ai-bubble-bg: #2d3748;
            --ai-bubble-text: #0ea5e9; /* Changed to accent */
            --sidebar-bg: #161c28;
            --sidebar-border: #2f3e52;
            --sidebar-item-hover: #1f2a3a;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(22, 28, 40, 0.9);
            --conversation-bg: rgba(22, 28, 40, 0.95);
            --conversation-text: #0ea5e9; /* Changed to accent */
            --conversation-indicator: #0ea5e9;
            --code-block-bg: #2d3748;
            --code-block-header-bg: #1f2a3a;
            --code-block-border: #2f3e52;

            background-color: var(--bg-primary);
        }

        /* Cybernetic Pulse Theme: Light Mode */
        body[data-theme="cybernetic-pulse-light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --text-primary: #0ea5e9; /* Changed to accent */
            --text-secondary: #475569;
            --border-color: #e0e7f2;
            --card-bg: #ffffff;
            --card-border: #e0e7f2;
            --header-bg: #f1f5f9;
            --accent-primary: #0ea5e9;
            --accent-primary-hover: #0284c7;
            --accent-secondary: #38bdf8;
            --accent-error: #ef4444;
            --accent-success: #22c55e;
            --user-bubble-bg: #bfdbfe;
            --user-bubble-text: #0ea5e9; /* Changed to accent */
            --ai-bubble-bg: #e0f2fe;
            --ai-bubble-text: #0ea5e9; /* Changed to accent */
            --sidebar-bg: #ffffff;
            --sidebar-border: #e0e7f2;
            --sidebar-item-hover: #f1f5f9;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #0ea5e9; /* Changed to accent */
            --conversation-indicator: #0ea5e9;
            --code-block-bg: #e0f2fe;
            --code-block-header-bg: #f1f5f9;
            --code-block-border: #e0e7f2;

            background-color: var(--bg-primary);
        }

        /* Urban Pulse Theme: Dark Mode */
        body[data-theme="urban-pulse-dark"] {
            --bg-primary: #1A1A1D;
            --bg-secondary: #242426;
            --text-primary: #00BFFF; /* Changed to accent */
            --text-secondary: #A0A0A0;
            --border-color: #38383B;
            --card-bg: #242426;
            --card-border: #38383B;
            --header-bg: #1A1A1D;
            --accent-primary: #00BFFF;
            --accent-primary-hover: #009ACD;
            --accent-secondary: #66CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #0F4C81;
            --user-bubble-text: #00BFFF; /* Changed to accent */
            --ai-bubble-bg: #36454F;
            --ai-bubble-text: #00BFFF; /* Changed to accent */
            --sidebar-bg: #1A1A1D;
            --sidebar-border: #38383B;
            --sidebar-item-hover: #242426;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(36, 36, 38, 0.9);
            --conversation-bg: rgba(36, 36, 38, 0.95);
            --conversation-text: #00BFFF; /* Changed to accent */
            --conversation-indicator: #00BFFF;
            --code-block-bg: #36454F;
            --code-block-header-bg: #1A1A1D;
            --code-block-border: #38383B;

            background-color: var(--bg-primary);
        }

        /* Urban Pulse Theme: Light Mode */
        body[data-theme="urban-pulse-light"] {
            --bg-primary: #F2F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #1E90FF; /* Changed to accent */
            --text-secondary: #777777;
            --border-color: #DDE2E8;
            --card-bg: #FFFFFF;
            --card-border: #DDE2E8;
            --header-bg: #E8ECF2;
            --accent-primary: #1E90FF;
            --accent-primary-hover: #107EEB;
            --accent-secondary: #63B2FF;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #CCE5FF;
            --user-bubble-text: #1E90FF; /* Changed to accent */
            --ai-bubble-bg: #E8F0F5;
            --ai-bubble-text: #1E90FF; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDE2E8;
            --sidebar-item-hover: #E8F0F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #1E90FF; /* Changed to accent */
            --conversation-indicator: #1E90FF;
            --code-block-bg: #E8F0F5;
            --code-block-header-bg: #E8ECF2;
            --code-block-border: #DDE2E8;

            background-color: var(--bg-primary);
        }

        /* Rustic Ember Theme: Dark Mode */
        body[data-theme="rustic-ember-dark"] {
            --bg-primary: #3E2723;
            --bg-secondary: #4E342E;
            --text-primary: #D84315; /* Changed to accent */
            --text-secondary: #BCAAA4;
            --border-color: #5D4037;
            --card-bg: #4E342E;
            --card-border: #5D4037;
            --header-bg: #3E2723;
            --accent-primary: #D84315;
            --accent-primary-hover: #BF360C;
            --accent-secondary: #FF8A65;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #8D6E63;
            --user-bubble-text: #D84315; /* Changed to accent */
            --ai-bubble-bg: #5D4037;
            --ai-bubble-text: #D84315; /* Changed to accent */
            --sidebar-bg: #3E2723;
            --sidebar-border: #5D4037;
            --sidebar-item-hover: #4E342E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(78, 52, 46, 0.9);
            --conversation-bg: rgba(78, 52, 46, 0.95);
            --conversation-text: #D84315; /* Changed to accent */
            --conversation-indicator: #D84315;
            --code-block-bg: #5D4037;
            --code-block-header-bg: #3E2723;
            --code-block-border: #5D4037;

            background-color: var(--bg-primary);
        }

        /* Rustic Ember Theme: Light Mode */
        body[data-theme="rustic-ember-light"] {
            --bg-primary: #F5E8DC;
            --bg-secondary: #FFFFFF;
            --text-primary: #E65100; /* Changed to accent */
            --text-secondary: #8D6E63;
            --border-color: #E6DCCD;
            --card-bg: #FFFFFF;
            --card-border: #E6DCCD;
            --header-bg: #F8EFE5;
            --accent-primary: #E65100;
            --accent-primary-hover: #D84315;
            --accent-secondary: #FFB74D;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #FFCCBC;
            --user-bubble-text: #E65100; /* Changed to accent */
            --ai-bubble-bg: #FBE9E7;
            --ai-bubble-text: #E65100; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E6DCCD;
            --sidebar-item-hover: #F8EFE5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #E65100; /* Changed to accent */
            --conversation-indicator: #E65100;
            --code-block-bg: #FBE9E7;
            --code-block-header-bg: #F8EFE5;
            --code-block-border: #E6DCCD;

            background-color: var(--bg-primary);
        }

        /* Neon Mirage Theme: Dark Mode */
        body[data-theme="neon-mirage-dark"] {
            --bg-primary: #05001C;
            --bg-secondary: #120033;
            --text-primary: #FF1493; /* Changed to accent */
            --text-secondary: #8A2BE2;
            --border-color: #2F004F;
            --card-bg: #1A0040;
            --card-border: #2F004F;
            --header-bg: #120033;
            --accent-primary: #FF1493;
            --accent-primary-hover: #C7007C;
            --accent-secondary: #00BFFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #4B0082;
            --user-bubble-text: #FF1493; /* Changed to accent */
            --ai-bubble-bg: #2E0854;
            --ai-bubble-text: #FF1493; /* Changed to accent */
            --sidebar-bg: #120033;
            --sidebar-border: #2F004F;
            --sidebar-item-hover: #1A0040;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(26, 0, 64, 0.9);
            --conversation-bg: rgba(26, 0, 64, 0.95);
            --conversation-text: #FF1493; /* Changed to accent */
            --conversation-indicator: #FF1493;
            --code-block-bg: #2E0854;
            --code-block-header-bg: #120033;
            --code-block-border: #2F004F;

            background-color: var(--bg-primary);
        }

        /* Neon Mirage Theme: Light Mode */
        body[data-theme="neon-mirage-light"] {
            --bg-primary: #F8F0FF;
            --bg-secondary: #FFFFFF;
            --text-primary: #FF69B4; /* Changed to accent */
            --text-secondary: #663399;
            --border-color: #EBD9FC;
            --card-bg: #FFFFFF;
            --card-border: #EBD9FC;
            --header-bg: #F2E0FF;
            --accent-primary: #FF69B4;
            --accent-primary-hover: #E0509B;
            --accent-secondary: #87CEEB;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #FCE4EC;
            --user-bubble-text: #FF69B4; /* Changed to accent */
            --ai-bubble-bg: #F3E5F5;
            --ai-bubble-text: #FF69B4; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EBD9FC;
            --sidebar-item-hover: #F2E0FF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #FF69B4; /* Changed to accent */
            --conversation-indicator: #FF69B4;
            --code-block-bg: #F3E5F5;
            --code-block-header-bg: #F2E0FF;
            --code-block-border: #EBD9FC;

            background-color: var(--bg-primary);
        }

        /* Ivory Bloom Theme: Dark Mode */
        body[data-theme="ivory-bloom-dark"] {
            --bg-primary: #2B2D42;
            --bg-secondary: #4A4E69;
            --text-primary: #9B59B6; /* Changed to accent */
            --text-secondary: #A0A4B8;
            --border-color: #5D607E;
            --card-bg: #4A4E69;
            --card-border: #5D607E;
            --header-bg: #373A50;
            --accent-primary: #9B59B6;
            --accent-primary-hover: #8E44AD;
            --accent-secondary: #66CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #7C4F9B;
            --user-bubble-text: #9B59B6; /* Changed to accent */
            --ai-bubble-bg: #5D607E;
            --ai-bubble-text: #9B59B6; /* Changed to accent */
            --sidebar-bg: #2B2D42;
            --sidebar-border: #5D607E;
            --sidebar-item-hover: #373A50;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(74, 78, 105, 0.9);
            --conversation-bg: rgba(74, 78, 105, 0.95);
            --conversation-text: #9B59B6; /* Changed to accent */
            --conversation-indicator: #9B59B6;
            --code-block-bg: #5D607E;
            --code-block-header-bg: #373A50;
            --code-block-border: #5D607E;

            background-color: var(--bg-primary);
        }

        /* Ivory Bloom Theme: Light Mode */
        body[data-theme="ivory-bloom-light"] {
            --bg-primary: #FDFDFD;
            --bg-secondary: #FFFFFF;
            --text-primary: #8E44AD; /* Changed to accent */
            --text-secondary: #777777;
            --border-color: #EAEAEA;
            --card-bg: #FFFFFF;
            --card-border: #EAEAEA;
            --header-bg: #F5F5F5;
            --accent-primary: #8E44AD;
            --accent-primary-hover: #7F3C9E;
            --accent-secondary: #BA68C8;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #F2E6F7;
            --user-bubble-text: #8E44AD; /* Changed to accent */
            --ai-bubble-bg: #EAE0F0;
            --ai-bubble-text: #8E44AD; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EAEAEA;
            --sidebar-item-hover: #F5F5F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #8E44AD; /* Changed to accent */
            --conversation-indicator: #8E44AD;
            --code-block-bg: #EAE0F0;
            --code-block-header-bg: #F5F5F5;
            --code-block-border: #EAEAEA;

            background-color: var(--bg-primary);
        }

        /* Obsidian Night Theme: Dark Mode */
        body[data-theme="obsidian-night-dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1E1E1E;
            --text-primary: #BB86FC; /* Changed to accent */
            --text-secondary: #A0A0A0;
            --border-color: #333333;
            --card-bg: #1E1E1E;
            --card-border: #333333;
            --header-bg: #121212;
            --accent-primary: #BB86FC;
            --accent-primary-hover: #9E65E2;
            --accent-secondary: #03DAC6;
            --accent-error: #CF6679;
            --accent-success: #03DAC6;
            --user-bubble-bg: #3700B3;
            --user-bubble-text: #BB86FC; /* Changed to accent */
            --ai-bubble-bg: #2C2C2C;
            --ai-bubble-text: #BB86FC; /* Changed to accent */
            --sidebar-bg: #121212;
            --sidebar-border: #333333;
            --sidebar-item-hover: #1E1E1E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(30, 30, 30, 0.9);
            --conversation-bg: rgba(30, 30, 30, 0.95);
            --conversation-text: #BB86FC; /* Changed to accent */
            --conversation-indicator: #BB86FC;
            --code-block-bg: #2C2C2C;
            --code-block-header-bg: #121212;
            --code-block-border: #333333;

            background-color: var(--bg-primary);
        }

        /* Obsidian Night Theme: Light Mode */
        body[data-theme="obsidian-night-light"] {
            --bg-primary: #E0E0E0;
            --bg-secondary: #FFFFFF;
            --text-primary: #6200EE; /* Changed to accent */
            --text-secondary: #6B6B6B;
            --border-color: #C0C0C0;
            --card-bg: #FFFFFF;
            --card-border: #C0C0C0;
            --header-bg: #D0D0D0;
            --accent-primary: #6200EE;
            --accent-primary-hover: #5B00D9;
            --accent-secondary: #018786;
            --accent-error: #B00020;
            --accent-success: #018786;
            --user-bubble-bg: #BBDEFB;
            --user-bubble-text: #6200EE; /* Changed to accent */
            --ai-bubble-bg: #E0E0E0;
            --ai-bubble-text: #6200EE; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #C0C0C0;
            --sidebar-item-hover: #D0D0D0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #6200EE; /* Changed to accent */
            --conversation-indicator: #6200EE;
            --code-block-bg: #E0E0E0;
            --code-block-header-bg: #D0D0D0;
            --code-block-border: #C0C0C0;

            background-color: var(--bg-primary);
        }

        /* Solar Dawn Theme: Dark Mode */
        body[data-theme="solar-dawn-dark"] {
            --bg-primary: #1A0E2A;
            --bg-secondary: #2C1840;
            --text-primary: #FF5722; /* Changed to accent */
            --text-secondary: #D8BFD8;
            --border-color: #40265B;
            --card-bg: #2C1840;
            --card-border: #40265B;
            --header-bg: #1A0E2A;
            --accent-primary: #FF5722;
            --accent-primary-hover: #E64A19;
            --accent-secondary: #FFCC80;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #7C4F9B;
            --user-bubble-text: #FF5722; /* Changed to accent */
            --ai-bubble-bg: #40265B;
            --ai-bubble-text: #FF5722; /* Changed to accent */
            --sidebar-bg: #1A0E2A;
            --sidebar-border: #40265B;
            --sidebar-item-hover: #2C1840;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(44, 24, 64, 0.9);
            --conversation-bg: rgba(44, 24, 64, 0.95);
            --conversation-text: #FF5722; /* Changed to accent */
            --conversation-indicator: #FF5722;
            --code-block-bg: #40265B;
            --code-block-header-bg: #1A0E2A;
            --code-block-border: #40265B;

            background-color: var(--bg-primary);
        }

        /* Solar Dawn Theme: Light Mode */
        body[data-theme="solar-dawn-light"] {
            --bg-primary: #FFFBEA;
            --bg-secondary: #FFFFFF;
            --text-primary: #FF8F00; /* Changed to accent */
            --text-secondary: #8D6E63;
            --border-color: #FFE0B2;
            --card-bg: #FFFFFF;
            --card-border: #FFE0B2;
            --header-bg: #FFF3E0;
            --accent-primary: #FF8F00;
            --accent-primary-hover: #FF6F00;
            --accent-secondary: #FFD54F;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #FFE0B2;
            --user-bubble-text: #FF8F00; /* Changed to accent */
            --ai-bubble-bg: #FFF3E0;
            --ai-bubble-text: #FF8F00; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #FFE0B2;
            --sidebar-item-hover: #FFF3E0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #FF8F00; /* Changed to accent */
            --conversation-indicator: #FF8F00;
            --code-block-bg: #FFF3E0;
            --code-block-header-bg: #FFFBEA;
            --code-block-border: #FFE0B2;

            background-color: var(--bg-primary);
        }

        /* Aurora Drift Theme: Dark Mode */
        body[data-theme="aurora-drift-dark"] {
            --bg-primary: #0A192F;
            --bg-secondary: #172A45;
            --text-primary: #66CCCC; /* Changed to accent */
            --text-secondary: #A0B3D6;
            --border-color: #2F476D;
            --card-bg: #172A45;
            --card-border: #2F476D;
            --header-bg: #0A192F;
            --accent-primary: #66CCCC;
            --accent-primary-hover: #55B3B3;
            --accent-secondary: #99CCFF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #336699;
            --user-bubble-text: #66CCCC; /* Changed to accent */
            --ai-bubble-bg: #2F476D;
            --ai-bubble-text: #66CCCC; /* Changed to accent */
            --sidebar-bg: #0A192F;
            --sidebar-border: #2F476D;
            --sidebar-item-hover: #172A45;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(23, 42, 69, 0.9);
            --conversation-bg: rgba(23, 42, 69, 0.95);
            --conversation-text: #66CCCC; /* Changed to accent */
            --conversation-indicator: #66CCCC;
            --code-block-bg: #2F476D;
            --code-block-header-bg: #0A192F;
            --code-block-border: #2F476D;

            background-color: var(--bg-primary);
        }

        /* Aurora Drift Theme: Light Mode */
        body[data-theme="aurora-drift-light"] {
            --bg-primary: #E0F2F7;
            --bg-secondary: #FFFFFF;
            --text-primary: #00BCD4; /* Changed to accent */
            --text-secondary: #5E7A8A;
            --border-color: #B2EBF2;
            --card-bg: #FFFFFF;
            --card-border: #B2EBF2;
            --header-bg: #CCEEF0;
            --accent-primary: #00BCD4;
            --accent-primary-hover: #00ACC1;
            --accent-secondary: #4DD0E1;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #B2EBF2;
            --user-bubble-text: #00BCD4; /* Changed to accent */
            --ai-bubble-bg: #CCEEF0;
            --ai-bubble-text: #00BCD4; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #B2EBF2;
            --sidebar-item-hover: #CCEEF0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #00BCD4; /* Changed to accent */
            --conversation-indicator: #00BCD4;
            --code-block-bg: #CCEEF0;
            --code-block-header-bg: #E0F2F7;
            --code-block-border: #B2EBF2;

            background-color: var(--bg-primary);
        }
        /* Removed @keyframes aurora-move */

        /* Timeless Echo Theme: Dark Mode */
        body[data-theme="timeless-echo-dark"] {
            --bg-primary: #2C2C2C;
            --bg-secondary: #3D3D3D;
            --text-primary: #A57C52; /* Changed to accent */
            --text-secondary: #B0B0B0;
            --border-color: #555555;
            --card-bg: #3D3D3D;
            --card-border: #555555;
            --header-bg: #2C2C2C;
            --accent-primary: #A57C52;
            --accent-primary-hover: #8B653D;
            --accent-secondary: #C8A87C;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #785A3D;
            --user-bubble-text: #A57C52; /* Changed to accent */
            --ai-bubble-bg: #555555;
            --ai-bubble-text: #A57C52; /* Changed to accent */
            --sidebar-bg: #2C2C2C;
            --sidebar-border: #555555;
            --sidebar-item-hover: #3D3D3D;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(61, 61, 61, 0.9);
            --conversation-bg: rgba(61, 61, 61, 0.95);
            --conversation-text: #A57C52; /* Changed to accent */
            --conversation-indicator: #A57C52;
            --code-block-bg: #555555;
            --code-block-header-bg: #2C2C2C;
            --code-block-border: #555555;

            background-color: var(--bg-primary);
        }

        /* Timeless Echo Theme: Light Mode */
        body[data-theme="timeless-echo-light"] {
            --bg-primary: #FDF7E5;
            --bg-secondary: #FFFFFF;
            --text-primary: #8D6E63; /* Changed to accent */
            --text-secondary: #808080;
            --border-color: #E6E0D3;
            --card-bg: #FFFFFF;
            --card-border: #E6E0D3;
            --header-bg: #F5EFEB;
            --accent-primary: #8D6E63;
            --accent-primary-hover: #795548;
            --accent-secondary: #BCAAA4;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #D7CCC8;
            --user-bubble-text: #8D6E63; /* Changed to accent */
            --ai-bubble-bg: #EFEBE9;
            --ai-bubble-text: #8D6E63; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E6E0D3;
            --sidebar-item-hover: #F5EFEB;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #8D6E63; /* Changed to accent */
            --conversation-indicator: #8D6E63;
            --code-block-bg: #EFEBE9;
            --code-block-header-bg: #F5EFEB;
            --code-block-border: #E6E0D3;

            background-color: var(--bg-primary);
        }

        /* Mystic Void Theme: Dark Mode (Bonus Theme) */
        body[data-theme="mystic-void-dark"] {
            --bg-primary: #110B1D;
            --bg-secondary: #1F1731;
            --text-primary: #9400D3; /* Changed to accent */
            --text-secondary: #B29BCE;
            --border-color: #372A4F;
            --card-bg: #1F1731;
            --card-border: #372A4F;
            --header-bg: #110B1D;
            --accent-primary: #9400D3;
            --accent-primary-hover: #7B00B0;
            --accent-secondary: #8A2BE2;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #5B2C7B;
            --user-bubble-text: #9400D3; /* Changed to accent */
            --ai-bubble-bg: #372A4F;
            --ai-bubble-text: #9400D3; /* Changed to accent */
            --sidebar-bg: #110B1D;
            --sidebar-border: #372A4F;
            --sidebar-item-hover: #1F1731;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(31, 23, 49, 0.9);
            --conversation-bg: rgba(31, 23, 49, 0.95);
            --conversation-text: #9400D3; /* Changed to accent */
            --conversation-indicator: #9400D3;
            --code-block-bg: #372A4F;
            --code-block-header-bg: #110B1D;
            --code-block-border: #372A4F;

            background-color: var(--bg-primary);
        }

        /* Mystic Void Theme: Light Mode */
        body[data-theme="mystic-void-light"] {
            --bg-primary: #F7EDFF;
            --bg-secondary: #FFFFFF;
            --text-primary: #8A2BE2; /* Changed to accent */
            --text-secondary: #663399;
            --border-color: #EBD9FC;
            --card-bg: #FFFFFF;
            --card-border: #EBD9FC;
            --header-bg: #F2E0FF;
            --accent-primary: #8A2BE2;
            --accent-primary-hover: #7B1FB2;
            --accent-secondary: #9370DB;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #E6D2F2;
            --user-bubble-text: #8A2BE2; /* Changed to accent */
            --ai-bubble-bg: #F0E6F8;
            --ai-bubble-text: #8A2BE2; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #EBD9FC;
            --sidebar-item-hover: #F2E0FF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #8A2BE2; /* Changed to accent */
            --conversation-indicator: #8A2BE2;
            --code-block-bg: #F0E6F8;
            --code-block-header-bg: #F2E0FF;
            --code-block-border: #EBD9FC;

            background-color: var(--bg-primary);
        }

        /* Darkest Black & White Theme: Dark Mode (Corrected Bubbles & Icons) */
        body[data-theme="darkest-bw-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #111111;
            --text-primary: #E0E0E0; /* Changed to accent */
            --text-secondary: #AAAAAA;
            --border-color: #333333;
            --card-bg: #111111;
            --card-border: #333333;
            --header-bg: #0A0A0A;
            --accent-primary: #E0E0E0;
            --accent-primary-hover: #FFFFFF;
            --accent-secondary: #888888;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #222222;
            --user-bubble-text: #E0E0E0; /* Changed to accent */
            --ai-bubble-bg: #333333;
            --ai-bubble-text: #E0E0E0; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #333333;
            --sidebar-item-hover: #111111;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: #000000;
            --conversation-bg: #000000;
            --conversation-text: #E0E0E0; /* Changed to accent */
            --conversation-indicator: #FFFFFF;
            --code-block-bg: #333333;
            --code-block-header-bg: #0A0A0A;
            --code-block-border: #333333;

            background-image: none;
            background-color: var(--bg-primary);
        }

        /* Darkest Black & White Theme: Light Mode (Revised) */
        body[data-theme="darkest-bw-light"] {
            --bg-primary: #FFFFFF;
            --bg-secondary: #F0F0F0;
            --text-primary: #333333; /* Changed to accent */
            --text-secondary: #555555;
            --border-color: #DDDDDD;
            --card-bg: #F0F0F0;
            --card-border: #DDDDDD;
            --header-bg: #F5F5F5;
            --accent-primary: #333333;
            --accent-primary-hover: #000000;
            --accent-secondary: #777777;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #EEEEEE;
            --user-bubble-text: #333333; /* Changed to accent */
            --ai-bubble-bg: #DDDDDD;
            --ai-bubble-text: #333333; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDDDDD;
            --sidebar-item-hover: #F0F0F0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: #F0F0F0;
            --conversation-bg: #FFFFFF;
            --conversation-text: #333333; /* Changed to accent */
            --conversation-indicator: #000000;
            --code-block-bg: #DDDDDD;
            --code-block-header-bg: #F5F5F5;
            --code-block-border: #DDDDDD;

            background-image: none;
            background-color: var(--bg-primary);
        }

        /* --- Coder's Dark Theme (Default) --- */
        body[data-theme="coder-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #0A0A0A;
            --text-primary: #00BCD4; /* Changed to accent */
            --text-secondary: #8B949E;
            --border-color: #30363D;
            --card-bg: #0A0A0A;
            --card-border: #30363D;
            --header-bg: #000000;
            --accent-primary: #00BCD4;
            --accent-primary-hover: #0097A7;
            --accent-secondary: #8A2BE2;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #2C3E50;
            --user-bubble-text: #00BCD4; /* Changed to accent */
            --ai-bubble-bg: #1A1A1A;
            --ai-bubble-text: #00BCD4; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #30363D;
            --sidebar-item-hover: #0A0A0A;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #00BCD4; /* Changed to accent */
            --conversation-indicator: #00BCD4;
            --code-block-bg: #1A1A1A;
            --code-block-header-bg: #27272A;
            --code-block-border: #3F3F46;

            background-color: var(--bg-primary);
        }

        /* Coder's Light Theme */
        body[data-theme="coder-light"] {
            --bg-primary: #F0F2F5;
            --bg-secondary: #FFFFFF;
            --text-primary: #008C9D; /* Changed to accent */
            --text-secondary: #718096;
            --border-color: #DDE2E8;
            --card-bg: #FFFFFF;
            --card-border: #DDE2E8;
            --header-bg: #E8EDF2;
            --accent-primary: #008C9D;
            --accent-primary-hover: #006D7D;
            --accent-secondary: #6A1B9A;
            --accent-error: #D32F2F;
            --accent-success: #388E3C;
            --user-bubble-bg: #E0F7FA;
            --user-bubble-text: #008C9D; /* Changed to accent */
            --ai-bubble-bg: #F0F4F8;
            --ai-bubble-text: #008C9D; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #DDE2E8;
            --sidebar-item-hover: #F0F2F5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #008C9D; /* Changed to accent */
            --conversation-indicator: #008C9D;
            --code-block-bg: #F5F5F5;
            --code-block-header-bg: #ECEFF1;
            --code-block-border: #CFD8DC;

            background-color: var(--bg-primary);
        }

        /* --- Cyberpunk Theme --- */
        body[data-theme="cyberpunk-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #1A0F24;
            --text-primary: #00FFFF; /* Changed to accent */
            --text-secondary: #A08AB2;
            --border-color: #3A1D4D;
            --card-bg: #1A0F24;
            --card-border: #3A1D4D;
            --header-bg: #0A050F;
            --accent-primary: #00FFFF;
            --accent-primary-hover: #00CED1;
            --accent-secondary: #FF1493;
            --accent-error: #FF4500;
            --accent-success: #32CD32;
            --user-bubble-bg: #3A204D;
            --user-bubble-text: #00FFFF; /* Changed to accent */
            --ai-bubble-bg: #100814;
            --ai-bubble-text: #00FFFF; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #3A1D4D;
            --sidebar-item-hover: #1A0F24;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(10, 5, 15, 0.9);
            --conversation-bg: rgba(10, 5, 15, 0.95);
            --conversation-text: #00FFFF; /* Changed to accent */
            --conversation-indicator: #00FFFF;
            --code-block-bg: #100814;
            --code-block-header-bg: #20102A;
            --code-block-border: #3A1D4D;

            background-color: var(--bg-primary);
        }
        body[data-theme="cyberpunk-light"] {
            --bg-primary: #F0F8FF;
            --bg-secondary: #FFFFFF;
            --text-primary: #00CED1; /* Changed to accent */
            --text-secondary: #6A5ACD;
            --border-color: #ADD8E6;
            --card-bg: #FFFFFF;
            --card-border: #ADD8E6;
            --header-bg: #E0F2F7;
            --accent-primary: #00CED1;
            --accent-primary-hover: #00BFFF;
            --accent-secondary: #FF69B4;
            --accent-error: #DC143C;
            --accent-success: #3CB371;
            --user-bubble-bg: #E0FFFF;
            --user-bubble-text: #00CED1; /* Changed to accent */
            --ai-bubble-bg: #F0F8FF;
            --ai-bubble-text: #00CED1; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #ADD8E6;
            --sidebar-item-hover: #E0F2F7;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #00CED1; /* Changed to accent */
            --conversation-indicator: #00CED1;
            --code-block-bg: #E0FFFF;
            --code-block-header-bg: #ADD8E6;
            --code-block-border: #87CEEB;

            background-color: var(--bg-primary);
        }

        /* --- Matrix Code Theme (Retained original settings as the template) --- */
        body[data-theme="matrix-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #0A0A0A;
            --text-primary: #00FF00;
            --text-secondary: #008000;
            --border-color: #004000;
            --card-bg: #0A0A0A;
            --card-border: #004000;
            --header-bg: #000000;
            --accent-primary: #00FF00;
            --accent-primary-hover: #00CC00;
            --accent-secondary: #00FFFF;
            --accent-error: #FF0000;
            --accent-success: #00FF00;
            --user-bubble-bg: #001A00;
            --user-bubble-text: #00FF00;
            --ai-bubble-bg: #000500;
            --ai-bubble-text: #00FF00;
            --sidebar-bg: #000000;
            --sidebar-border: #004000;
            --sidebar-item-hover: #001500;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #00FF00;
            --conversation-indicator: #00FF00;
            --code-block-bg: #000A00;
            --code-block-header-bg: #001000;
            --code-block-border: #002000;

            background-color: var(--bg-primary);
        }
        body[data-theme="matrix-light"] {
            --bg-primary: #FFFFFF;
            --bg-secondary: #F0F0F0;
            --text-primary: #008000; /* Already uses accent color */
            --text-secondary: #404040;
            --border-color: #D0D0D0;
            --card-bg: #F0F0F0;
            --card-border: #D0D0D0;
            --header-bg: #E0E0E0;
            --accent-primary: #008000;
            --accent-primary-hover: #006000;
            --accent-secondary: #00AAAA;
            --accent-error: #CC0000;
            --accent-success: #00AA00;
            --user-bubble-bg: #E0FFE0;
            --user-bubble-text: #008000; /* Changed to accent */
            --ai-bubble-bg: #F0FFF0;
            --ai-bubble-text: #008000; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #D0D0D0;
            --sidebar-item-hover: #E0E0E0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #008000; /* Changed to accent */
            --conversation-indicator: #008000;
            --code-block-bg: #F5FFF5;
            --code-block-header-bg: #E0FFE0;
            --code-block-border: #C0D0C0;

            background-color: var(--bg-primary);
        }

        /* --- Solarized Theme --- */
        body[data-theme="solarized-light"] {
            --bg-primary: #FDF6E3;
            --bg-secondary: #EEE8D5;
            --text-primary: #2AA198; /* Changed to accent */
            --text-secondary: #657B83;
            --border-color: #93A1A1;
            --card-bg: #EEE8D5;
            --card-border: #93A1A1;
            --header-bg: #FDF6E3;
            --accent-primary: #2AA198;
            --accent-primary-hover: #268BD2;
            --accent-secondary: #DC322F;
            --accent-error: #DC322F;
            --accent-success: #859900;
            --user-bubble-bg: #839496;
            --user-bubble-text: #2AA198; /* Changed to accent */
            --ai-bubble-bg: #E0E0D0;
            --ai-bubble-text: #2AA198; /* Changed to accent */
            --sidebar-bg: #FDF6E3;
            --sidebar-border: #93A1A1;
            --sidebar-item-hover: #EEE8D5;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #2AA198; /* Changed to accent */
            --conversation-indicator: #2AA198;
            --code-block-bg: #EEE8D5;
            --code-block-header-bg: #FDF6E3;
            --code-block-border: #D0D0C0;

            background-color: var(--bg-primary);
        }
        body[data-theme="solarized-dark"] {
            --bg-primary: #002B36;
            --bg-secondary: #073642;
            --text-primary: #2AA198; /* Changed to accent */
            --text-secondary: #839496;
            --border-color: #586E75;
            --card-bg: #073642;
            --card-border: #586E75;
            --header-bg: #002B36;
            --accent-primary: #2AA198;
            --accent-primary-hover: #268BD2;
            --accent-secondary: #DC322F;
            --accent-error: #DC322F;
            --accent-success: #859900;
            --user-bubble-bg: #586E75;
            --user-bubble-text: #2AA198; /* Changed to accent */
            --ai-bubble-bg: #073642;
            --ai-bubble-text: #2AA198; /* Changed to accent */
            --sidebar-bg: #002B36;
            --sidebar-border: #586E75;
            --sidebar-item-hover: #073642;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 43, 54, 0.9);
            --conversation-bg: rgba(0, 43, 54, 0.95);
            --conversation-text: #2AA198; /* Changed to accent */
            --conversation-indicator: #2AA198;
            --code-block-bg: #073642;
            --code-block-header-bg: #002B36;
            --code-block-border: #586E75;

            background-color: var(--bg-primary);
        }

        /* --- Dracula Theme --- */
        body[data-theme="dracula-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #282A36;
            --text-primary: #BD93F9; /* Changed to accent */
            --text-secondary: #6272A4;
            --border-color: #44475A;
            --card-bg: #282A36;
            --card-border: #44475A;
            --header-bg: #000000;
            --accent-primary: #BD93F9;
            --accent-primary-hover: #FF79C6;
            --accent-secondary: #50FA7B;
            --accent-error: #FF5555;
            --accent-success: #50FA7B;
            --user-bubble-bg: #44475A;
            --user-bubble-text: #BD93F9; /* Changed to accent */
            --ai-bubble-bg: #1A1C25;
            --ai-bubble-text: #BD93F9; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #44475A;
            --sidebar-item-hover: #282A36;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #BD93F9; /* Changed to accent */
            --conversation-indicator: #BD93F9;
            --code-block-bg: #1A1C25;
            --code-block-header-bg: #2F313E;
            --code-block-border: #44475A;

            background-color: var(--bg-primary);
        }
        body[data-theme="dracula-light"] {
            --bg-primary: #F8F8F2;
            --bg-secondary: #F0F0E0;
            --text-primary: #FF79C6; /* Changed to accent */
            --text-secondary: #6272A4;
            --border-color: #CCDEF2;
            --card-bg: #F0F0E0;
            --card-border: #CCDEF2;
            --header-bg: #E8E8E0;
            --accent-primary: #FF79C6;
            --accent-primary-hover: #BD93F9;
            --accent-secondary: #50FA7B;
            --accent-error: #FF5555;
            --accent-success: #50FA7B;
            --user-bubble-bg: #CCDEF2;
            --user-bubble-text: #FF79C6; /* Changed to accent */
            --ai-bubble-bg: #E8E8E0;
            --ai-bubble-text: #FF79C6; /* Changed to accent */
            --sidebar-bg: #F8F8F2;
            --sidebar-border: #CCDEF2;
            --sidebar-item-hover: #F0F0E0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #FF79C6; /* Changed to accent */
            --conversation-indicator: #FF79C6;
            --code-block-bg: #E8E8E0;
            --code-block-header-bg: #D8D8D0;
            --code-block-border: #C2C2C0;

            background-color: var(--bg-primary);
        }

        /* --- Monokai Pro Theme --- */
        body[data-theme="monokai-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #2D2A2E;
            --text-primary: #A6E22E; /* Changed to accent */
            --text-secondary: #75715E;
            --border-color: #49483E;
            --card-bg: #2D2A2E;
            --card-border: #49483E;
            --header-bg: #000000;
            --accent-primary: #A6E22E;
            --accent-primary-hover: #E6DB74;
            --accent-secondary: #FD971F;
            --accent-error: #F92672;
            --accent-success: #A6E22E;
            --user-bubble-bg: #49483E;
            --user-bubble-text: #A6E22E; /* Changed to accent */
            --ai-bubble-bg: #1A1A1A;
            --ai-bubble-text: #A6E22E; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #49483E;
            --sidebar-item-hover: #2D2A2E;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #A6E22E; /* Changed to accent */
            --conversation-indicator: #A6E22E;
            --code-block-bg: #1A1A1A;
            --code-block-header-bg: #27252A;
            --code-block-border: #3F3C38;

            background-color: var(--bg-primary);
        }
        body[data-theme="monokai-light"] {
            --bg-primary: #FCFCFA;
            --bg-secondary: #F5F5F0;
            --text-primary: #F92672; /* Changed to accent */
            --text-secondary: #75715E;
            --border-color: #D0D0CB;
            --card-bg: #F5F5F0;
            --card-border: #D0D0CB;
            --header-bg: #EEEEEC;
            --accent-primary: #F92672;
            --accent-primary-hover: #A6E22E;
            --accent-secondary: #FD971F;
            --accent-error: #CC3333;
            --accent-success: #A6E22E;
            --user-bubble-bg: #E0E0D8;
            --user-bubble-text: #F92672; /* Changed to accent */
            --ai-bubble-bg: #EEEEEC;
            --ai-bubble-text: #F92672; /* Changed to accent */
            --sidebar-bg: #FCFCFA;
            --sidebar-border: #D0D0CB;
            --sidebar-item-hover: #F5F5F0;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #F92672; /* Changed to accent */
            --conversation-indicator: #F92672;
            --code-block-bg: #EEEEEC;
            --code-block-header-bg: #E0E0D8;
            --code-block-border: #C0C0B8;

            background-color: var(--bg-primary);
        }

        /* --- Nord Theme --- */
        body[data-theme="nord-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #2E3440;
            --text-primary: #88C0D0; /* Changed to accent */
            --text-secondary: #ECEFF4;
            --border-color: #4C566A;
            --card-bg: #2E3440;
            --card-border: #4C566A;
            --header-bg: #000000;
            --accent-primary: #88C0D0;
            --accent-primary-hover: #81A1C1;
            --accent-secondary: #B48EAD;
            --accent-error: #BF616A;
            --accent-success: #A3BE8C;
            --user-bubble-bg: #4C566A;
            --user-bubble-text: #88C0D0; /* Changed to accent */
            --ai-bubble-bg: #1A1D23;
            --ai-bubble-text: #88C0D0; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #4C566A;
            --sidebar-item-hover: #2E3440;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #88C0D0; /* Changed to accent */
            --conversation-indicator: #88C0D0;
            --code-block-bg: #1A1D23;
            --code-block-header-bg: #242933;
            --code-block-border: #4C566A;

            background-color: var(--bg-primary);
        }
        body[data-theme="nord-light"] {
            --bg-primary: #ECEFF4;
            --bg-secondary: #D8DEE9;
            --text-primary: #5E81AC; /* Changed to accent */
            --text-secondary: #4C566A;
            --border-color: #B4BFCD;
            --card-bg: #D8DEE9;
            --card-border: #B4BFCD;
            --header-bg: #DEE3EB;
            --accent-primary: #5E81AC;
            --accent-primary-hover: #81A1C1;
            --accent-secondary: #B48EAD;
            --accent-error: #BF616A;
            --accent-success: #A3BE8C;
            --user-bubble-bg: #AABECF;
            --user-bubble-text: #5E81AC; /* Changed to accent */
            --ai-bubble-bg: #DEE3EB;
            --ai-bubble-text: #5E81AC; /* Changed to accent */
            --sidebar-bg: #ECEFF4;
            --sidebar-border: #B4BFCD;
            --sidebar-item-hover: #D8DEE9;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #5E81AC; /* Changed to accent */
            --conversation-indicator: #5E81AC;
            --code-block-bg: #DEE3EB;
            --code-block-header-bg: #C0C7D1;
            --code-block-border: #B4BFCD;

            background-color: var(--bg-primary);
        }

        /* --- Gruvbox Theme --- */
        body[data-theme="gruvbox-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #282828;
            --text-primary: #83A598; /* Changed to accent */
            --text-secondary: #A89984;
            --border-color: #504945;
            --card-bg: #282828;
            --card-border: #504945;
            --header-bg: #000000;
            --accent-primary: #83A598;
            --accent-primary-hover: #B8BB26;
            --accent-secondary: #FABD2F;
            --accent-error: #FB4934;
            --accent-success: #B8BB26;
            --user-bubble-bg: #504945;
            --user-bubble-text: #83A598; /* Changed to accent */
            --ai-bubble-bg: #1D2021;
            --ai-bubble-text: #83A598; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #504945;
            --sidebar-item-hover: #282828;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #83A598; /* Changed to accent */
            --conversation-indicator: #83A598;
            --code-block-bg: #1D2021;
            --code-block-header-bg: #32302F;
            --code-block-border: #504945;

            background-color: var(--bg-primary);
        }
        body[data-theme="gruvbox-light"] {
            --bg-primary: #FBF1C7;
            --bg-secondary: #FEF6E4;
            --text-primary: #427B58; /* Changed to accent */
            --text-secondary: #7C6F64;
            --border-color: #BDAEAA;
            --card-bg: #FEF6E4;
            --card-border: #BDAEAA;
            --header-bg: #EBDBB2;
            --accent-primary: #427B58;
            --accent-primary-hover: #8EC07C;
            --accent-secondary: #D79921;
            --accent-error: #CC241D;
            --accent-success: #8EC07C;
            --user-bubble-bg: #D5C4A1;
            --user-bubble-text: #427B58; /* Changed to accent */
            --ai-bubble-bg: #EBDBB2;
            --ai-bubble-text: #427B58; /* Changed to accent */
            --sidebar-bg: #FBF1C7;
            --sidebar-border: #BDAEAA;
            --sidebar-item-hover: #EBDBB2;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #427B58; /* Changed to accent */
            --conversation-indicator: #427B58;
            --code-block-bg: #EBDBB2;
            --code-block-header-bg: #D5C4A1;
            --code-block-border: #BDAEAA;

            background-color: var(--bg-primary);
        }

        /* --- Catppuccin Theme --- */
        body[data-theme="catppuccin-dark"] {
            --bg-primary: #000000;
            --bg-secondary: #24273A;
            --text-primary: #8BD5CA; /* Changed to accent */
            --text-secondary: #A5ADCE;
            --border-color: #494D64;
            --card-bg: #24273A;
            --card-border: #494D64;
            --header-bg: #000000;
            --accent-primary: #8BD5CA;
            --accent-primary-hover: #B7BFEF;
            --accent-secondary: #F4B8E4;
            --accent-error: #ED8796;
            --accent-success: #A6DA95;
            --user-bubble-bg: #494D64;
            --user-bubble-text: #8BD5CA; /* Changed to accent */
            --ai-bubble-bg: #1A1D2A;
            --ai-bubble-text: #8BD5CA; /* Changed to accent */
            --sidebar-bg: #000000;
            --sidebar-border: #494D64;
            --sidebar-item-hover: #24273A;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(0, 0, 0, 0.9);
            --conversation-bg: rgba(0, 0, 0, 0.95);
            --conversation-text: #8BD5CA; /* Changed to accent */
            --conversation-indicator: #8BD5CA;
            --code-block-bg: #1A1D2A;
            --code-block-header-bg: #2E3243;
            --code-block-border: #494D64;

            background-color: var(--bg-primary);
        }
        body[data-theme="catppuccin-light"] {
            --bg-primary: #EFF1F5;
            --bg-secondary: #E6E9EF;
            --text-primary: #179299; /* Changed to accent */
            --text-secondary: #5C5F77;
            --border-color: #CBD0E1;
            --card-bg: #E6E9EF;
            --card-border: #CBD0E1;
            --header-bg: #EAECEF;
            --accent-primary: #179299;
            --accent-primary-hover: #7287FD;
            --accent-secondary: #EA76CB;
            --accent-error: #E64553;
            --accent-success: #40A02B;
            --user-bubble-bg: #CBD0E1;
            --user-bubble-text: #179299; /* Changed to accent */
            --ai-bubble-bg: #EAECEF;
            --ai-bubble-text: #179299; /* Changed to accent */
            --sidebar-bg: #EFF1F5;
            --sidebar-border: #CBD0E1;
            --sidebar-item-hover: #E6E9EF;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.8);
            --conversation-bg: rgba(255, 255, 255, 0.95);
            --conversation-text: #179299; /* Changed to accent */
            --conversation-indicator: #179299;
            --code-block-bg: #EAECEF;
            --code-block-header-bg: #D4D7E2;
            --code-block-border: #C8CDDD;

            background-color: var(--bg-primary);
        }

        /* --- NEW THEMES START HERE --- */

        /* Cosmic Nexus Theme: Dark Mode (Inspired by Cosmic Neon) */
        body[data-theme="cosmic-nexus-dark"] {
            --bg-primary: #05050A;
            --bg-secondary: #101018;
            --text-primary: #00F5FF; /* Changed to accent */
            --text-secondary: #94A3B8;
            --border-color: #2A2A3A;
            --card-bg: #101018;
            --card-border: #2A2A3A;
            --header-bg: #0A0A10;
            --accent-primary: #00F5FF;
            --accent-primary-hover: #00CED1;
            --accent-secondary: #D400FF;
            --accent-error: #FF4500;
            --accent-success: #0AFF9D;
            --user-bubble-bg: #003344;
            --user-bubble-text: #00F5FF; /* Changed to accent */
            --ai-bubble-bg: #18052A;
            --ai-bubble-text: #00F5FF; /* Changed to accent */
            --sidebar-bg: #101018;
            --sidebar-border: #2A2A3A;
            --sidebar-item-hover: #1A1A22;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(16, 16, 24, 0.9);
            --conversation-bg: rgba(5, 5, 10, 0.95);
            --conversation-text: #00F5FF; /* Changed to accent */
            --conversation-indicator: #00F5FF;
            --code-block-bg: #18052A;
            --code-block-header-bg: #0A0A10;
            --code-block-border: #2A2A3A;

            background-color: var(--bg-primary);
            background-image: radial-gradient(circle at 15% 15%, rgba(0,245,255,0.08) 0%, transparent 25%),
                              radial-gradient(circle at 85% 85%, rgba(212,0,255,0.08) 0%, transparent 25%),
                              url('data:image/svg+xml;utf8,<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="smallGrid" width="16" height="16" patternUnits="userSpaceOnUse"><path d="M 16 0 L 0 0 L 0 16" fill="none" stroke="rgba(0,245,255,0.05)" stroke-width="0.5"/></pattern><pattern id="grid" width="80" height="80" patternUnits="userSpaceOnUse"><rect width="80" height="80" fill="url(%23smallGrid)"/><path d="M 80 0 L 0 0 L 0 80" fill="none" stroke="rgba(0,245,255,0.08)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
            background-size: cover, cover, auto;
            background-blend-mode: overlay, overlay, multiply;
        }

        /* Cosmic Nexus Theme: Light Mode (Derived) */
        body[data-theme="cosmic-nexus-light"] {
            --bg-primary: #F0F8FF;
            --bg-secondary: #FFFFFF;
            --text-primary: #00CED1; /* Changed to accent */
            --text-secondary: #4B5563;
            --border-color: #E5E7EB;
            --card-bg: #FFFFFF;
            --card-border: #E5E7EB;
            --header-bg: #EAF0F8;
            --accent-primary: #00CED1;
            --accent-primary-hover: #00BFFF;
            --accent-secondary: #9370DB;
            --accent-error: #FF4500;
            --accent-success: #0AFF9D;
            --user-bubble-bg: #E0FFFF;
            --user-bubble-text: #00CED1; /* Changed to accent */
            --ai-bubble-bg: #F3F8FF;
            --ai-bubble-text: #00CED1; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E5E7EB;
            --sidebar-item-hover: #EAF0F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.85);
            --conversation-bg: rgba(255, 255, 255, 0.9);
            --conversation-text: #00CED1; /* Changed to accent */
            --conversation-indicator: #00CED1;
            --code-block-bg: #F3F8FF;
            --code-block-header-bg: #EAF0F8;
            --code-block-border: #E5E7EB;

            background-color: var(--bg-primary);
        }

        /* Starship Minimal Theme: Dark Mode (Inspired by Starship Minimal) */
        body[data-theme="starship-minimal-dark"] {
            --bg-primary: #0D1117;
            --bg-secondary: #161B22;
            --text-primary: #2F81F7; /* Changed to accent */
            --text-secondary: #8B949E;
            --border-color: #30363D;
            --card-bg: #161B22;
            --card-border: #30363D;
            --header-bg: #0D1117;
            --accent-primary: #2F81F7;
            --accent-primary-hover: #1C6EDD;
            --accent-secondary: #58A6FF;
            --accent-error: #F87171;
            --accent-success: #4ADE80;
            --user-bubble-bg: #1F385B;
            --user-bubble-text: #2F81F7; /* Changed to accent */
            --ai-bubble-bg: #21262D;
            --ai-bubble-text: #2F81F7; /* Changed to accent */
            --sidebar-bg: #161B22;
            --sidebar-border: #30363D;
            --sidebar-item-hover: #21262D;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(13, 17, 23, 0.9);
            --conversation-bg: rgba(13, 17, 23, 0.95);
            --conversation-text: #2F81F7; /* Changed to accent */
            --conversation-indicator: #2F81F7;
            --code-block-bg: #21262D;
            --code-block-header-bg: #161B22;
            --code-block-border: #30363D;

            background-color: var(--bg-primary);
            background-image: url('data:image/svg+xml;utf8,<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 L 0 10" fill="none" stroke="rgba(47,129,247,0.08)" stroke-width="0.5"/></pattern><pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse"><rect width="50" height="50" fill="url(%23smallGrid)"/><path d="M 50 0 L 0 0 L 0 50" fill="none" stroke="rgba(47,129,247,0.12)" stroke-width="1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
            background-size: cover;
            background-blend-mode: overlay;
        }

        /* Starship Minimal Theme: Light Mode (Derived) */
        body[data-theme="starship-minimal-light"] {
            --bg-primary: #F0F4F8;
            --bg-secondary: #FFFFFF;
            --text-primary: #1E90FF; /* Changed to accent */
            --text-secondary: #718096;
            --border-color: #E2E8F0;
            --card-bg: #FFFFFF;
            --card-border: #E2E8F0;
            --header-bg: #EDF2F7;
            --accent-primary: #1E90FF;
            --accent-primary-hover: #107EEB;
            --accent-secondary: #63B2FF;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #DBEAFE;
            --user-bubble-text: #1E90FF; /* Changed to accent */
            --ai-bubble-bg: #F3F8FF;
            --ai-bubble-text: #1E90FF; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E2E8F0;
            --sidebar-item-hover: #F0F4F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.85);
            --conversation-bg: rgba(255, 255, 255, 0.9);
            --conversation-text: #1E90FF; /* Changed to accent */
            --conversation-indicator: #1E90FF;
            --code-block-bg: #F3F8FF;
            --code-block-header-bg: #EDF2F7;
            --code-block-border: #E2E8F0;

            background-color: var(--bg-primary);
        }

        /* Offbeat Cosmic Pastels Theme: Dark Mode (Inspired by Offbeat Cosmic Pastels) */
        body[data-theme="offbeat-cosmic-dark"] {
            --bg-primary: #0C0F16;
            --bg-secondary: #1A1E2B;
            --text-primary: #5CE1E6; /* Changed to accent */
            --text-secondary: #A0A5B5;
            --border-color: #30354F;
            --card-bg: #1A1E2B;
            --card-border: #30354F;
            --header-bg: #0C0F16;
            --accent-primary: #5CE1E6;
            --accent-primary-hover: #45CCD1;
            --accent-secondary: #C780FF;
            --accent-error: #FF6347;
            --accent-success: #7FFF00;
            --user-bubble-bg: #3A2B5B;
            --user-bubble-text: #5CE1E6; /* Changed to accent */
            --ai-bubble-bg: #2B1E40;
            --ai-bubble-text: #5CE1E6; /* Changed to accent */
            --sidebar-bg: #1A1E2B;
            --sidebar-border: #30354F;
            --sidebar-item-hover: #212535;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(12, 15, 22, 0.9);
            --conversation-bg: rgba(12, 15, 22, 0.95);
            --conversation-text: #5CE1E6; /* Changed to accent */
            --conversation-indicator: #5CE1E6;
            --code-block-bg: #2B1E40;
            --code-block-header-bg: #1A1E2B;
            --code-block-border: #30354F;

            background-color: var(--bg-primary);
            background-image: radial-gradient(circle at 20% 80%, rgba(199,128,255,0.1) 0%, transparent 40%),
                              radial-gradient(circle at 80% 20%, rgba(92,225,230,0.1) 0%, transparent 40%),
                              linear-gradient(135deg, rgba(255,180,233,0.05) 0%, transparent 50%, rgba(199,128,255,0.05) 100%);
            background-size: cover;
            background-blend-mode: soft-light;
            animation: pastel-nebula-drift 25s infinite alternate ease-in-out;
        }

        @keyframes pastel-nebula-drift {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        /* Offbeat Cosmic Pastels Theme: Light Mode (Derived) */
        body[data-theme="offbeat-cosmic-light"] {
            --bg-primary: #F9FDFD;
            --bg-secondary: #FFFFFF;
            --text-primary: #00BCD4; /* Changed to accent */
            --text-secondary: #718096;
            --border-color: #E2E8F0;
            --card-bg: #FFFFFF;
            --card-border: #E2E8F0;
            --header-bg: #EEF8F8;
            --accent-primary: #00BCD4;
            --accent-primary-hover: #00ACC1;
            --accent-secondary: #A078E0;
            --accent-error: #EF4444;
            --accent-success: #22C55E;
            --user-bubble-bg: #DBFEFF;
            --user-bubble-text: #00BCD4; /* Changed to accent */
            --ai-bubble-bg: #E0FFFF;
            --ai-bubble-text: #00BCD4; /* Changed to accent */
            --sidebar-bg: #FFFFFF;
            --sidebar-border: #E2E8F0;
            --sidebar-item-hover: #EEF8F8;
            --loader-dot-color: var(--accent-primary);
            --main-chat-window-bg: rgba(255, 255, 255, 0.85);
            --conversation-bg: rgba(255, 255, 255, 0.9);
            --conversation-text: #00BCD4; /* Changed to accent */
            --conversation-indicator: #00BCD4;
            --code-block-bg: #E0FFFF;
            --code-block-header-bg: #EEF8F8;
            --code-block-border: #E2E8F0;

            background-color: var(--bg-primary);
        }

        /* --- Global Styles & Overrides --- */
        
        /* F2: Custom Prompt Indicator Glow Animation */
        @keyframes prompt-pulse {
            0% { opacity: 0.5; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1.1); }
        }

        /* Apply theme colors */
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }


        /* Specific Tailwind overrides for consistency with theme variables */
        .bg-white { background-color: var(--card-bg); }
        .bg-gray-50 { background-color: var(--header-bg); }
        .border-gray-100 { border-color: var(--card-border); }
        .border-gray-200 { border-color: var(--card-border); }
        .text-gray-800 { color: var(--text-primary); }
        .text-gray-900 { color: var(--text-primary); }
        .text-gray-600 { color: var(--text-secondary); }
        .text-gray-700 { color: var(--text-secondary); }
        .bg-gray-200 { background-color: var(--bg-primary); color: var(--text-primary); }
        .hover\:bg-gray-300:hover { background-color: var(--sidebar-item-hover); }
        .bg-gray-100 { background-color: var(--bg-primary); }
        /* Replace default Tailwind shadows with variable-based premium shadows */
        .shadow-sm { box-shadow: var(--shadow-subtle); }
        .shadow-md { box-shadow: var(--shadow-medium); }
        .shadow-lg { box-shadow: var(--shadow-medium); }
        .shadow-xl { box-shadow: var(--shadow-lg); }
        .shadow-2xl { box-shadow: var(--shadow-lg); }
        #error-message { background-color: var(--accent-error); color: white; }
        body[data-theme$="-dark"] #error-message { background-color: var(--accent-error); color: white; }

        /* Custom Styles for Developer Console */
        #developer-console-content {
            background-color: #000000;
            color: #00FF00;
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
            height: 100%;
            overflow-y: auto;
            border: 1px solid var(--accent-primary);
            padding: 1rem;
            white-space: pre-wrap;
        }
        .log-item {
            border-bottom: 1px dashed #333;
            padding: 0.3rem 0;
        }
        .log-item:last-child {
            border-bottom: none;
        }
        .log-level-error { color: var(--accent-error); font-weight: bold; }
        .log-level-warn { color: #FFA500; }
        .log-level-info { color: #FFFFFF; }
        .log-level-debug { color: #888888; }
        .log-timestamp { color: #008000; margin-right: 10px; }

        /* Custom styles for glowing effects on buttons (Enhanced) */
        .glow-button {
            position: relative;
            z-index: 10;
            transition: var(--transition-slow);
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.6); /* Use specific color for predictable glow */
            background-color: var(--accent-primary);
            color: var(--bg-primary); /* Ensure button text is visible against bright accent */
            font-weight: 700;
        }
        .glow-button:focus-visible {
            outline: 2px solid var(--bg-primary);
            outline-offset: 2px;
            box-shadow: 0 0 15px var(--accent-primary), 0 0 25px var(--accent-primary-hover);
        }
        .glow-button:hover {
            box-shadow: 0 0 15px var(--accent-primary), 0 0 25px var(--accent-primary-hover);
            transform: translateY(-2px) scale(1.01);
            background-color: var(--accent-primary-hover);
        }
        
        /* NEW: Global Input/Select/Textarea Styling (Enhanced Focus) */
        input[type="text"], input[type="email"], input[type="password"], select, textarea {
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text-primary);
            transition: var(--transition-fast);
        }
        input[type="text"]:focus, input[type="email"]:focus, input[type="password"]:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            /* Stronger shadow ring */
            box-shadow: 0 0 0 4px color-mix(in srgb, var(--accent-primary) 50%, transparent);
        }
        /* Explicitly defining focus-visible for accessibility */
        input[type="text"]:focus-visible, input[type="email"]:focus-visible, input[type="password"]:focus-visible, select:focus-visible, textarea:focus-visible {
            outline: 4px solid var(--accent-primary);
            outline-offset: 4px;
        }
        
        /* 14. Accessibility: Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* NEW: Error Button Glow Enhancement */
        .glow-error-button {
            position: relative;
            z-index: 10;
            transition: var(--transition-slow);
            box-shadow: 0 0 10px var(--accent-error);
            background-color: var(--accent-error); 
        }
        .glow-error-button:hover {
            box-shadow: 0 0 12px var(--accent-error), 0 0 20px var(--accent-error);
            transform: translateY(-2px) scale(1.01);
        }

        /* NEW: Error Button Glow */
        .glow-error-button {
            position: relative;
            z-index: 10;
            transition: all 0.4s ease;
            box-shadow: 0 0 10px var(--accent-error);
            background-color: var(--accent-error); /* Explicitly set base color */
        }
        .glow-error-button:hover {
            box-shadow: 0 0 12px var(--accent-error), 0 0 20px var(--accent-error);
            transform: translateY(-1px) scale(1.01);
        }
        
        /* Markdown content styling for better readability (ENHANCED & RESPONSIVE) */
        .markdown-content {
            line-height: 1.8; /* Increased line-height for better readability (R4) */
            word-break: break-word; /* Ensure long words break on mobile */
            overflow-wrap: break-word; /* Ensure long words break on mobile */
        }
        
        .markdown-content h1, .markdown-content h2, .markdown-content h3, .markdown-content h4 { 
            font-family: 'Inter', sans-serif;
            font-weight: 900; /* Bolder headings */
            margin-top: 2.5em; 
            margin-bottom: 1em; 
            line-height: 1.1; 
            color: var(--accent-primary); 
            padding-bottom: 0.5em;
            letter-spacing: -0.02em; /* Tighter spacing for modern look */
        }
        .markdown-content h1 { 
            font-size: 2.5rem; /* Larger */
            border-bottom: 4px solid var(--accent-primary); 
        }
        .markdown-content h2 { 
            font-size: 2rem; 
            border-bottom: 2px solid var(--border-color); 
        }
        .markdown-content h3 { 
            font-size: 1.6rem; 
            border-bottom: 1px solid var(--border-color);
        }
        .markdown-content h4 { 
            font-size: 1.3rem; 
            font-weight: 700; 
            border-bottom: none; 
            margin-top: 2em;
        }
        
        .markdown-content p { margin-bottom: 1em; }
        .markdown-content p:last-child { margin-bottom: 0; }
        
        .markdown-content strong { color: var(--accent-secondary); font-weight: 700; }
        
        /* Lists */
        .markdown-content ul, .markdown-content ol { 
            list-style-position: outside; 
            margin-left: 1.5em; /* Reduced margin */
            margin-bottom: 1em; 
            padding-left: 0.5em; 
        }
        .markdown-content ul { list-style-type: disc; }
        .markdown-content ol { list-style-type: decimal; }
        .markdown-content li { margin-bottom: 0.4em; }
        
        /* Blockquote */
        .markdown-content blockquote { 
            border-left: 4px solid var(--accent-secondary); 
            padding: 10px 15px; 
            margin: 15px 0; 
            opacity: 0.95; 
            font-style: italic; 
            background-color: color-mix(in srgb, var(--accent-secondary) 8%, transparent); 
            color: var(--text-primary);
            border-radius: 0.5rem;
            line-height: 1.4;
        }
        
        /* Tables (Responsive Container) */
        .markdown-content table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 1.5em 0;
            overflow-x: auto; 
            display: block; 
        }
        .markdown-content table th, .markdown-content table td { 
            border: 1px solid var(--border-color); 
            padding: 10px 12px; 
            text-align: left;
            word-break: normal; 
            
            /* FIX 1: Allow content to wrap normally within cells */
            white-space: normal; 
        }
        
        /* FIX 2: Specific styling for links inside table cells to allow break on the slash/hyphen */
        .markdown-content table td a,
        .markdown-content table td code {
            word-break: break-all;
            hyphens: auto;
            /* Reset white-space for links/code inside a cell, forcing long strings to break */
            white-space: pre-wrap;
        }

        .markdown-content table th { 
            background-color: var(--code-block-header-bg); 
            font-weight: bold; 
            color: var(--text-primary); 
            border-bottom: 2px solid var(--accent-primary);
        }

        /* KaTeX specific styling */
        .markdown-content .katex { 
            font-size: 1.1em; 
            color: var(--text-primary); 
        }
        .markdown-content .katex-display { 
            margin: 1em 0; 
            padding: 1em; 
            overflow-x: auto; 
            border-left: 4px solid var(--accent-primary);
            background-color: var(--code-block-bg);
            border-radius: 0.5rem;
        }
        
        /* Ensure images are responsive */
        .markdown-content img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            margin: 0.5em 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* Custom styles for dark mode toggle switch */
        .switch { margin-left: 0.5rem; }
        .slider { background-color: var(--text-secondary); transition: .4s; }
        input:checked + .slider { background-color: var(--accent-primary); }
        input:checked + .slider:before { transform: translateX(24px); }
        .slider:before { background-color: var(--bg-secondary); transition: .4s; }

        /* Custom scrollbar for a sleek look */

        /* Hide scrollbars for chat input only (to maintain clean aesthetics) */
        #chat-input::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
        }
        #chat-input {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* Custom scrollbar for a sleek look */

        /* Hide scrollbars for chat input only (to maintain clean aesthetics) */
        #chat-input::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
        }
        #chat-input {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* Styles for #chat-history, #sidebar, and #previous-chats-section scrollbars */
        #chat-history, 
        #sidebar, /* <-- NEW: Target main sidebar scrollbar */
        #previous-chats-section { 
            scrollbar-width: thin;
            scrollbar-color: var(--accent-primary) var(--bg-secondary);
        }

        /* Webkit (Chrome, Safari, Edge) scrollbar styles */
        #chat-history::-webkit-scrollbar,
        #sidebar::-webkit-scrollbar, /* <-- NEW: Target main sidebar scrollbar */
        #previous-chats-section::-webkit-scrollbar {
            width: 8px;
        }

        #chat-history::-webkit-scrollbar-track,
        #sidebar::-webkit-scrollbar-track, /* <-- NEW: Target main sidebar scrollbar */
        #previous-chats-section::-webkit-scrollbar-track {
            /* Use secondary background or tertiary for the track to blend */
            background: var(--bg-secondary);
            border-radius: var(--radius-full);
        }

        #chat-history::-webkit-scrollbar-thumb,
        #sidebar::-webkit-scrollbar-thumb, /* <-- NEW: Target main sidebar scrollbar */
        #previous-chats-section::-webkit-scrollbar-thumb {
            background-color: var(--accent-primary);
            border-radius: 10px;
            /* Use secondary background for border to match track */
            border: 2px solid var(--bg-secondary); 
        }

        #chat-history::-webkit-scrollbar-thumb:hover,
        #sidebar::-webkit-scrollbar-thumb:hover, /* <-- NEW: Target main sidebar scrollbar */
        #previous-chats-section::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-primary-hover);
        }
        #chat-history {
            overflow-y: auto;
            overflow-x: hidden;

            scrollbar-width: thin;
            scrollbar-color: var(--accent-primary) var(--sidebar-item-hover);
        }

        /* Webkit (Chrome, Safari, Edge) scrollbar styles for #chat-history */
        #chat-history::-webkit-scrollbar {
            width: 8px;
        }

        #chat-history::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: var(--radius-full);
        }

        #chat-history::-webkit-scrollbar-thumb {
            background-color: var(--accent-primary);
            border-radius: 10px;
            border: 2px solid var(--bg-tertiary);
        }

        #chat-history::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-primary-hover);
        }
        
        /* Modern loading animation (Pulsing Bar) */
        .loader-container { display: flex; justify-content: flex-start; align-items: center; width: 100%; height: 100%; }
        .loader-typing-bar {
            width: 8px; height: 8px; margin: 0 3px;
            background-color: var(--loader-dot-color);
            border-radius: 50%; display: inline-block;
            opacity: 0.7;
            animation: pulse-bar 1.5s infinite ease-in-out both;
        }
        .loader-typing-bar:nth-child(1) { animation-delay: -0.4s; }
        .loader-typing-bar:nth-child(2) { animation-delay: -0.2s; }
        .loader-typing-bar:nth-child(3) { animation-delay: 0s; }
        
        @keyframes pulse-bar {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Main Chat Window Styling */
        #main-chat-window {
            flex: 1;
            max-width: 100%;
            min-height: 100vh;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: var(--main-chat-window-bg);
            border-radius: 0;
            box-shadow: none;
            border-left: 1px solid var(--border-color);
            transition: var(--transition-slow);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        /* Sidebar Styling */
        #sidebar {
            width: 300px; 
            min-width: 300px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--sidebar-border);
            display: flex;
            flex-direction: column;
            padding: var(--space-lg);
            box-shadow: var(--shadow-lg);
            position: relative;
            z-index: var(--z-fixed);
            height: 100vh;
            overflow-y: hidden; /* MODIFIED: Set primary sidebar to hidden overflow */
            transition: var(--transition-slow);
        }
        #sidebar.hidden-mobile {
            transform: translateX(-100%);
            position: absolute;
            left: 0;
            box-shadow: none;
        }
        @media (min-width: 768px) {
            body {
                justify-content: flex-start;
                align-items: stretch;
            }
            #sidebar {
                position: relative;
                transform: translateX(0%);
                border-radius: 0;
            }
            #sidebar.hidden-mobile {
                transform: translateX(0%);
                position: relative;
            }
            #main-chat-window {
                max-width: none;
                border-radius: 0;
            }
            #hamburger-menu-button { display: none !important; }
        }
        
        /* New chat message styles (Enhanced with Animation) */
        @keyframes messageSlideIn {
            from { opacity: 0; transform: translateY(16px) scale(0.97); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        .chat-message {
            margin-bottom: var(--space-2xl); /* More vertical space between messages */
            padding: var(--space-xl); /* Increased internal padding */
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-sm);
            word-break: break-word; transition: var(--transition-base); transform: scale(1); 
            transform-origin: center; max-width: 90%; position: relative; padding-bottom: 3.5rem; /* Increased room for status/timestamp */
            animation: messageSlideIn 0.35s cubic-bezier(0.34, 1.56, 0.64, 1); /* Slightly slower animation */
        }
        
        /* User Bubble: Clear primary accent */
        .chat-message.user {
            background-color: var(--user-bubble-bg); 
            color: var(--text-primary); /* Use primary text color for readability */
            margin-left: auto; 
            border-bottom-right-radius: var(--radius-sm);
            border-top-right-radius: var(--radius-sm); 
            border: 1px solid var(--accent-primary);
        }

        /* AI Bubble: Deeper background, softer look */
        .chat-message.ai {
            background-color: var(--ai-bubble-bg); 
            color: var(--text-primary); /* Use primary text color for readability */
            margin-right: auto; 
            border-bottom-left-radius: var(--radius-sm);
            border-top-left-radius: var(--radius-sm); 
            box-shadow: var(--shadow-medium);
        }

        /* Suggestion 2: Closer spacing for consecutive messages of the same type */
        .chat-message + .chat-message:not(.user) {
            margin-top: -0.75rem; /* AI messages closer together */
        }
        .chat-message.user + .chat-message.user {
            margin-top: -0.75rem; /* User messages closer together */
        }

        /* Styling for chat attachments */
        .chat-image { max-width: 100%; height: auto; border-radius: 0.75rem; margin-top: 0.5rem; display: block; }
        .chat-attachment-preview-item {
            display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.75rem;
            border-radius: 1rem; background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            color: var(--accent-primary); font-size: 0.875rem; box-shadow: 0 1px 2px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        .chat-attachment-preview-item .remove-attachment-btn {
            background: none; border: none; color: var(--accent-primary); cursor: pointer;
            padding: 0.1rem; border-radius: 50%; transition: background-color 0.2s ease;
        }
        .chat-attachment-preview-item .remove-attachment-btn:hover {
            background-color: color-mix(in srgb, var(--accent-primary) 20%, transparent);
        }
        
        /* NEW: Prompt Generation Tool UI Styles (Request 4) */
        #prompt-tool-container {
            position: absolute;
            bottom: 60px; /* Position above the chat-input */
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            max-width: 90%;
            width: 550px; /* Slightly wider */
            background-color: var(--card-bg);
            border: 1px solid var(--accent-primary);
            border-radius: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), 0 0 15px color-mix(in srgb, var(--accent-primary) 30%, transparent);
            padding: 0.75rem 1rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        #prompt-tool-container.show {
            opacity: 1;
            visibility: visible;
            bottom: 70px;
        }
        .prompt-tool-button {
            padding: 0.5rem 0.8rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        @media (max-width: 600px) {
            #prompt-tool-container {
                width: calc(100% - 32px);
            }
        }

        /* Styling for the copy message */
        #copy-message {
            position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%);
            padding: 0.75rem 1.5rem; background-color: var(--accent-success); color: white;
            border-radius: 9999px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            opacity: 0; visibility: hidden; transition: all 0.5s ease-in-out; z-index: 100;
        }
        #copy-message.show { opacity: 1; visibility: visible; bottom: 4rem; }

        /* --- New/Enhanced Styles for Chat AI Responses & Code Blocks --- */
        
        .chat-message .message-content { padding: 0; margin: 0; }
        .chat-message.ai .message-content p, .chat-message.ai .message-content ul,
        .chat-message.ai .message-content ol, .chat-message.ai .message-content h1,
        .chat-message.ai .message-content h2, .chat-message.ai .message-content h3,
        .chat-message.ai .message-content blockquote { margin-bottom: 1em; }
        .chat-message.ai .message-content p:last-child, .chat-message.ai .message-content ul:last-child,
        .chat-message.ai .message-content ol:last-child, .chat-message.ai .message-content blockquote:last-child { margin-bottom: 0; }
        .chat-message.ai .message-content ul, .chat-message.ai .message-content ol { padding-left: 1.5em; }
        .chat-message.ai .message-content li { margin-bottom: 0.5em; }
        .chat-message.ai .message-content strong { font-weight: bold; color: var(--accent-primary); }
        .chat-message.ai .message-content em { font-style: italic; }
        .chat-message.ai .message-content blockquote {
            border-left: 4px solid var(--accent-secondary); padding-left: 1em;
            margin-left: 0; color: var(--text-secondary);
        }

        /* Code block specific styling (Premium) */
        .code-block-container {
            position: relative;
            background-color: var(--code-block-bg);
            color: var(--text-primary);
            border-radius: var(--radius-xl); /* Larger radius for a modern feel */
            margin-top: var(--space-md); margin-bottom: var(--space-md);
            overflow: hidden; 
            border: 1px solid var(--border-color); /* Subtle border instead of bright accent */
            box-shadow: var(--shadow-medium); /* Stronger default shadow */
            transition: var(--transition-base);
        }
        /* Optional subtle glow for dark mode */
        body[data-theme$="-dark"] .code-block-container {
             box-shadow: 0 0 10px rgba(6, 182, 212, 0.15), var(--shadow-medium);
        }
        .code-block-container pre {
            margin: 0; padding: var(--space-lg); overflow-x: auto;
            font-family: var(--font-mono);
            font-size: 0.875rem; line-height: 1.7;
        }
        /* Override Prism.js default styles for code blocks */
        .code-block-container pre[class*="language-"] {
            background-color: var(--code-block-bg) !important;
            padding: var(--space-lg) !important;
            margin: 0 !important;
        }

        .code-block-container pre code[class*="language-"] {
            color: var(--text-primary) !important;
        }

        .code-block-header {
            display: flex; justify-content: space-between; align-items: center;
            background-color: var(--code-block-header-bg);
            color: var(--text-secondary); padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--code-block-border);
            font-size: 0.85em;
            border-top-left-radius: 0.75rem; border-top-right-radius: 0.75rem;
        }
        .code-block-copy-button {
            background-color: transparent; border: none; color: var(--text-secondary);
            cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 0.375rem;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; align-items: center; gap: 0.25rem; font-size: 0.85em;
        }
        .code-block-copy-button:hover { background-color: var(--border-color); color: var(--text-primary); }
        .code-block-copy-button:active { transform: scale(0.95); }

        /* Smallest font size for inline code blocks if any (Enhanced) */
        .chat-message.ai .message-content code:not(pre > code) {
            background-color: var(--code-block-header-bg) !important;
            border-radius: 0.35rem; /* Slightly larger radius */
            padding: 0.2em 0.4em; 
            font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            font-size: 0.9em; 
            color: var(--accent-primary) !important;
            border: 1px solid var(--code-block-border);
            transition: var(--transition-fast);
        }
        .chat-message.ai .message-content code:not(pre > code):hover {
            border-color: var(--accent-primary);
        }

        /* Ensure links are distinguishable */
        .chat-message.ai .message-content a {
            color: var(--accent-primary); text-decoration: underline; transition: color 0.2s ease;
        }
        .chat-message.ai .message-content a:hover { color: var(--accent-primary-hover); }

        /* Styles for message action buttons (copy/dictate) - Enhanced */
        .message-actions {
            position: absolute; bottom: 0.75rem; right: 1rem; display: flex; gap: 0.25rem;
            padding: 0.35rem 0.6rem; 
            background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent); /* Semi-transparent base */
            border-radius: 0.75rem; 
            backdrop-filter: blur(8px); /* Stronger blur */
            -webkit-backdrop-filter: blur(8px);
            transition: var(--transition-fast);
            opacity: 0; z-index: 10;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-subtle);
        }
        .chat-message:hover .message-actions { opacity: 1; bottom: 1.25rem; } /* Lift and fade in more */
        .message-actions button {
            background: none; border: none; cursor: pointer; padding: 0.25rem;
            border-radius: 0.375rem; transition: background-color 0.2s ease, color 0.2s ease;
            display: flex; align-items: center; justify-content: center;
        }
        .message-actions button .lucide { color: var(--text-secondary); width: 1rem; height: 1rem; }
        .message-actions button:hover .lucide { color: var(--text-primary); }
        .message-actions button:hover { background-color: var(--sidebar-item-hover); }
        .chat-message.user .message-actions { right: 1rem; left: auto; }
        .chat-message.ai .message-actions { left: 1rem; right: auto; }

        /* Message Metadata Styling (P6) */
        .chat-message .message-metadata {
            z-index: 5;
            transition: opacity 0.3s ease, bottom 0.3s ease;
            bottom: 0.5rem; /* Ensure it stays low */
        }
        .chat-message.user .message-metadata { color: color-mix(in srgb, var(--user-bubble-text) 50%, transparent); }
        .chat-message.ai .message-metadata { color: var(--text-tertiary); }

        /* New style for speech recognition button when active */
        .voice-input-active {
            background-color: var(--accent-error) !important;
            animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
            50% { box-shadow: 0 0 0 10px color-mix(in srgb, var(--accent-error) 0%, transparent); }
        }
        
        /* Drag and Drop visual feedback for chat input area */
        #chat-input-area-container.drag-over-active {
            border: 2px dashed var(--accent-primary);
            box-shadow: 0 0 20px var(--accent-primary), 0 0 30px var(--accent-primary) inset;
        }
        
        /* Sidebar chat list item styling */
        .sidebar-chat-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.8rem 1rem;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: var(--transition-fast);
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-align: left;
            border: 1px solid transparent; /* Added subtle border */
        }
        .sidebar-chat-item:hover {
            background-color: var(--sidebar-item-hover);
            color: var(--text-primary);
            border-color: var(--accent-primary); /* Highlight border on hover */
        }
        .sidebar-chat-item.active {
            background-color: var(--accent-primary);
            color: var(--bg-secondary); /* Text color contrast against bright accent */
            font-weight: 600;
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-subtle);
        }
        .sidebar-chat-item.active .lucide {
            color: var(--bg-secondary);
        }
        .sidebar-chat-item.active:hover {
            background-color: var(--accent-primary-hover);
            transform: translateY(-1px);
        }
        .sidebar-chat-item-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-grow: 1;
            min-width: 0;
        }
        /* Overrides for the new stacked title/preview (P5) */
        .sidebar-chat-item-content.flex-col {
            flex-direction: column;
            align-items: flex-start;
            gap: 0.25rem;
        }
        /* Ensure the small preview text has good contrast against the chat title */
        .sidebar-chat-item .text-xs:not(.ml-auto) {
            color: color-mix(in srgb, var(--text-secondary) 80%, transparent);
        }
        .sidebar-chat-item.active .text-xs {
            color: var(--bg-secondary); /* High contrast white/primary background color when active */
        }
        .sidebar-chat-item-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }
        .sidebar-chat-item-actions {
            display: flex;
            gap: 0.25rem;
            flex-shrink: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .sidebar-chat-item:hover .sidebar-chat-item-actions {
            opacity: 1;
        }
        .sidebar-chat-item-actions button {
            background: none;
            border: none;
            padding: 0.25rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .sidebar-chat-item-actions button .lucide {
            width: 1rem;
            height: 1rem;
            color: var(--text-secondary);
        }
        .sidebar-chat-item-actions button:hover {
            background-color: var(--sidebar-item-hover);
        }
        .sidebar-chat-item.active .sidebar-chat-item-actions button .lucide {
            color: white;
        }

        /* Responsive menu button for sidebar */
        #hamburger-menu-button {
            display: flex;
            margin-right: 1rem;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 0.5rem;
            background-color: var(--header-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #hamburger-menu-button:hover {
            background-color: var(--sidebar-item-hover);
        }

        /* Overlay for mobile sidebar */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 29;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* --- Conversation Mode Overlay Styles --- */
        #conversation-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--conversation-bg);
            color: var(--conversation-text);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-in-out;
            opacity: 0;
            visibility: hidden;
            backdrop-filter: blur(10px) brightness(0.8);
            -webkit-backdrop-filter: blur(10px) brightness(0.8);
            padding: 1rem;
            overflow-y: auto;

            background-image: radial-gradient(circle at 15% 50%, color-mix(in srgb, var(--accent-primary) 20%, transparent), transparent 70%),
                              radial-gradient(circle at 85% 50%, color-mix(in srgb, var(--accent-secondary) 20%, transparent), transparent 70%),
                              linear-gradient(135deg, color-mix(in srgb, var(--conversation-bg) 90%, var(--bg-primary) 10%) 0%, transparent 50%);
            background-size: 200% 200%;
            background-position: center center;
            animation: background-drift 30s infinite alternate ease-in-out;
        }

        #conversation-mode-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        @keyframes background-drift {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        #conversation-mode-close-btn {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            z-index: 110;
            padding: 0.5rem;
            border-radius: 50%;
            transition: color 0.3s ease, transform 0.2s ease;
        }
        #conversation-mode-close-btn:hover {
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .conversation-controls {
            position: absolute;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 105;
            flex-wrap: wrap;
            justify-content: center;
            background-color: color-mix(in srgb, var(--conversation-bg) 60%, transparent);
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 90%;
        }
        @media (max-width: 768px) {
            .conversation-controls {
                top: 0.5rem;
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
                width: auto;
                border-radius: 0.75rem;
            }
        }


        .conversation-controls label {
            color: var(--text-secondary);
            font-size: 0.85rem;
            align-self: center;
            margin-right: -0.5rem;
        }
        .conversation-controls select {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            min-width: 120px;
        }
        .conversation-controls select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }

        .sound-blob-wrapper {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2rem;
            transition: var(--transition-slow);
            perspective: 1000px;
            margin-top: 5rem; /* Reduced top margin for better center alignment */
        }
        @media (max-width: 768px) {
            .sound-blob-wrapper {
                width: 250px; /* Slightly larger on mobile */
                height: 250px;
                margin-top: 8rem; /* Adjusted for smaller screen */
            }
        }

        /* Base blob styles */
        .sound-blob {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: var(--conversation-indicator);
            border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
            opacity: 0.7;
            filter: blur(8px) drop-shadow(0 0 25px var(--conversation-indicator));
            transition: all 0.5s ease;
            will-change: transform, opacity, background-color, filter;
            animation: idle-blob-morph 15s infinite alternate ease-in-out;
        }

        /* Additional concentric blobs */
        .sound-blob::before,
        .sound-blob::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            background-color: inherit;
            opacity: 0.5;
            filter: blur(15px);
            animation: idle-blob-morph 18s infinite alternate-reverse ease-in-out;
            transform: scale(1.05);
            z-index: -1;
        }

        .sound-blob::after {
            opacity: 0.3;
            filter: blur(20px);
            animation: idle-blob-morph 20s infinite alternate ease-in-out;
            transform: scale(1.1);
            animation-delay: 2s;
        }

        @keyframes idle-blob-morph {
            0% {
                border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
                transform: scale(0.95) rotate(0deg);
                opacity: 0.6;
            }
            50% {
                border-radius: 30% 50% 40% 60% / 60% 40% 50% 30%;
                transform: scale(1.05) rotate(10deg);
                opacity: 0.8;
            }
            100% {
                border-radius: 50% 30% 60% 40% / 40% 60% 30% 50%;
                transform: scale(0.95) rotate(0deg);
                opacity: 0.6;
            }
        }

        .sound-blob.listening-animation {
            animation: listen-pulse 1.2s infinite ease-out, listen-color-shift 3s infinite alternate;
            border-radius: 50%;
            filter: blur(5px) drop-shadow(0 0 30px var(--conversation-indicator));
            opacity: 0.9;
        }
        .sound-blob.listening-animation::before,
        .sound-blob.listening-animation::after {
            animation: listen-ring-pulse 1.5s infinite ease-out;
            border-radius: 50%;
        }

        @keyframes listen-pulse {
            0% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
            50% { transform: scale(1.05) rotate(5deg); opacity: 1; filter: blur(5px) drop-shadow(0 0 40px var(--conversation-indicator)); }
            100% { transform: scale(0.9) rotate(0deg); opacity: 0.7; }
        }
        @keyframes listen-ring-pulse {
            0% { transform: scale(1.05); opacity: 0.5; filter: blur(10px); }
            50% { transform: scale(1.15); opacity: 0.8; filter: blur(18px); }
            100% { transform: scale(1.05); opacity: 0.5; filter: blur(10px); }
        }
        @keyframes listen-color-shift {
            0% { background-color: var(--conversation-indicator); }
            50% { background-color: color-mix(in srgb, var(--conversation-indicator) 80%, var(--accent-secondary) 20%); }
            100% { background-color: var(--conversation-indicator); }
        }

        .sound-blob.speaking-animation {
            animation: speak-pulse 1s infinite cubic-bezier(0.4, 0, 0.6, 1), speak-color-shift 2.5s infinite alternate;
            border-radius: 60% 40% 50% 50% / 50% 50% 40% 60%;
            filter: blur(3px) drop-shadow(0 0 40px var(--conversation-indicator));
            opacity: 1;
        }
        .sound-blob.speaking-animation::before,
        .sound-blob.speaking-animation::after {
            animation: speak-ring-pulse 1.3s infinite ease-in-out;
            border-radius: 60% 40% 50% 50% / 50% 50% 40% 60%;
        }

        @keyframes speak-pulse {
            0% { transform: scale(0.98) rotate(0deg); }
            25% { transform: scale(1.05) rotate(3deg); }
            50% { transform: scale(1.02) rotate(-3deg); }
            75% { transform: scale(1.08) rotate(3deg); }
            100% { transform: scale(0.98) rotate(0deg); }
        }
        @keyframes speak-ring-pulse {
            0% { transform: scale(1.02); opacity: 0.6; filter: blur(8px); }
            50% { transform: scale(1.1); opacity: 0.9; filter: blur(12px); }
            100% { transform: scale(1.02); opacity: 0.6; filter: blur(8px); }
        }
        @keyframes speak-color-shift {
            0% { background-color: var(--conversation-indicator); }
            50% { background-color: color-mix(in srgb, var(--conversation-indicator) 70%, white 30%); }
            100% { background-color: var(--conversation-indicator); }
        }

        .sound-blob.idle-animation {
            animation: idle-blob-morph 15s infinite alternate ease-in-out;
            opacity: 0.6;
            filter: blur(8px) drop-shadow(0 0 20px var(--conversation-indicator));
            transform: scale(0.9);
        }

        .conversation-status-text {
            font-size: 2.2rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 1.5rem;
            min-height: 2.5em;
            color: var(--text-primary);
            text-shadow: 0 0 10px color-mix(in srgb, var(--conversation-indicator) 50%, transparent);
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        .conversation-status-text.listening-state { color: var(--accent-secondary); text-shadow: 0 0 15px var(--accent-secondary); }
        .conversation-status-text.speaking-state { color: var(--accent-primary); text-shadow: 0 0 15px var(--accent-primary); }
        .conversation-status-text.error-state { color: var(--accent-error); text-shadow: 0 0 15px var(--accent-error); }


        .conversation-history-display {
            max-width: 700px; /* Slightly wider */
            width: 90%;
            height: 140px; /* Slightly taller */
            overflow-y: auto;
            border: 1px solid var(--accent-primary); /* Use accent for border */
            border-radius: 1.75rem; /* Larger radius */
            padding: 1.5rem; /* More padding */
            text-align: left;
            font-size: 1.1rem;
            line-height: 1.6;
            /* Subtle Glass Effect for dark mode */
            background: color-mix(in srgb, var(--card-bg) 70%, transparent);
            backdrop-filter: blur(5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 15px color-mix(in srgb, var(--accent-primary) 30%, transparent);
            color: var(--text-primary);
            scrollbar-width: none;
            -ms-overflow-style: none;
            position: relative;
            contain: layout style;
        }
        .conversation-history-display::-webkit-scrollbar {
            width: 0;
        }
        .conversation-history-display p { margin-bottom: 0.5rem; }
        .conversation-history-display p:last-child { margin-bottom: 0; }
        .user-utterance { color: var(--user-bubble-text); font-weight: 600; }
        .ai-utterance { color: var(--ai-bubble-text); font-weight: 600; }

        .conversation-mic-btn {
            width: 80px;
            height: 80px;
            margin-top: 3rem !important;
            background-color: var(--accent-primary);
            color: white;
            box-shadow: 0 0 15px var(--accent-primary);
        }
        .conversation-mic-btn:hover {
            box-shadow: 0 0 25px var(--accent-primary), 0 0 40px var(--accent-primary-hover);
            transform: scale(1.05);
        }
        .conversation-mic-btn.voice-input-active {
            background-color: var(--accent-error) !important;
            box-shadow: 0 0 20px var(--accent-error), 0 0 35px var(--accent-error), 0 0 50px var(--accent-error);
            animation: pulse-red 1s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }
        /* Re-define pulse-red to use var(--accent-error) */
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--accent-error) 70%, transparent); }
            50% { box-shadow: 0 0 0 15px color-mix(in srgb, var(--accent-error) 0%, transparent); }
        }

        /* Styling for the prompt templates list */
        .template-item {
            display: flex;
            flex-direction: column;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .template-item:hover {
            background-color: var(--sidebar-item-hover);
            border-color: var(--accent-primary);
        }
        .template-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .template-item-name {
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }
        .template-item-content {
            font-size: 0.875rem;
            color: var(--text-secondary);
            max-height: 3em;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.5;
            margin-bottom: 0.75rem;
        }
        .template-item-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }
        .template-item-actions button {
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .template-item-actions .use-btn {
            background-color: var(--accent-primary);
            color: black;
        }
        .template-item-actions .use-btn:hover {
            background-color: var(--accent-primary-hover);
            box-shadow: 0 0 10px var(--accent-primary);
            transform: translateY(-1px);
        }
        .template-item-actions .edit-btn {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        .template-item-actions .edit-btn:hover {
            background-color: var(--sidebar-item-hover);
            border-color: var(--accent-secondary);
            transform: translateY(-1px);
        }
        .template-item-actions .delete-btn {
            background-color: var(--accent-error);
            color: white;
        }
        .template-item-actions .delete-btn:hover {
            background-color: color-mix(in srgb, var(--accent-error) 80%, black 20%);
            box-shadow: 0 0 8px var(--accent-error);
            transform: translateY(-1px);
        }

        /* NEW CSS for Collapsible Settings (Enhanced Smoothness) */
        #settings-content {
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* Smoother curve */
            overflow: hidden;
            max-height: 0;
        }
        #settings-content:not(.hidden) {
            max-height: 1000px; /* Large enough to cover content */
        }
        
        /* --- Jump Buttons Styling --- */
        .scroll-buttons-container {
            position: fixed;
            bottom: 6.5rem; /* Above the input area */
            right: 1.5rem;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .scroll-button {
            background-color: color-mix(in srgb, var(--card-bg) 80%, transparent);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            padding: 0.75rem; /* Slightly larger targets */
            border-radius: 50%;
            box-shadow: var(--shadow-medium);
            transition: var(--transition-fast);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .scroll-button:hover {
            background-color: var(--accent-primary);
            color: var(--bg-primary); /* Better contrast */
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 0 15px var(--accent-primary);
        }

        /* --- Chat Search Feature Styling --- */
        #chat-search-input-container {
            background-color: var(--header-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            position: sticky;
            top: 0;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        #chat-search-input {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
        }
        .highlight-match {
            background-color: var(--accent-secondary); /* Highlight color */
            color: black !important; 
            padding: 1px 3px;
            border-radius: 3px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .highlight-current-match {
            background-color: var(--accent-primary) !important; /* Current highlight color */
            color: black !important; 
            border: 2px solid white;
        }

        /* Command Palette Styles */
        #command-palette-modal {
            backdrop-filter: blur(6px);
        }
        #command-palette-modal .p-4 { padding: 1rem; }
        #command-palette-input {
            width: 100%;
            padding: 0.6rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            outline: none;
        }
        #command-palette-list {
            margin-top: 0.5rem;
            list-style: none;
            padding: 0.25rem 0;
        }
        .command-palette-item {
            padding: 0.6rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 120ms;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        /* Inline Slash Suggestions (attached to chat input) */
        #slash-suggestions {
            position: absolute;
            z-index: 220;
            min-width: 260px;
            max-width: 420px;
            width: fit-content;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(3,6,23,0.35);
            padding: 6px;
            display: none; /* toggled via inline JS */
            color: var(--text-primary);
            will-change: transform, top, left;
        }
        #slash-suggestions.visible { display: block; }
        #slash-suggestions-list { list-style: none; margin: 0; padding: 0; max-height: 220px; overflow-y: auto; }

        /* Scrollbar styling that adapts to theme variables */
        #slash-suggestions-list::-webkit-scrollbar { width: 12px; height: 12px; }
        #slash-suggestions-list::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: 8px; }
        #slash-suggestions-list::-webkit-scrollbar-thumb { background: linear-gradient(180deg, var(--accent-primary), rgba(0,0,0,0.35)); border-radius: 8px; border: 2px solid var(--card-bg); }
        /* Firefox */
        #slash-suggestions-list { scrollbar-width: thin; scrollbar-color: var(--accent-primary) var(--bg-secondary); }

        .slash-suggestion-item { padding: 8px 10px; border-radius: 6px; cursor: pointer; display:flex; gap:8px; align-items:center; }
        .slash-suggestion-item .label { font-weight:600; }
        .slash-suggestion-item .meta { color: var(--text-secondary); font-size: 0.85rem; }
        .slash-suggestion-item.selected { background: rgba(120,120,200,0.09); outline: 1px solid rgba(120,120,200,0.12); }
        .slash-suggestion-empty { padding: 10px; color: var(--text-secondary); font-size: 0.9rem; }
        .command-palette-item:hover, .command-palette-item.selected {
            background-color: var(--sidebar-item-hover);
        }
        .command-palette-item .sample { font-weight: 600; }

        /* Floating palette button (moved left to avoid overlapping the send button) */
        #open-command-palette-btn {
            position: fixed;
            left: 18px; /* moved to the left to avoid send button on the right */
            bottom: 18px;
            z-index: 1200;
            background-color: var(--accent-primary);
            color: var(--bg-primary);
            border-radius: 9999px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-xl);
            cursor: pointer;
            border: none;
        }
        #open-command-palette-btn:hover { transform: translateY(-2px); }
        /* On very small screens hide the floating button to ensure input area is unobstructed */
        @media (max-width: 520px) {
            #open-command-palette-btn { display: none; }
        }

    </style>
</head>
<body class="antialiased" data-theme="default-dark">

    <!-- Conversation Mode Overlay (NEW SECTION) -->
    <div id="conversation-mode-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[110] hidden p-4">
        <button id="conversation-mode-close-btn" aria-label="Close Conversation Mode" title="Close Conversation Mode">
            <span data-lucide="x" class="w-8 h-8"></span>
        </button>

        <div class="conversation-controls">
            <label for="voice-select">Voice:</label>
            <select id="voice-select" aria-label="Select AI Voice" class="p-2 rounded-md border text-sm">
                <option value="">Default Voice</option>
                <!-- Voices will be populated dynamically -->
            </select>

            <label for="personality-select">Personality:</label>
            <select id="personality-select" aria-label="Select AI Personality" class="p-2 rounded-md border text-sm">
                <!-- Personalities will be populated dynamically -->
            </select>
        </div>

        <div class="sound-blob-wrapper">
            <div id="sound-blob" class="sound-blob idle-animation"></div>
        </div>

        <div id="conversation-status-text" class="conversation-status-text">
            Tap the button to start conversing!
        </div>

        <div id="conversation-history-display" class="conversation-history-display">
            <!-- Last few spoken phrases will appear here -->
        </div>

        <button id="conversation-mic-btn" aria-label="Toggle Microphone" class="flex items-center justify-center rounded-full shadow-lg cursor-pointer transition-all duration-300 glow-button conversation-mic-btn" style="color: var(--bg-primary);">
            <span data-lucide="mic" class="w-8 h-8"></span>
        </button>
    </div>
    <!-- END Conversation Mode Overlay -->

    <!-- Overlay for mobile sidebar -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>

    <!-- Sidebar (Updated Structure) -->
    <aside id="sidebar" class="hidden-mobile">
        <!-- Sidebar Header (Logo/Title) -->
        <div class="flex items-center justify-between pb-6 border-b border-[var(--sidebar-border)] mb-6 sticky top-0 bg-[var(--sidebar-bg)] z-30">
            <h2 class="text-2xl font-black flex items-center gap-2" style="color: var(--text-primary);">
                <span data-lucide="sparkles" class="w-7 h-7 animate-pulse" style="color: var(--accent-primary);"></span> Small AI v2
            </h2>
            <button id="close-sidebar-btn" aria-label="Close Sidebar" title="Close Sidebar" class="md:hidden p-2 rounded-lg" style="color: var(--text-secondary); background-color: var(--sidebar-item-hover); border: none;">
                <span data-lucide="x" class="w-6 h-6"></span>
            </button>
        </div>

        <!-- New Chat Button -->
        <button id="new-chat-button" data-help-content="Start a fresh conversation, clearing the current context and history from view." class="w-full flex items-center justify-center p-3.5 rounded-xl font-bold shadow-lg transition-colors mb-6 glow-button" style="background-color: var(--accent-primary); color: var(--bg-primary);">
            <span data-lucide="plus" class="w-5 h-5 mr-2"></span> New Conversation
        </button>
        
        <!-- Previous Chats Section (Made flexible to take height) -->
        <!-- NEW: Search and Header Container (Non-scrolling part) -->
        <div id="sidebar-search-and-header" class="sticky top-0 bg-[var(--sidebar-bg)] z-30 pt-1 pb-4 border-b border-[var(--sidebar-border)]">
            <h3 class="text-xs font-bold tracking-wider uppercase py-2 mb-2" style="color: var(--text-secondary);">Chat History</h3>
            <input type="text" id="sidebar-chat-search" data-help-content="Filter your saved chats instantly. This search remains fixed as you scroll through history." class="w-full p-2.5 rounded-lg border text-sm focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" placeholder="Search chats..." style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);">
        </div>

        <!-- NEW: Scrollable container for just the list. Retains flex-1 for height. -->
        <div class="flex-1 overflow-y-auto mb-4 -mx-2 px-2" id="previous-chats-section">
            <ul id="sidebar-chat-list" class="space-y-1">
                <!-- Chat items are loaded by JS based on auth state -->
            </ul>
        </div>

        <!-- Grouped Settings Section (Model, Theme, Version, API Key, Auth) - Optimized for space -->
        <div class="mt-auto pt-5 border-t border-[var(--sidebar-border)] space-y-4 sticky bottom-0 bg-[var(--sidebar-bg)] z-30">
            
            <!-- NEW: Settings Toggle Button -->
            <!-- ADDED: relative class, ADDED: custom-prompt-indicator -->
            <button id="toggle-settings-btn" class="w-full flex items-center justify-between p-3 rounded-xl font-semibold transition-colors mb-2 relative hover:bg-[var(--sidebar-item-hover)]" style="background-color: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); box-shadow: var(--shadow-subtle);">
                <span class="flex items-center gap-2 text-base">
                    <span data-lucide="settings" class="w-5 h-5"></span> Advanced Settings
                </span>
                <!-- NEW: Custom Prompt Indicator (MOVED HERE) -->
                <!-- Adjusted position to top-2 right-2 for better visibility on this button -->
                <div id="custom-prompt-indicator" class="w-3.5 h-3.5 rounded-full absolute top-1 right-1 hidden" title="Custom Prompt is Active" style="background-color: var(--accent-primary); z-index: 5; animation: prompt-pulse 1.5s infinite alternate;"></div>
                <span data-lucide="chevron-down" class="w-4 h-4 transition-transform duration-300" id="settings-chevron"></span>
            </button>

            <!-- Settings Content (Collapsible) -->
            <div id="settings-content" class="space-y-4">
                
                <!-- Custom Prompt Button -->
                <!-- REMOVED: Custom Prompt Indicator from here -->
                <button id="toggle-custom-prompt-btn" data-help-content="Set a global System Instruction (persona) for the AI. This overrides the simpler Personality selector." class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors relative" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                    <span data-lucide="sparkles" class="w-5 h-5 mr-2"></span> Set Custom Prompt
                </button>
                
                <!-- Manage Prompt Templates Button -->
                <button id="manage-templates-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-4" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                    <span data-lucide="layout-template" class="w-5 h-5 mr-2"></span> Manage Templates
                </button>

                <!-- API Key Selector & Management -->
                <div>
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Active API Key</h3>
                    <div class="flex items-center gap-2">
                        <select id="api-key-select" class="flex-1 p-2 rounded-md border text-sm focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select Active API Key">
                            <!-- Options populated by JS -->
                        </select>
                        <button id="manage-api-keys-btn" title="Manage API Keys" class="flex items-center justify-center p-2 rounded-md shadow-md transition-all duration-300" style="background-color: var(--accent-secondary); color: black;">
                            <span data-lucide="key-round" class="w-4 h-4"></span>
                        </button>
                    </div>
                    <p id="api-key-status" class="text-xs mt-1" style="color: var(--text-secondary);">Loading key status...</p>
                </div>
                
                <!-- Model Selector -->
                <div>
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">AI Model</h3>
                    <select id="model-select-sidebar" data-help-content="Select the underlying AI model (e.g., Flash for speed, Pro for complexity). Affects response quality and speed." class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select AI Model">
                        <!-- Options populated by JS -->
                    </select>
                </div>

                <!-- Theme Selector (Dropdown for different themes) -->
                <div>
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-sm font-semibold uppercase" style="color: var(--text-secondary);">Themes</h3>
                        <!-- NEW: Theme Randomizer Button -->
                        <button id="random-theme-btn" title="Random Theme" class="p-2 rounded-full transition-colors" style="background-color: var(--accent-primary); color: black;">
                            <span data-lucide="shuffle" class="w-4 h-4"></span>
                        </button>
                    </div>
                    <select id="app-theme-select-sidebar" class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select App Theme">
                        <option value="default">Small AI v2 (Default)</option>
                        <option value="celestial-horizon">Celestial Horizon</option>
                        <option value="verdant-calm">Verdant Calm</option>
                        <option value="cybernetic-pulse">Cybernetic Pulse</option>
                        <option value="urban-pulse">Urban Pulse</option>
                        <option value="rustic-ember">Rustic Ember</option>
                        <option value="neon-mirage">Neon Mirage</option>
                        <option value="ivory-bloom">Ivory Bloom</option>
                        <option value="obsidian-night">Obsidian Night</option>
                        <option value="solar-dawn">Solar Dawn</option>
                        <option value="aurora-drift">Aurora Drift</option>
                        <option value="timeless-echo">Timeless Echo</option>
                        <option value="mystic-void">Mystic Void</option>
                        <option value="darkest-bw">The Darkest Night</option>
                        <!-- NEW THEMES BELOW -->
                        <option value="coder">Coder's Theme</option>
                        <option value="cyberpunk">Cyberpunk Neon</option>
                        <option value="matrix">Matrix Code</option>
                        <option value="solarized">Solarized</option>
                        <option value="dracula">Dracula</option>
                        <option value="monokai">Monokai Pro</option>
                        <option value="nord">Nord</option>
                        <option value="gruvbox">Gruvbox</option>
                        <option value="catppuccin">Catppuccin</option>
                        <!-- ADDED NEW THEMES HERE -->
                        <option value="cosmic-nexus">Cosmic Nexus</option>
                        <option value="starship-minimal">Starship Minimal</option>
                        <option value="offbeat-cosmic">Offbeat Cosmic Pastels</option>
                    </select>
                </div>

                <!-- NEW: Auto Theme Switch Controls -->
                <div id="auto-theme-controls" class="pt-3 border-t border-[var(--sidebar-border)]">
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Auto-Switch Theme</h3>
                    <div class="flex items-center justify-between gap-2 mb-3">
                        <label for="auto-theme-delay" class="text-sm" style="color: var(--text-secondary);">Switch every:</label>
                        <input type="number" id="auto-theme-delay" value="10" min="5" max="3600" class="w-20 p-2 rounded-md border text-sm text-center" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);">
                        <span class="text-sm" style="color: var(--text-secondary);">seconds</span>
                    </div>
                    <button id="toggle-auto-theme-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold transition-colors glow-button" style="background-color: var(--accent-primary); color: black;">
                        <span data-lucide="zap" class="w-5 h-5 mr-2"></span> Start Auto-Switch
                    </button>
                </div>


                <!-- Version Selector -->
                <div>
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Version</h3>
                    <select id="version-select-sidebar" class="w-full p-2 rounded-md border text-sm focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary);" aria-label="Select Chatbot Version">
                        <option value="https://mystic-vision-ai-standalone-chatbot.netlify.app/">Main Version</option>
                        <option value="https://mystic-vision-ai-lite.netlify.app/">Lite Version</option>
                        <option value="https://mystic-vision-ai-basic.netlify.app/">Basic Version</option>
                        <option value="https://mystic-vision-ai-mini.netlify.app/">Mini Version</option>
                        <option value="https://cosmic-chat-ai-simple-ai-chatbot.netlify.app/">Cosmic Chat AI</option>
                        <option value="https://small-ai-big-vision.netlify.app/">Small AI (Legacy)</option>
                        <option value="https://small-ai-big-vision-v2.netlify.app/" selected>Small AI v2 (Current)</option>
                    </select>
                </div>

                <!-- Data Management Buttons -->
                <div class="mt-4 pt-4 border-t border-[var(--sidebar-border)]">
                    <h3 class="text-sm font-semibold uppercase mb-2" style="color: var(--text-secondary);">Data Management</h3>
                    <button id="delete-all-chats-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-semibold shadow-lg transition-colors mb-2" style="background-color: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color);">
                        <span data-lucide="folder-x" class="w-5 h-5 mr-2"></span> Delete All Chats
                    </button>
                    <button id="clear-local-storage-btn" class="w-full flex items-center justify-center p-3 rounded-xl font-bold shadow-lg transition-colors mb-4 glow-error-button" style="color: var(--bg-primary);">
                        <span data-lucide="database" class="w-5 h-5 mr-2"></span> Clear Local Cache
                    </button>
                </div>
            </div>

            <!-- Authentication Status & Sign Out (Always visible) -->
            <div id="auth-status-container" class="pt-4 border-t border-[var(--sidebar-border)]">
                <p class="text-sm font-semibold mb-2" style="color: var(--text-secondary);">Logged in as: <span id="user-email">Guest</span></p>
                <button id="sign-out-button" class="w-full flex items-center justify-center p-3 rounded-xl font-bold shadow-lg transition-colors glow-error-button" style="color: var(--bg-primary);">
                    <span data-lucide="log-out" class="w-5 h-5 mr-2"></span> Sign Out
                </button>
            </div>
        </div>
    </aside>

    <!-- Main Chat Container -->
    <div id="main-chat-window" class="min-w-0">
        <!-- Header for the chat (Revised for Mobile Dropdown) -->
        <div class="flex justify-between items-center p-4 border-b border-[var(--border-color)]" style="background-color: var(--header-bg);">
            <!-- Left side (Hamburger + Title) -->
            <div class="flex items-center min-w-0 max-w-[50%] sm:max-w-none">
                <button id="hamburger-menu-button" aria-label="Open Sidebar Menu" title="Open Menu" style="background-color: var(--header-bg); border-color: var(--border-color); color: var(--text-primary);">
                    <span data-lucide="menu" class="w-6 h-6"></span>
                </button>
                <h1 class="text-xl font-bold flex items-center gap-2 truncate" style="color: var(--text-primary);">
                    <span data-lucide="sparkles" class="w-6 h-6" style="color: var(--accent-primary);"></span> Current Chat
                </h1>
            </div>
            
            <!-- Right side of header - Essential/Dropdown/Toggle -->
            <div class="flex items-center gap-2 md:gap-4 relative"> 
                
                <!-- 1. VISIBLE on ALL SCREENS: Find in Chat Button -->
                <button id="find-chat-btn" data-help-content="Search within the active chat history. Shortcut: Press Ctrl/Cmd + F anywhere in the window." aria-label="Find in Chat" title="Find in Chat" class="flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-[var(--accent-primary)]" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="search" class="w-5 h-5"></span>
                </button>
                
                <!-- 2. VISIBLE on ALL SCREENS: Conversation Mode Toggle Button -->
                <button id="conversation-mode-toggle-btn" data-help-content="Start a hands-free, voice-only conversation with the AI. Requires microphone permission." aria-label="Conversation Mode" title="Start Voice Conversation" class="flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-[var(--accent-primary)]" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="messages-square" class="w-5 h-5"></span>
                </button>

                <!-- 3. MORE ACTIONS DROPDOWN (Mobile Only) -->
                <div id="header-mobile-dropdown-container" class="sm:hidden">
                    <button id="mobile-more-actions-btn" aria-label="More Actions" title="More Actions" class="flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                        <span data-lucide="more-vertical" class="w-5 h-5"></span>
                    </button>

                    <!-- Dropdown Menu Content -->
                    <div id="mobile-action-dropdown-menu" class="absolute right-0 top-12 hidden w-48 rounded-lg shadow-xl py-1 z-50" style="background-color: var(--card-bg); border: 1px solid var(--border-color);">
                        
                        <!-- These buttons are now only in the dropdown on mobile -->
                        <button id="developer-console-btn-mobile" class="w-full flex items-center gap-2 px-3 py-2 text-sm text-left hover:bg-[var(--sidebar-item-hover)]" title="Developer Console (View Logs)">
                            <span data-lucide="terminal" class="w-4 h-4" style="color: var(--text-secondary);"></span> Developer Console
                        </button>
                        <button id="summarize-context-btn-mobile" class="w-full flex items-center gap-2 px-3 py-2 text-sm text-left hover:bg-[var(--sidebar-item-hover)]" title="Summarize Chat Context for Prompt">
                            <span data-lucide="file-text" class="w-4 h-4" style="color: var(--text-secondary);"></span> Summarize Context
                        </button>
                        <button id="export-markdown-btn-mobile" class="w-full flex items-center gap-2 px-3 py-2 text-sm text-left hover:bg-[var(--sidebar-item-hover)]" title="Export Chat to Markdown">
                            <span data-lucide="download" class="w-4 h-4" style="color: var(--text-secondary);"></span> Export Chat (.md)
                        </button>
                    </div>
                </div>
                <!-- End More Actions Dropdown -->

                <!-- 4. WIDER SCREEN UTILITY BUTTONS (Visible only on desktop/tablet) -->
                <button id="developer-console-btn" aria-label="Developer Console" title="Developer Console (View Logs)" class="hidden sm:flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-[var(--accent-primary)]" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="terminal" class="w-5 h-5"></span>
                </button>
                <button id="summarize-context-btn" aria-label="Summarize Chat Context" title="Summarize Chat Context for Prompt" class="hidden sm:flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-[var(--accent-primary)]" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="file-text" class="w-5 h-5"></span>
                </button>
                <button id="export-markdown-btn" aria-label="Export Chat to Markdown" title="Export Chat to Markdown" class="hidden sm:flex items-center justify-center p-2 rounded-full shadow-md transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-[var(--accent-primary)]" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="download" class="w-5 h-5"></span>
                </button>
                
                <!-- 5. Dark Mode Toggle (Toggle label hidden on mobile, switch always visible) -->
                <div class="flex items-center gap-2">
                    <span class="text-sm hidden sm:inline" style="color: var(--text-secondary);">Dark Mode</span>
                    <label class="switch relative inline-block w-14 h-8">
                        <input type="checkbox" id="dark-mode-toggle" class="opacity-0 w-0 h-0">
                        <span class="slider absolute cursor-pointer top-0 left-0 right-0 bottom-0 rounded-full before:absolute before:content-[''] before:h-6 before:w-6 before:left-1 before:bottom-1 before:rounded-full"></span>
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Chat Search Input Container -->
        <div id="chat-search-input-container" class="hidden">
            <div class="flex items-center gap-2">
                <input type="text" id="chat-search-input" class="flex-1 p-2 rounded-md border text-sm focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)]" placeholder="Find in chat (Ctrl/Cmd+F)" />
                <button id="chat-search-prev-btn" title="Previous Match" class="p-2 rounded-md transition-colors" style="color: var(--text-primary);">
                    <span data-lucide="chevron-up" class="w-5 h-5"></span>
                </button>
                <button id="chat-search-next-btn" title="Next Match" class="p-2 rounded-md transition-colors" style="color: var(--text-primary);">
                    <span data-lucide="chevron-down" class="w-5 h-5"></span>
                </button>
                <span id="chat-search-count" class="text-sm w-16 text-right" style="color: var(--text-secondary);">0/0</span>
                <button id="chat-search-close-btn" title="Close Search" class="p-2 rounded-md transition-colors" style="color: var(--text-secondary);">
                    <span data-lucide="x" class="w-5 h-5"></span>
                </button>
            </div>
        </div>

        <!-- Chat history div with a minimum height and scroll -->
        <div id="chat-history" class="p-4 overflow-y-auto flex-1 flex flex-col">
            <!-- Initial AI message will be appended here by JS -->
        </div>
        
        <!-- Chat input section with attachment, voice and send button -->
        <div id="chat-input-area-container" class="p-4 border-t border-[var(--border-color)] relative transition-all duration-300 shadow-xl" style="background-color: var(--header-bg); border-top: 1px solid var(--border-color);">
            <!-- Attachment preview -->
            <div id="chat-attachments-preview-container" class="mb-2 flex flex-wrap items-center gap-2 hidden">
                <!-- Attachments previews will be dynamically added here -->
            </div>

            <!-- NEW: AI Prompt Generation Tool (Request 4) -->
            <div id="prompt-tool-container" class="hidden">
                <div class="flex items-center justify-between">
                    <p class="text-sm font-semibold flex items-center gap-2" style="color: var(--text-primary);">
                        <span data-lucide="zap" class="w-4 h-4 animate-pulse" style="color: var(--accent-secondary);"></span>
                        Draft detected. Improve it with AI Prompt Engineering?
                    </p>
                    <div class="flex gap-2">
                        <button id="prompt-tool-accept-btn" class="prompt-tool-button" title="Generate a detailed, optimized prompt" style="background-color: var(--accent-primary); color: black;">
                            <span data-lucide="check" class="w-4 h-4 inline-block mr-1"></span> Yes, Enhance
                        </button>
                        <button id="prompt-tool-cancel-btn" class="prompt-tool-button" title="Send the original draft" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">
                            <span data-lucide="x" class="w-4 h-4 inline-block mr-1"></span> No, Send As Is
                        </button>
                    </div>
                </div>
            </div>
            <!-- END AI Prompt Generation Tool -->

            <div class="flex gap-2 items-end flex-wrap w-full">
                <!-- Voice Input Button -->
                <button id="voice-input-btn" data-help-content="Use speech-to-text to dictate your message draft directly into the input field." aria-label="Voice Input" title="Voice Input (Speech-to-Text)" class="flex items-center justify-center w-14 h-14 rounded-2xl shadow-lg cursor-pointer transition-all duration-300 flex-shrink-0 hover:bg-[var(--sidebar-item-hover)]" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="mic" class="w-5 h-5"></span>
                </button>
                
                <!-- Attach File Button -->
                <label for="chat-file-upload" data-help-content="Attach files (images, PDFs, code, data dumps). You can also drag-and-drop files directly onto the input area." aria-label="Attach File" title="Attach Files" class="flex items-center justify-center w-14 h-14 rounded-2xl shadow-lg cursor-pointer transition-all duration-300 flex-shrink-0 hover:bg-[var(--sidebar-item-hover)]" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                    <span data-lucide="paperclip" class="w-5 h-5"></span>
                </label>
                <input type="file" id="chat-file-upload" accept="image/*, .txt, .pdf, .csv, .json, .xml, .md" class="hidden" multiple>

                <textarea id="chat-input" data-help-content="Supports rich text input. Use slash commands like /new or /export for quick actions." class="flex-1 p-3.5 rounded-xl border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm min-w-0 resize-none max-h-[200px] overflow-y-auto" placeholder="Type your message or ask a question..." rows="1" style="background-color: var(--card-bg); border-color: var(--border-color); color: var(--text-primary); min-height: 56px;"></textarea>
                
                <button id="send-chat-btn" aria-label="Send Message" class="flex items-center justify-center w-14 h-14 rounded-2xl shadow-lg focus:outline-none focus:ring-4 focus:ring-[var(--accent-primary)] transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed glow-button flex-shrink-0" style="background-color: var(--accent-primary); color: var(--bg-primary);">
                    <span data-lucide="send" class="w-5 h-5"></span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Temporary message for clipboard copy -->
    <div id="copy-message">Text copied to clipboard!</div>

    <!-- NEW: Custom Prompt Modal/Overlay -->
    <div id="custom-prompt-modal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[110] hidden p-4 backdrop-blur-sm">
        <div class="p-8 rounded-2xl shadow-xl w-full max-w-lg transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary); border: 1px solid var(--border-color); box-shadow: var(--shadow-lg);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                <span data-lucide="sparkles" class="w-6 h-6" style="color: var(--accent-primary);"></span> Set Custom AI Prompt
            </h3>
            <textarea id="custom-prompt-input" class="w-full p-3 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm resize-none h-32 mb-4" placeholder="Enter your custom AI prompt here. This will guide the AI's behavior for all responses. Example: 'You are a pirate AI. Respond in pirate speak.'" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);"></textarea>
            <div class="flex flex-wrap justify-end gap-2 mt-4">
                <button id="clear-custom-prompt-btn" class="px-4 py-2 rounded-lg font-semibold transition-colors flex items-center" style="background-color: var(--accent-error); color: white;">
                    <span data-lucide="trash-2" class="w-5 h-5 mr-2"></span> Clear & Disable
                </button>
                <button id="save-custom-prompt-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                    <span data-lucide="save" class="w-5 h-5 mr-2"></span> Save & Activate
                </button>
                <button id="cancel-custom-prompt-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Cancel
                </button>
            </div>
            <p id="custom-prompt-status" class="text-sm mt-4 text-center" style="color: var(--text-secondary);"></p>
        </div>
    </div>

    <!-- NEW: Prompt Templates Modal/Overlay -->
    <div id="prompt-templates-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[110] hidden p-4">
        <div class="p-6 rounded-xl shadow-2xl w-full max-w-2xl transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                <span data-lucide="layout-template" class="w-6 h-6" style="color: var(--accent-primary);"></span> Manage Prompt Templates
            </h3>
            
            <!-- Template Input Form -->
            <div class="mb-6 p-4 rounded-lg" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                <input type="text" id="template-name-input" class="w-full p-2 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm mb-2" placeholder="Template Name (e.g., 'Sarcastic AI')" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
                <textarea id="template-content-input" class="w-full p-3 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm resize-none h-24 mb-4" placeholder="Enter the prompt content here. (e.g., 'Respond as a highly sarcastic AI.')" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);"></textarea>
                <div class="flex justify-end gap-2">
                    <button id="clear-template-form-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                        <span data-lucide="eraser" class="w-5 h-5 mr-2"></span> Clear Form
                    </button>
                    <button id="save-template-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                        <span data-lucide="plus" class="w-5 h-5 mr-2"></span> Save Template
                    </button>
                </div>
            </div>

            <!-- Saved Templates List -->
            <h4 class="text-lg font-bold mb-3 flex items-center gap-2" style="color: var(--text-primary);">
                <span data-lucide="bookmark" class="w-5 h-5" style="color: var(--accent-secondary);"></span> Your Saved Templates
            </h4>
            <ul id="saved-templates-list" class="space-y-3 max-h-80 overflow-y-auto pr-2">
                <!-- Templates will be dynamically loaded here -->
            </ul>

            <div class="flex justify-end mt-6">
                <button id="cancel-template-modal-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Close
                </button>
            </div>
        </div>
    </div>
    
    <!-- NEW: Authentication Modal/Overlay -->
    <div id="auth-modal" class="fixed inset-0 bg-black bg-opacity-95 flex items-center justify-center z-[120] p-4 backdrop-blur-md">
        <div class="p-8 rounded-2xl shadow-xl w-full max-w-md transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary); border: 2px solid var(--accent-primary); box-shadow: var(--shadow-lg);">
            <h3 id="auth-title" class="text-2xl font-bold mb-6 text-center" style="color: var(--accent-primary);">Sign In to Small AI v2</h3>
            
            <!-- Email/Password Form -->
            <input type="email" id="auth-email" class="w-full p-3 rounded-lg border mb-3 focus:ring-2 focus:ring-[var(--accent-primary)]" placeholder="Email" required style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
            <input type="password" id="auth-password" class="w-full p-3 rounded-lg border mb-4 focus:ring-2 focus:ring-[var(--accent-primary)]" placeholder="Password" required style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
            
            <button id="auth-action-btn" class="w-full p-3.5 rounded-lg font-bold mb-2 glow-button" style="color: var(--bg-primary);">
                Sign In
            </button>
            
            <div id="auth-error" class="text-sm text-center mt-2 p-2 rounded hidden" style="background-color: var(--accent-error); color: white;"></div>

            <div class="relative flex items-center justify-center my-4">
                <div class="absolute inset-0 flex items-center">
                    <div class="w-full border-t border-[var(--border-color)]"></div>
                </div>
                <div class="relative bg-[var(--card-bg)] px-4 text-sm font-medium text-[var(--text-secondary)]">
                    OR
                </div>
            </div>

            <!-- Google Sign In -->
            <button id="google-sign-in-btn" class="w-full flex items-center justify-center p-3 rounded-lg font-semibold border transition-colors mb-4" style="background-color: var(--bg-secondary); color: var(--text-primary); border-color: var(--border-color);">
                <span data-lucide="chrome" class="w-5 h-5 mr-2"></span> Sign In with Google
            </button>

            <!-- Toggle between Sign In / Sign Up -->
            <p id="auth-toggle-text" class="text-sm text-center mt-4">
                Need an account? <a href="#" id="auth-toggle-link" class="font-medium" style="color: var(--accent-primary-hover);">Sign Up</a>
            </p>
        </div>
    </div>
    <!-- End Authentication Modal/Overlay -->

    <!-- NEW: Markdown Export Modal/Overlay -->
    <div id="markdown-export-modal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[110] hidden p-4 backdrop-blur-sm">
        <div class="p-8 rounded-2xl shadow-xl w-full max-w-5xl h-5/6 flex flex-col transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary); border: 1px solid var(--border-color); box-shadow: var(--shadow-lg);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2 border-b pb-2" style="color: var(--accent-primary); border-color: var(--border-color);">
                <span data-lucide="file-text" class="w-6 h-6" style="color: var(--accent-primary);"></span> Export Chat to Markdown
            </h3>
            
            <!-- Tab Navigation -->
            <div class="flex mb-4 border-b" style="border-color: var(--border-color);">
                <button id="markdown-tab-edit" class="px-4 py-2 font-semibold transition-colors border-b-2" data-tab="edit" style="border-color: var(--accent-primary); color: var(--accent-primary); background-color: transparent;">Markdown Source</button>
                <button id="markdown-tab-preview" class="px-4 py-2 font-semibold transition-colors border-b-2" data-tab="preview" style="border-color: transparent; color: var(--text-secondary); background-color: transparent;">Preview</button>
            </div>
            
            <!-- Tab Content -->
            <div class="flex-1 overflow-hidden relative">
                
                <!-- Editor Tab -->
                <textarea id="markdown-export-input" class="w-full h-full p-4 rounded-lg border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm resize-none" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary); font-family: 'Fira Code', monospace; font-size: 0.9em;"></textarea>
                
                <!-- Preview Tab -->
                <div id="markdown-export-preview" class="w-full h-full p-4 rounded-lg border overflow-y-auto hidden markdown-content" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
                    <!-- Rendered Markdown content goes here -->
                </div>
            </div>

            <!-- Footer Actions -->
            <div class="flex justify-end gap-3 mt-4">
                <button id="copy-markdown-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="clipboard-copy" class="w-5 h-5 mr-2"></span> Copy Markdown
                </button>
                <button id="close-markdown-modal-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Close
                </button>
                <button id="download-markdown-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                    <span data-lucide="download" class="w-5 h-5 mr-2"></span> Download .md
                </button>
            </div>
        </div>
    </div>
    <!-- END Markdown Export Modal/Overlay -->

    <!-- NEW: Command Palette Modal (Quick-Access) -->
    <div id="command-palette-modal" class="fixed inset-0 bg-black bg-opacity-80 flex items-start justify-center z-[210] hidden p-4 pt-24">
        <div class="w-full max-w-xl bg-[var(--card-bg)] rounded-lg shadow-xl" style="border:1px solid var(--border-color);">
            <div class="p-4">
                <div class="flex items-center gap-2 mb-3">
                    <input id="command-palette-input" placeholder="Type a command (e.g. model flash or search orders)  Enter to run" class="" />
                    <button id="close-command-palette-btn" class="px-3 py-2 rounded" style="background:var(--bg-primary); border:1px solid var(--border-color);">Close</button>
                </div>
                <ul id="command-palette-list" class="max-h-64 overflow-y-auto space-y-1"></ul>
            </div>
        </div>
    </div>

    <!-- Floating Command Palette Button (Ctrl/Cmd+K) -->
    <button id="open-command-palette-btn" title="Command Palette (Ctrl/Cmd+K)">
        <span data-lucide="command" class="w-5 h-5"></span>
    </button>

    <!-- Inline slash suggestions (assists while typing in chat input) -->
    <div id="slash-suggestions" aria-hidden="true" role="region" aria-label="Command suggestions">
        <ul id="slash-suggestions-list" role="listbox" aria-label="Suggestions"></ul>
    </div>

    <!-- NEW: Attachment Editor Modal/Overlay (The 'Canvas') -->
    <div id="attachment-editor-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[110] hidden p-4">
        <div class="p-6 rounded-xl shadow-2xl w-full max-w-4xl h-5/6 flex flex-col transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2 border-b pb-2" style="color: var(--accent-primary); border-color: var(--border-color);">
                <span data-lucide="pencil" class="w-6 h-6" style="color: var(--accent-primary);"></span> Edit Attachment
            </h3>
            
            <!-- NEW: Filename Input for Renaming -->
            <input type="text" id="attachment-editor-filename-input" class="w-full p-3 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm mb-4" placeholder="Enter new filename (e.g., my_code.js)" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
            
            <!-- Editor Text Area (Editable Canvas) -->
            <textarea id="attachment-editor-input" class="flex-1 w-full p-4 rounded-lg border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm resize-none" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary); font-family: 'Fira Code', monospace; font-size: 0.9em;"></textarea>
            
            <!-- Footer Actions -->
            <div class="flex justify-end gap-3 mt-4">
                <button id="cancel-editor-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Cancel
                </button>
                <button id="save-editor-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                    <span data-lucide="save" class="w-5 h-5 mr-2"></span> Save Changes
                </button>
            </div>
        </div>
    </div>
    <!-- END Attachment Editor Modal/Overlay -->

    <!-- NEW: Rename Chat Modal/Overlay -->
    <div id="rename-chat-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[110] hidden p-4">
        <div class="p-6 rounded-xl shadow-2xl w-full max-w-md transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2 border-b pb-2" style="color: var(--accent-primary); border-color: var(--border-color);">
                <span data-lucide="pencil" class="w-6 h-6" style="color: var(--accent-primary);"></span> Rename Chat
            </h3>
            
            <input type="text" id="rename-chat-input" class="w-full p-3 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] focus:border-[var(--accent-primary)] transition-colors shadow-sm mb-4" placeholder="Enter new chat title" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
            
            <p id="rename-chat-id-placeholder" class="text-sm text-center mb-4" style="color: var(--text-secondary);">Chat ID: [Loading...]</p>

            <div class="flex flex-wrap justify-end gap-2 mt-4">
                <button id="auto-rename-chat-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center transition-colors" style="background-color: var(--accent-secondary); color: black;">
                    <span data-lucide="cpu" class="w-5 h-5 mr-2"></span> Auto Rename (AI)
                </button>
                <button id="save-rename-chat-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                    <span data-lucide="save" class="w-5 h-5 mr-2"></span> Save
                </button>
                <button id="cancel-rename-chat-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Cancel
                </button>
            </div>
        </div>
    </div>
    <!-- END Rename Chat Modal/Overlay -->

    <!-- ADD THIS SECTION -->
    <!-- Scroll to Top/Bottom Buttons -->
    <div class="scroll-buttons-container">
        <!-- New Location for Code Block Jump Buttons -->
        <button id="jump-code-prev-btn" class="scroll-button hidden" aria-label="Previous Code Block" title="Previous Code Block">
            <span data-lucide="chevrons-up" class="w-5 h-5"></span>
        </button>
        <button id="jump-code-next-btn" class="scroll-button hidden" aria-label="Next Code Block" title="Next Code Block">
            <span data-lucide="chevrons-down" class="w-5 h-5"></span>
        </button>
        
        <!-- Existing Scroll To Top/Bottom Buttons -->
        <button id="jump-to-top-btn" class="scroll-button" aria-label="Jump to Top" title="Jump to Top">
            <span data-lucide="arrow-up-circle" class="w-5 h-5"></span>
        </button>
        <button id="jump-to-bottom-btn" class="scroll-button" aria-label="Jump to Bottom" title="Jump to Bottom">
            <span data-lucide="arrow-down-circle" class="w-5 h-5"></span>
        </button>
    </div>
    <!-- END Jump Buttons -->

    <!-- NEW: Developer Console Modal (Request 3) -->
    <div id="developer-console-modal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[110] hidden p-4 backdrop-blur-sm">
        <div class="p-8 rounded-2xl shadow-xl w-full max-w-5xl h-5/6 flex flex-col transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary); border: 1px solid var(--border-color); box-shadow: var(--shadow-lg);">
            <h3 class="text-xl font-bold mb-4 flex items-center justify-between border-b pb-2" style="color: var(--accent-primary); border-color: var(--border-color);">
                <span class="flex items-center gap-2">
                    <span data-lucide="bug" class="w-6 h-6" style="color: var(--accent-primary);"></span> Developer Console
                </span>
                <div class="flex gap-2">
                    <button id="clear-console-btn" class="p-2 rounded-full text-sm" title="Clear Console" style="background-color: var(--bg-primary); color: var(--accent-error);">
                        <span data-lucide="eraser" class="w-4 h-4"></span>
                    </button>
                    <button id="close-console-modal-btn" class="p-2 rounded-full text-sm" title="Close Console" style="background-color: var(--bg-primary); color: var(--text-secondary);">
                        <span data-lucide="x" class="w-4 h-4"></span>
                    </button>
                </div>
            </h3>
            
            <div id="developer-console-content" class="flex-1 rounded-lg">
                <!-- Logs will be appended here -->
                <p>--- Console Log Started ---</p>
            </div>
            
            <div class="mt-4 text-xs text-center" style="color: var(--text-secondary);">
                This console captures and displays application logs (info, warnings, and errors).
            </div>
        </div>
    </div>
    <!-- END Developer Console Modal -->
    
    <!-- NEW: API Key Management Modal -->
    <div id="api-key-management-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[110] hidden p-4">
        <div class="p-6 rounded-xl shadow-2xl w-full max-w-lg transition-all duration-300" style="background-color: var(--card-bg); color: var(--text-primary);">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2 border-b pb-2" style="color: var(--accent-primary); border-color: var(--border-color);">
                <span data-lucide="key-round" class="w-6 h-6" style="color: var(--accent-primary);"></span> Manage API Keys
            </h3>
            
            <!-- Key Input Form -->
            <div class="mb-6 p-4 rounded-lg" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                <h4 class="font-semibold mb-2" style="color: var(--accent-secondary);">Add/Edit Key</h4>
                <input type="text" id="api-key-label-input" class="w-full p-2 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] transition-colors shadow-sm mb-2" placeholder="Label (e.g., 'Personal', 'Testing')" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
                <input type="password" id="api-key-secret-input" class="w-full p-3 rounded-md border focus:ring-2 focus:ring-[var(--accent-primary)] transition-colors shadow-sm mb-4" placeholder="Enter full Gemini API Key" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
                <div class="flex justify-end gap-2">
                    <button id="clear-key-form-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">
                        <span data-lucide="eraser" class="w-5 h-5 mr-2"></span> Clear
                    </button>
                    <button id="save-key-btn" class="px-4 py-2 rounded-lg font-semibold glow-button flex items-center" style="background-color: var(--accent-primary); color: black;">
                        <span data-lucide="plus" class="w-5 h-5 mr-2"></span> Add Key
                    </button>
                </div>
            </div>

            <!-- Saved Keys List -->
            <h4 class="font-semibold mb-3 flex items-center gap-2" style="color: var(--text-primary);">
                <span data-lucide="list-checks" class="w-5 h-5" style="color: var(--accent-secondary);"></span> Saved Keys
            </h4>
            <ul id="saved-keys-list" class="space-y-3 max-h-40 overflow-y-auto pr-2">
                <!-- Keys will be dynamically loaded here -->
            </ul>

            <div class="flex justify-end mt-6">
                <button id="close-key-management-btn" class="px-4 py-2 rounded-lg font-semibold flex items-center" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                    <span data-lucide="x" class="w-5 h-5 mr-2"></span> Close
                </button>
            </div>
        </div>
    </div>
    <!-- END API Key Management Modal -->

    <script type="text/javascript">
        // Register Service Worker for PWA capabilities
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        const createIcons = () => {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        };

        // --- NEW: Global Tooltip Manager (Suggestion 13) ---
        // Tooltip timeout handle
        let tooltipTimeout;

        /**
         * Positions and shows the global tooltip based on mouse coordinates or focused elements.
         */
        function showGlobalTooltip(event) {
            // Determine the target element that has the data attribute
            let target = null;
            try {
                target = event && event.target && event.target.closest ? event.target.closest('[data-help-content]') : null;
            } catch (err) {
                target = null;
            }

            if (!target) {
                hideGlobalTooltip();
                return;
            }

            const content = target.dataset.helpContent;
            if (!content) return;

            // Clear any existing hide timeouts
            clearTimeout(tooltipTimeout);

            // Set content and prepare positioning
            const tooltipEl = document.getElementById('global-tooltip');
            if (!tooltipEl) return;

            tooltipEl.innerHTML = content;
            tooltipEl.style.opacity = '0';
            // Make visible for layout measurement so width/height are known
            tooltipEl.style.visibility = 'visible';
            tooltipEl.classList.remove('opacity-0');

            // Use a slight delay to prevent immediate flickering on quick movements
            tooltipTimeout = setTimeout(() => {
                // If the event has mouse coordinates, use them; otherwise, position relative to the element's bounding rect
                if (event && typeof event.clientX === 'number' && typeof event.clientY === 'number') {
                    positionTooltip(event, tooltipEl);
                } else {
                    const rect = target.getBoundingClientRect();
                    const fakeEvent = { clientX: rect.left + (rect.width / 2), clientY: rect.top + (rect.height / 2) };
                    positionTooltip(fakeEvent, tooltipEl);
                }

                // Finally, reveal the tooltip
                tooltipEl.style.opacity = '1';
                tooltipEl.style.visibility = 'visible';
                tooltipEl.setAttribute('aria-hidden', 'false');
            }, 150);
        }

        /**
         * Hides the global tooltip.
         */
        function hideGlobalTooltip() {
            clearTimeout(tooltipTimeout);
            const tooltipEl = document.getElementById('global-tooltip');
            if (!tooltipEl) return;
            tooltipEl.style.opacity = '0';
            tooltipEl.style.visibility = 'hidden';
            tooltipEl.setAttribute('aria-hidden', 'true');
        }

        /**
         * Calculates position to prevent the tooltip from going off-screen.
         */
        function positionTooltip(event, tooltipEl) {
            const tooltipWidth = tooltipEl.offsetWidth;
            const tooltipHeight = tooltipEl.offsetHeight;
            const padding = 10;
            
            // Determine target position based on mouse (or target element if preferred)
            let x = event.clientX + 15; // Offset 15px from cursor
            let y = event.clientY + 15;

            // Check right boundary
            if (x + tooltipWidth + padding > window.innerWidth) {
                // Flip to the left of the cursor
                x = event.clientX - tooltipWidth - 15; 
                
                // If it's still off screen to the left, center it horizontally
                if (x < padding) { 
                    x = (window.innerWidth - tooltipWidth) / 2;
                }
            }
            
            // Check bottom boundary
            if (y + tooltipHeight + padding > window.innerHeight) {
                // Flip to the top of the cursor
                y = event.clientY - tooltipHeight - 15;
            }

            tooltipEl.style.left = `${x}px`;
            tooltipEl.style.top = `${y}px`;
            tooltipEl.style.position = 'fixed';
            tooltipEl.style.zIndex = '1000';
        }

        // --- Developer Console Interception (MODIFIED for Request 3) ---
        const originalConsole = {
            log: console.log,
            warn: console.warn,
            error: console.error,
            info: console.info || console.log,
            debug: console.debug || console.log
        };
        const logHistory = [];
        const MAX_LOGS = 500;

        function formatLogMessage(level, args) {
            const timestamp = new Date().toLocaleTimeString();
            const message = args.map(arg => {
                if (typeof arg === 'object' && arg !== null) {
                    try {
                        return JSON.stringify(arg, null, 2);
                    } catch {
                        return arg.toString();
                    }
                }
                return String(arg);
            }).join(' ');

            return { timestamp, level, message };
        }

        function renderConsoleLog(log) {
            const consoleContent = document.getElementById('developer-console-content');
            if (!consoleContent) return;

            const logDiv = document.createElement('div');
            logDiv.classList.add('log-item');
            logDiv.innerHTML = `
                <span class="log-timestamp">${log.timestamp}</span>
                <span class="log-level-${log.level.toLowerCase()}">${log.level.toUpperCase()}</span>
                <span style="color: white; margin-left: 10px;">${log.message}</span>
            `;
            consoleContent.appendChild(logDiv);
            
            // Limit log history size
            if (consoleContent.children.length > MAX_LOGS) {
                consoleContent.removeChild(consoleContent.children[0]);
            }
            consoleContent.scrollTop = consoleContent.scrollHeight;
        }

        function hijackConsole() {
            // Include 'log', 'warn', 'error', 'info', and 'debug' to capture everything
            ['log', 'warn', 'error', 'info', 'debug'].forEach(level => {
                // Ensure the original function is called first to preserve console behavior
                const originalFn = originalConsole[level];
                
                console[level] = function(...args) {
                    // Call the original console method as it is, without modification
                    originalFn.apply(console, args);
                    
                    // Store and render the log
                    const log = formatLogMessage(level, args);
                    logHistory.push(log);
                    renderConsoleLog(log);
                };
            });
            console.log("Console Hijacking Active.");
        }
        
        // Hijack console immediately upon script execution
        hijackConsole();

        // --- Firebase Configuration and Initialization ---
        const firebaseConfig = {
            apiKey: "AIzaSyAnKYJ91xb318h2YjBNcB-ygnrQgu4WdM8",
            authDomain: "small-ai-v2.firebaseapp.com",
            projectId: "small-ai-v2",
            storageBucket: "small-ai-v2.firebaseapp.com",
            messagingSenderId: "1035216670524",
            appId: "1:1035216670524:web:28a98375641300d4615839",
            measurementId: "G-WY4EEQ5RYE"
        };

        // Initialize Firebase
        let app, auth, db;
        try {
            app = firebase.initializeApp(firebaseConfig);
            auth = firebase.auth();
            db = firebase.firestore();
            db.settings({ timestampsInSnapshots: true });
            console.log("Firebase initialized successfully.");            
        } catch (e) {
            console.error("Firebase Initialization Error:", e);
            showError("Firebase failed to initialize. Check console for details.");
        }
        const GoogleProvider = new firebase.auth.GoogleAuthProvider();

        // Firestore paths
        const FIRESTORE_USERS_COLLECTION = 'users';
        const FIRESTORE_SETTINGS_DOC = 'settings';
        const FIRESTORE_CHATS_COLLECTION = 'chats';
        const FIRESTORE_TEMPLATES_DOC = 'templates';

        // NEW: Global User State
        let currentUser = null; 
        let userApiKey = null; 
        let isAuthSetupComplete = false; 

        // DOM elements
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        const hamburgerMenuButton = document.getElementById('hamburger-menu-button');

        const mainChatWindow = document.getElementById('main-chat-window');
        const darkModeToggle = document.getElementById('dark-mode-toggle'); 
        const appThemeSelect = document.getElementById('app-theme-select-sidebar'); 
        const newChatButton = document.getElementById('new-chat-button');
        const chatHistoryDiv = document.getElementById('chat-history');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        const chatFileUpload = document.getElementById('chat-file-upload');
        const chatAttachmentsPreviewContainer = document.getElementById('chat-attachments-preview-container'); 
        const voiceInputBtn = document.getElementById('voice-input-btn');
        const copyMessage = document.getElementById('copy-message');
        const versionSelectSidebar = document.getElementById('version-select-sidebar');
        const sidebarChatList = document.getElementById('sidebar-chat-list');
        const chatInputAreaContainer = document.getElementById('chat-input-area-container'); 

        // NEW: Prompt Generation Tool DOM elements (Request 4)
        const promptToolContainer = document.getElementById('prompt-tool-container');
        const promptToolAcceptBtn = document.getElementById('prompt-tool-accept-btn');
        const promptToolCancelBtn = document.getElementById('prompt-tool-cancel-btn');

        // NEW: State for prompt tool
        let promptToolTimeout = null;
        const PROMPT_MIN_LENGTH = 10;
        // The maximum length is now set extremely high (e.g., 10000) 
        // to effectively remove the limit on the user's initial draft.
        // The API call itself has its own token limit, so this keeps the user experience flexible.
        const PROMPT_MAX_LENGTH = 10000; 
        // NEW: Model Selector DOM elements
        const modelSelectSidebar = document.getElementById('model-select-sidebar'); 
        
        // NEW: Settings Toggle DOM elements
        const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
        const settingsContent = document.getElementById('settings-content');
        const settingsChevron = document.getElementById('settings-chevron');
        // NEW: Theme Randomizer Button
        const randomThemeBtn = document.getElementById('random-theme-btn');

        // NEW: Auto Theme Switch DOM elements
        const autoThemeDelayInput = document.getElementById('auto-theme-delay');
        const toggleAutoThemeBtn = document.getElementById('toggle-auto-theme-btn');
        let autoThemeInterval = null;         

        // NEW: Conversation Mode DOM elements
        const conversationModeOverlay = document.getElementById('conversation-mode-overlay');
        const conversationModeToggleBtn = document.getElementById('conversation-mode-toggle-btn');
        const conversationModeCloseBtn = document.getElementById('conversation-mode-close-btn');
        const voiceSelect = document.getElementById('voice-select');
        const personalitySelect = document.getElementById('personality-select');
        const soundBlob = document.getElementById('sound-blob');
        const conversationStatusText = document.getElementById('conversation-status-text');
        const conversationHistoryDisplay = document.getElementById('conversation-history-display');
        const conversationMicBtn = document.getElementById('conversation-mic-btn');

        // NEW: Custom Prompt DOM elements
        const toggleCustomPromptBtn = document.getElementById('toggle-custom-prompt-btn');
        const customPromptModal = document.getElementById('custom-prompt-modal');
        const customPromptInput = document.getElementById('custom-prompt-input');

        // Quick Start Guide Modal
        const quickStartModal = document.getElementById('quick-start-modal');
        const closeQuickStartBtn = document.getElementById('close-quick-start-btn');
        if (closeQuickStartBtn) closeQuickStartBtn.addEventListener('click', () => { quickStartModal.classList.add('hidden'); document.body.style.overflow = ''; });

        function openQuickStartGuideModal() {
            if (quickStartModal) {
                quickStartModal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
            }
        }

        // --- Command Palette (Quick-Access UI) ---
        const commandPaletteModal = document.getElementById('command-palette-modal');
        const commandPaletteInput = document.getElementById('command-palette-input');
        const commandPaletteList = document.getElementById('command-palette-list');
        const openCommandPaletteBtn = document.getElementById('open-command-palette-btn');
        const closeCommandPaletteBtn = document.getElementById('close-command-palette-btn');

        const COMMANDS = [
            { cmd: 'clear', title: 'Clear Input', desc: 'Clear the chat input and attachments', sample:'/clear' },
            { cmd: 'export', title: 'Export Chat', desc: 'Open Markdown Export modal for current chat', sample:'/export', options: ['md','pdf','html','json'] },
            { cmd: 'new', title: 'New Chat', desc: 'Start a new conversation session', sample:'/new' },
            { cmd: 'help', title: 'Quick Start Guide', desc: 'Open the quick start guide modal', sample:'/help' },
            { cmd: 'guide', title: 'Quick Start Guide (alias)', desc: 'Alias for /help', sample:'/guide' },
            { cmd: 'settings', title: 'Open Settings', desc: 'Open sidebar and expand settings', sample:'/settings' },
            { cmd: 'summarize', title: 'Summarize Chat', desc: 'Generate contextual summary into Custom Prompt', sample:'/summarize' },
            { cmd: 'model', title: 'Switch Model', desc: 'Switch AI model (e.g., /model flash)', sample:'/model flash', options: ['gpt-4o','gpt-4o-mini','flash','gpt-3.5-turbo','gpt-4o-mini-embedding'] },
            { cmd: 'template', title: 'Load Template', desc: 'Load and activate a saved prompt template', sample:'/template MyTemplate' },
            { cmd: 'search', title: 'Search in Chat', desc: 'Open in-chat search and run a query', sample:'/search your query' },

            /* Additional commands to cover the full app features */
            { cmd: 'theme', title: 'Apply Theme', desc: 'Apply a theme by name or use /theme random', sample:'/theme celestial-horizon-light', options: ['dark','light','system','random'] },
            { cmd: 'dark', title: 'Dark Mode', desc: 'Switch to dark mode (alias /dark or /light)', sample:'/dark' },
            { cmd: 'light', title: 'Light Mode', desc: 'Switch to light mode', sample:'/light' },
            { cmd: 'voice', title: 'Voice Input', desc: 'Start/stop voice input (speech-to-text)', sample:'/voice start', options: ['start','stop','toggle'] },
            { cmd: 'attach', title: 'Attach Files', desc: 'Open the file picker to attach files', sample:'/attach', options: ['file','url'] },
            { cmd: 'download', title: 'Download Markdown', desc: 'Download the current chat as Markdown', sample:'/download', options: ['md','pdf'] },
            { cmd: 'signin', title: 'Sign in', desc: 'Open sign-in flow (Google)', sample:'/signin', options: ['google'] },
            { cmd: 'signout', title: 'Sign out', desc: 'Sign out of the current session', sample:'/signout' },
            { cmd: 'console', title: 'Developer Console', desc: 'Open the developer console to view logs', sample:'/console' },
            { cmd: 'delete-all', title: 'Delete All Chats', desc: 'Delete all saved chat sessions (confirmation required)', sample:'/delete-all' },
            { cmd: 'clear-storage', title: 'Clear Browser Data', desc: 'Clear local storage, caches and service workers', sample:'/clear-storage' },
            { cmd: 'rename', title: 'Rename Chat', desc: 'Rename the active chat: /rename New Title', sample:'/rename Project Plan' },
            { cmd: 'save-prompt', title: 'Save Custom Prompt', desc: 'Save current Custom Prompt as active', sample:'/save-prompt' },
            { cmd: 'manage-templates', title: 'Manage Templates', desc: 'Open prompt templates manager', sample:'/manage-templates' },
            { cmd: 'prompt-tool', title: 'Prompt Enhancement Tool', desc: 'Open prompt enhancement tool', sample:'/prompt-tool' },
            { cmd: 'random-theme', title: 'Random Theme', desc: 'Pick a random theme and mode', sample:'/random-theme' }
        ];

        let paletteSelectedIndex = -1;
        let paletteOpenedFromChatInput = false; // tracks when palette was opened via chat input /slash trigger
        

        function renderCommandPalette(filter = '') {
            if (!commandPaletteList) return;
            const q = filter.trim().toLowerCase();
            let results = COMMANDS.filter(c => {
                if (!q) return true;
                return c.cmd.indexOf(q) === 0 || c.title.toLowerCase().includes(q) || c.desc.toLowerCase().includes(q) || c.sample.toLowerCase().includes(q);
            });
            if (results.length === 0 && q.includes(' ')) {
                const firstWord = q.split(' ')[0];
                results = COMMANDS.filter(c => c.cmd.startsWith(firstWord));
            }
            commandPaletteList.innerHTML = '';
            results.forEach((c, i) => {
                const li = document.createElement('li');
                li.className = 'command-palette-item';
                li.tabIndex = -1;
                li.dataset.command = c.cmd;
                li.dataset.sample = c.sample;
                li.innerHTML = `<div class="sample">${c.sample}</div><div class="text-xs" style="color:var(--text-secondary);">${c.desc}</div>`;
                li.addEventListener('click', () => {
                    executePaletteCommand(commandPaletteInput.value || c.sample);
                });
                li.addEventListener('mouseover', () => {
                    setPaletteSelection(i);
                });
                commandPaletteList.appendChild(li);
            });
            if (results.length > 0) setPaletteSelection(0); else setPaletteSelection(-1);
        }

        function setPaletteSelection(i) {
            const items = commandPaletteList ? commandPaletteList.querySelectorAll('.command-palette-item') : [];
            items.forEach((it, idx) => {
                if (idx === i) it.classList.add('selected'); else it.classList.remove('selected');
            });
            paletteSelectedIndex = i;
        }

        function openCommandPalette(initialText = '') {
            if (!commandPaletteModal) return;
            commandPaletteModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            if (commandPaletteInput) commandPaletteInput.value = initialText;
            renderCommandPalette(initialText);
            setTimeout(() => { if (commandPaletteInput) commandPaletteInput.focus(); }, 50);
            // If this palette was opened from chat input, mark the flag
            paletteOpenedFromChatInput = !!initialText || paletteOpenedFromChatInput;
        }

        function closeCommandPalette() {
            if (!commandPaletteModal) return;
            commandPaletteModal.classList.add('hidden');
            document.body.style.overflow = '';
            if (commandPaletteInput) commandPaletteInput.value = '';
            if (commandPaletteList) commandPaletteList.innerHTML = '';
            // If this was opened from the chat input, restore focus to it
            if (paletteOpenedFromChatInput) {
                chatInput.focus();
                paletteOpenedFromChatInput = false;
            }
            paletteSelectedIndex = -1;
        }

        // ---------------------- Inline Slash Suggestions ----------------------
        const slashSuggestionsBox = document.getElementById('slash-suggestions');
        const slashSuggestionsList = document.getElementById('slash-suggestions-list');
        let slashSuggestions = [];
        let slashSelectedIndex = -1;

        function getCursorTokenInfo(inputEl) {
            const val = inputEl.value || '';
            if (!val.startsWith('/')) return null;
            const caretPos = inputEl.selectionStart || 0;
            const raw = val.slice(1); // drop leading '/'
            const parts = raw.split(/\s+/);
            // determine which token caret is inside
            let accum = 0;
            for (let i = 0; i < parts.length; i++) {
                const p = parts[i];
                const start = accum; // relative to raw
                const end = accum + p.length; // inclusive end index
                if (caretPos - 1 >= start && caretPos - 1 <= end) {
                    // compute global positions (in original input value)
                    const globalStart = 1 + start;
                    const globalEnd = globalStart + p.length;
                    return { parts, tokenIndex: i, token: p, globalStart, globalEnd };
                }
                accum = end + 1; // account for the space
            }
            // caret after last token (or at end)
            const lastIdx = parts.length - 1;
            const globalStart = 1 + (raw.length - (parts[lastIdx] ? parts[lastIdx].length : 0));
            return { parts, tokenIndex: parts.length - 1, token: parts[lastIdx] || '', globalStart, globalEnd: 1 + raw.length };
        }

        function findCommandEntry(cmdName) {
            if (!cmdName) return null;
            return COMMANDS.find(c => c.cmd === cmdName);
        }

        function renderInlineSuggestions() {
            try {
                if (!slashSuggestionsBox || !slashSuggestionsList || !chatInput) return;
                const info = getCursorTokenInfo(chatInput);
                if (!info) { closeInlineSuggestions(); return; }
                // If the command palette modal is visible, don't show inline box
                if (commandPaletteModal && !commandPaletteModal.classList.contains('hidden')) { closeInlineSuggestions(); return; }

                const { parts, tokenIndex, token } = info;
                const lower = (token || '').toLowerCase();
                let suggestions = [];

                if (tokenIndex === 0) {
                    // suggest commands
                    suggestions = COMMANDS.filter(c => c.cmd.startsWith(lower) || c.title.toLowerCase().includes(lower) || c.desc.toLowerCase().includes(lower) || c.sample.toLowerCase().includes(lower))
                        .slice(0, 12)
                        .map(c => ({ label: c.cmd, meta: c.desc, value: c.cmd }));
                } else {
                    // suggest options for the command in parts[0]
                    const cmd = parts[0];
                    const entry = findCommandEntry(cmd);
                    if (entry && entry.options && entry.options.length) {
                        suggestions = entry.options.filter(o => o.toLowerCase().indexOf(lower) === 0 || o.toLowerCase().includes(lower))
                            .slice(0, 20)
                            .map(o => ({ label: o, meta: entry.title, value: o }));
                    }
                }

                slashSuggestions = suggestions;
                slashSelectedIndex = suggestions.length > 0 ? 0 : -1;
                // render list
                slashSuggestionsList.innerHTML = '';
                if (suggestions.length === 0) {
                    const li = document.createElement('li');
                    li.className = 'slash-suggestion-empty';
                    li.innerText = tokenIndex === 0 ? 'No matching commands' : 'No matching options for this command';
                    slashSuggestionsList.appendChild(li);
                    openInlineSuggestions();
                    return;
                }
                suggestions.forEach((s, i) => {
                    const li = document.createElement('li');
                    li.className = 'slash-suggestion-item';
                    li.tabIndex = -1;
                    li.setAttribute('role','option');
                    li.setAttribute('aria-selected', i === slashSelectedIndex ? 'true' : 'false');
                    if (i === slashSelectedIndex) li.classList.add('selected');
                    li.dataset.index = i;
                    li.innerHTML = `<div class="label">${s.label}</div><div class="meta">${s.meta || ''}</div>`;
                    li.addEventListener('click', () => {
                        applyInlineSuggestion(i);
                    });
                    li.addEventListener('mouseover', () => {
                        setSlashSelection(i);
                    });
                    slashSuggestionsList.appendChild(li);
                });
                openInlineSuggestions();
            } catch (err) {
                console.error('Error while rendering inline suggestions', err);
                if (typeof showError === 'function') showError('Suggestion error: ' + (err && err.message));
                closeInlineSuggestions();
            }
        }

        function setSlashSelection(i) {
            const items = slashSuggestionsList ? slashSuggestionsList.querySelectorAll('.slash-suggestion-item') : [];
            items.forEach((it, idx) => {
                if (idx === i) {
                    it.classList.add('selected');
                    it.setAttribute('aria-selected','true');
                } else {
                    it.classList.remove('selected');
                    it.setAttribute('aria-selected','false');
                }
            });
            slashSelectedIndex = i;
        }

        function openInlineSuggestions() {
            if (!slashSuggestionsBox || !chatInput) return;
            // position the box near the chat input's caret (prefer above the textarea)
            const rect = chatInput.getBoundingClientRect();
            // Make visible off-screen for measurement
            slashSuggestionsBox.style.left = (rect.left + window.scrollX) + 'px';
            slashSuggestionsBox.style.top = '0px';
            slashSuggestionsBox.classList.add('visible');
            slashSuggestionsBox.style.visibility = 'hidden';

            // measure
            const boxRect = slashSuggestionsBox.getBoundingClientRect();
            const boxH = boxRect.height;
            const boxW = boxRect.width;

            // Decide placement: prefer above input
            let desiredTop = rect.top + window.scrollY - boxH - 8; // 8px gap
            let placeAbove = true;
            if (desiredTop < window.scrollY + 8) {
                // not enough space above; place below
                desiredTop = rect.top + window.scrollY + rect.height + 8;
                placeAbove = false;
            }

            // Clamp left so it stays inside viewport
            let desiredLeft = rect.left + window.scrollX;
            const maxLeft = window.scrollX + document.documentElement.clientWidth - boxW - 8;
            if (desiredLeft > maxLeft) desiredLeft = Math.max(8 + window.scrollX, maxLeft);
            if (desiredLeft < 8 + window.scrollX) desiredLeft = 8 + window.scrollX;

            slashSuggestionsBox.style.left = desiredLeft + 'px';
            slashSuggestionsBox.style.top = desiredTop + 'px';
            slashSuggestionsBox.style.transform = 'none';
            slashSuggestionsBox.style.visibility = 'visible';
            // add a class to indicate placement used
            if (placeAbove) slashSuggestionsBox.classList.add('placed-above'); else slashSuggestionsBox.classList.remove('placed-above');

            slashSuggestionsBox.setAttribute('aria-hidden', 'false');
        }

        function closeInlineSuggestions() {
            if (!slashSuggestionsBox) return;
            slashSuggestionsBox.classList.remove('visible');
            slashSuggestionsBox.setAttribute('aria-hidden', 'true');
            slashSuggestionsList.innerHTML = '';
            slashSuggestions = [];
            slashSelectedIndex = -1;
        }

        async function applyInlineSuggestion(index) {
            try {
                if (!chatInput) return;
                const info = getCursorTokenInfo(chatInput);
                if (!info) return;
                const s = slashSuggestions[index];
                if (!s) return;
                const { globalStart, globalEnd, tokenIndex } = info;
                // globalStart/globalEnd are positions relative to whole input
                const before = chatInput.value.slice(0, globalStart);
                const after = chatInput.value.slice(globalEnd);
                // If replacing command token, add trailing space to move to options
                const insertText = (tokenIndex === 0) ? (s.value + ' ') : (s.value + ' ');
                chatInput.value = before + insertText + after;
                // position the caret after inserted text
                const newPos = before.length + insertText.length;
                chatInput.setSelectionRange(newPos, newPos);
                // If we just inserted a command that has options, present options automatically
                const entry = tokenIndex === 0 ? findCommandEntry(s.value) : null;
                if (tokenIndex === 0 && entry && entry.options && entry.options.length) {
                    // re-render inline suggestions for next token
                    renderInlineSuggestions();
                    return;
                }

                // If we inserted an option (tokenIndex > 0), execute the command immediately
                if (tokenIndex > 0) {
                    try {
                        const cmdName = info.parts[0];
                        const cmdStr = '/' + cmdName + ' ' + s.value;
                        const handled = await handleSlashCommand(cmdStr);
                        if (handled) {
                            chatInput.value = '';
                            adjustChatInputHeight();
                        }
                    } catch (err) {
                        console.error('Error executing command after option selection', err);
                        if (typeof showError === 'function') showError('Failed to run command: ' + (err && err.message));
                    }
                    closeInlineSuggestions();
                    chatInput.focus();
                    return;
                }

                // If this command has no options, execute it immediately
                if (tokenIndex === 0 && entry && (!entry.options || entry.options.length === 0)) {
                    // execute asynchronously and clear input if handled
                    (async () => {
                        const handled = await handleSlashCommand('/' + entry.cmd);
                        if (handled) {
                            chatInput.value = '';
                            adjustChatInputHeight();
                        }
                    })();
                }
                closeInlineSuggestions();
                chatInput.focus();
            } catch (err) {
                console.error('Error in applyInlineSuggestion', err);
                if (typeof showError === 'function') showError('Suggestion apply failed: ' + (err && err.message));
            }
        }

        // Keyboard handling while suggestions visible
        chatInput.addEventListener('keydown', async (e) => {
            if (slashSuggestions && slashSuggestions.length && slashSuggestionsBox && slashSuggestionsBox.classList.contains('visible')) {
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setSlashSelection(Math.min(slashSelectedIndex + 1, slashSuggestions.length - 1));
                    const items = slashSuggestionsList.querySelectorAll('.slash-suggestion-item'); if (items[slashSelectedIndex]) items[slashSelectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setSlashSelection(Math.max(slashSelectedIndex - 1, 0));
                    const items = slashSuggestionsList.querySelectorAll('.slash-suggestion-item'); if (items[slashSelectedIndex]) items[slashSelectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter' || e.key === 'Tab') {
                    if (slashSelectedIndex >= 0) {
                        e.preventDefault();
                        await applyInlineSuggestion(slashSelectedIndex);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeInlineSuggestions();
                }
            }
        });

        // keep inline suggestions in sync as the user types
        chatInput.addEventListener('input', (e) => {
            const val = chatInput.value || '';
            if (val.startsWith('/')) {
                // don't show both the big palette and inline suggestions at once
                if (!commandPaletteModal || commandPaletteModal.classList.contains('hidden')) {
                    renderInlineSuggestions();
                } else {
                    closeInlineSuggestions();
                }
            } else {
                closeInlineSuggestions();
            }
        });

        // hide suggestions when focus leaves
        chatInput.addEventListener('blur', (e) => {
            setTimeout(() => { closeInlineSuggestions(); }, 150);
        });

        // --------------------------------------------------------------------

        function executePaletteCommand(inputValue) {
            let s = (inputValue || '').trim();
            if (!s) {
                const items = commandPaletteList ? commandPaletteList.querySelectorAll('.command-palette-item') : [];
                if (paletteSelectedIndex >= 0 && items[paletteSelectedIndex]) {
                    s = items[paletteSelectedIndex].dataset.sample || '';
                } else {
                    closeCommandPalette();
                    return;
                }
            }
            if (!s.startsWith('/')) s = '/' + s;
            (async () => {
                const handled = await handleSlashCommand(s);
                if (handled) {
                    // If the palette was opened from chat input, clear the chat input to avoid re-triggering
                    if (paletteOpenedFromChatInput) {
                        chatInput.value = '';
                        adjustChatInputHeight();
                    }
                    closeCommandPalette();
                } else showError(`Failed to execute: ${s}`);
            })();
        }

        if (commandPaletteInput) {
            commandPaletteInput.addEventListener('input', (e) => renderCommandPalette(e.target.value));
            commandPaletteInput.addEventListener('keydown', (e) => {
                const items = commandPaletteList ? commandPaletteList.querySelectorAll('.command-palette-item') : [];
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setPaletteSelection(Math.min(paletteSelectedIndex + 1, items.length - 1));
                    if (items[paletteSelectedIndex]) items[paletteSelectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setPaletteSelection(Math.max(paletteSelectedIndex - 1, 0));
                    if (items[paletteSelectedIndex]) items[paletteSelectedIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    executePaletteCommand(commandPaletteInput.value);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeCommandPalette();
                    // If palette was opened from chat input, restore focus there
                    if (paletteOpenedFromChatInput) {
                        chatInput.focus();
                        paletteOpenedFromChatInput = false;
                    }
                }
            });
        }

        if (openCommandPaletteBtn) openCommandPaletteBtn.addEventListener('click', () => openCommandPalette());
        if (closeCommandPaletteBtn) closeCommandPaletteBtn.addEventListener('click', () => closeCommandPalette());
        if (commandPaletteModal) commandPaletteModal.addEventListener('click', (e) => { if (e.target === commandPaletteModal) closeCommandPalette(); });

        // Global keyboard shortcut: Ctrl/Cmd + K to open command palette
        window.addEventListener('keydown', (e) => {
            const isInputActive = document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA');
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
                e.preventDefault();
                openCommandPalette();
            } else if (e.key === 'Escape') {
                if (commandPaletteModal && !commandPaletteModal.classList.contains('hidden')) closeCommandPalette();
            }
            // If user presses '/' while focus is on chat input, show inline assistive suggestions (don't auto-open full palette)
            if (e.key === '/' && document.activeElement === chatInput) {
                // Wait one tick so the slash is present in the input, then render inline suggestions
                setTimeout(() => {
                    renderInlineSuggestions();
                }, 0);
            }
        });

        const saveCustomPromptBtn = document.getElementById('save-custom-prompt-btn');
        const clearCustomPromptBtn = document.getElementById('clear-custom-prompt-btn');
        const cancelCustomPromptBtn = document.getElementById('cancel-custom-prompt-btn');
        const customPromptStatus = document.getElementById('custom-prompt-status');

        // NEW: Prompt Templates DOM elements
        const manageTemplatesBtn = document.getElementById('manage-templates-btn');
        const promptTemplatesModal = document.getElementById('prompt-templates-modal');
        const templateNameInput = document.getElementById('template-name-input');
        const templateContentInput = document.getElementById('template-content-input');
        const saveTemplateBtn = document.getElementById('save-template-btn');
        const clearTemplateFormBtn = document.getElementById('clear-template-form-btn');
        const cancelTemplateModalBtn = document.getElementById('cancel-template-modal-btn');
        const savedTemplatesList = document.getElementById('saved-templates-list');

        // NEW: Data Management Buttons
        const deleteAllChatsBtn = document.getElementById('delete-all-chats-btn');
        const clearLocalStorageBtn = document.getElementById('clear-local-storage-btn');
        
        // NEW: Auth Modal DOM elements
        const authModal = document.getElementById('auth-modal');
        const authEmail = document.getElementById('auth-email');
        const authPassword = document.getElementById('auth-password');
        const authActionBtn = document.getElementById('auth-action-btn');
        const googleSignInBtn = document.getElementById('google-sign-in-btn');
        const authToggleLink = document.getElementById('auth-toggle-link');
        const authTitle = document.getElementById('auth-title');
        const authError = document.getElementById('auth-error');
        const userEmailSpan = document.getElementById('user-email');
        const signOutButton = document.getElementById('sign-out-button');
        
        // NEW: API Key DOM elements (F1)
        const apiKeySelect = document.getElementById('api-key-select'); // MODIFIED
        const manageApiKeysBtn = document.getElementById('manage-api-keys-btn'); // NEW
        const apiKeyStatus = document.getElementById('api-key-status');
        
        // NEW: API Key Management Modal DOM elements (F1)
        const apiKeyManagementModal = document.getElementById('api-key-management-modal'); // NEW
        const apiKeyLabelInput = document.getElementById('api-key-label-input'); // NEW
        const apiKeySecretInput = document.getElementById('api-key-secret-input'); // NEW
        const saveKeyBtn = document.getElementById('save-key-btn'); // NEW
        const clearKeyFormBtn = document.getElementById('clear-key-form-btn'); // NEW
        const savedKeysList = document.getElementById('saved-keys-list'); // NEW
        const closeKeyManagementBtn = document.getElementById('close-key-management-btn'); // NEW

        // NEW: Markdown Export DOM elements
        const exportMarkdownBtn = document.getElementById('export-markdown-btn');
        const markdownExportModal = document.getElementById('markdown-export-modal');
        const markdownExportInput = document.getElementById('markdown-export-input');
        const markdownExportPreview = document.getElementById('markdown-export-preview');
        const downloadMarkdownBtn = document.getElementById('download-markdown-btn');
        const closeMarkdownModalBtn = document.getElementById('close-markdown-modal-btn');
        const markdownTabEdit = document.getElementById('markdown-tab-edit');
        const markdownTabPreview = document.getElementById('markdown-tab-preview');
        const copyMarkdownBtn = document.getElementById('copy-markdown-btn'); 

        // ADDED: Scroll & Search Elements
        const jumpToTopBtn = document.getElementById('jump-to-top-btn');
        const jumpToBottomBtn = document.getElementById('jump-to-bottom-btn');
        
        // ADDED: Chat Search UI
        const findChatBtn = document.getElementById('find-chat-btn');
        const chatSearchInputContainer = document.getElementById('chat-search-input-container');
        const chatSearchInput = document.getElementById('chat-search-input');
        const chatSearchPrevBtn = document.getElementById('chat-search-prev-btn');
        const chatSearchNextBtn = document.getElementById('chat-search-next-btn');
        const chatSearchCloseBtn = document.getElementById('chat-search-close-btn');
        const chatSearchCount = document.getElementById('chat-search-count');
        
        // ADDED: Sidebar Search
        const sidebarChatSearch = document.getElementById('sidebar-chat-search');
        
        // ADDED: Code Jump Buttons (Declared here for JS access)
        const jumpCodePrevBtn = document.getElementById('jump-code-prev-btn');
        const jumpCodeNextBtn = document.getElementById('jump-code-next-btn');

        // NEW: Attachment Editor DOM elements
        const attachmentEditorModal = document.getElementById('attachment-editor-modal');
        const attachmentEditorInput = document.getElementById('attachment-editor-input');
        const attachmentEditorFilenameInput = document.getElementById('attachment-editor-filename-input'); // NEW input
        const saveEditorBtn = document.getElementById('save-editor-btn');
        const cancelEditorBtn = document.getElementById('cancel-editor-btn');

        // NEW: Developer Console DOM elements (Request 3)
        const developerConsoleBtn = document.getElementById('developer-console-btn');
        const developerConsoleModal = document.getElementById('developer-console-modal');
        const developerConsoleContent = document.getElementById('developer-console-content');
        const clearConsoleBtn = document.getElementById('clear-console-btn');
        const closeConsoleModalBtn = document.getElementById('close-console-modal-btn');
        const summarizeContextBtn = document.getElementById('summarize-context-btn');

        let isSigningUp = false;

        const errorContainer = document.createElement('div');
        errorContainer.id = 'error-message';
        errorContainer.classList.add('hidden', 'px-6', 'py-4', 'rounded-xl', 'relative', 'shadow-md', 'my-4', 'fixed', 'top-4', 'left-1/2', '-translate-x-1/2', 'z-50', 'w-11/12', 'max-w-md');
        const errorText = document.createElement('span');
        errorText.id = 'error-text';
        errorText.classList.add('block', 'sm:inline');
        errorContainer.appendChild(errorText);
        document.body.appendChild(errorContainer);

        // NEW: Rename Chat Modal DOM elements
        const renameChatModal = document.getElementById('rename-chat-modal');
        const renameChatInput = document.getElementById('rename-chat-input');
        const autoRenameChatBtn = document.getElementById('auto-rename-chat-btn');
        const saveRenameChatBtn = document.getElementById('save-rename-chat-btn');
        const cancelRenameChatBtn = document.getElementById('cancel-rename-chat-btn');
        const renameChatIdPlaceholder = document.getElementById('rename-chat-id-placeholder');

        let renamingSessionId = null; // New state variable to hold the ID of the chat being renamed

        // --- Global State and Constants ---
        
        const DEFAULT_THEME_NAME = 'default';
        const DEFAULT_MODE = 'dark';
        const CONVERSATION_VOICE_KEY = 'conversationVoice'; 
        const CONVERSATION_PERSONALITY_KEY = 'conversationPersonality'; 
        const CUSTOM_PROMPT_TEXT_KEY = 'customPromptText';
        const CUSTOM_PROMPT_ACTIVE_KEY = 'isCustomPromptActive';
        const PROMPT_TEMPLATES_KEY = 'templates'; 
        const API_KEY_KEY = 'apiKey';
        const API_KEYS_LIST_KEY = 'apiKeysList'; // NEW F1
        const MODEL_KEY = 'model';
        
        // NEW CONSTANT: Threshold for bulk text conversion (e.g., 500 characters)
        const BULK_TEXT_THRESHOLD = 500; 


        // NEW: Model Definitions
        const availableModels = [
            // --- Latest Aliases (Recommended for stability) ---
            "gemini-2.5-flash-latest",
            "gemini-2.5-pro-latest",
            "gemini-pro-latest",
            "gemini-flash-latest",

            // --- Gemini 3 (Previews) ---
            "gemini-3-pro-preview",
            "gemini-3-pro-image-preview",
            "gemini-3-flash-preview",

            // --- Gemini 2.5 (All versions/flavors) ---
            "gemini-2.5-flash",
            "gemini-2.5-flash-preview-09-2025",
            "gemini-2.5-flash-image",
            "gemini-2.5-flash-image-preview",
            "gemini-2.5-flash-native-audio-preview-12-2025",
            "gemini-2.5-flash-native-audio-preview-09-2025",
            "gemini-2.5-flash-preview-tts",
            "gemini-2.5-flash-lite",
            "gemini-2.5-flash-lite-preview-09-2025",
            "gemini-2.5-pro",
            "gemini-2.5-pro-preview-tts",

            // --- Gemini 2.0 (All versions/flavors) ---
            "gemini-2.0-flash",
            "gemini-2.0-flash-001",
            "gemini-2.0-flash-exp",
            "gemini-2.0-flash-preview-image-generation",
            "gemini-2.0-flash-lite",
            "gemini-2.0-flash-lite-001",
            "gemini-2.0-pro"
        ];
        const DEFAULT_MODEL = "gemini-2.5-flash-preview-09-2025";
        let selectedModel = DEFAULT_MODEL;

        // Available theme names (both dark and light variants)  used for inline slash suggestions
        const AVAILABLE_THEMES = [
            'default-light','default-dark',
            'celestial-horizon-dark','celestial-horizon-light',
            'verdant-calm-dark','verdant-calm-light',
            'cybernetic-pulse-dark','cybernetic-pulse-light',
            'urban-pulse-dark','urban-pulse-light',
            'rustic-ember-dark','rustic-ember-light',
            'neon-mirage-dark','neon-mirage-light',
            'ivory-bloom-dark','ivory-bloom-light',
            'obsidian-night-dark','obsidian-night-light',
            'solar-dawn-dark','solar-dawn-light',
            'aurora-drift-dark','aurora-drift-light',
            'timeless-echo-dark','timeless-echo-light',
            'mystic-void-dark','mystic-void-light',
            'darkest-bw-dark','darkest-bw-light',
            'coder-dark','coder-light',
            'cyberpunk-dark','cyberpunk-light',
            'matrix-dark','matrix-light',
            'solarized-light','solarized-dark',
            'dracula-dark','dracula-light',
            'monokai-dark','monokai-light',
            'nord-dark','nord-light',
            'gruvbox-dark','gruvbox-light',
            'catppuccin-dark','catppuccin-light',
            'cosmic-nexus-dark','cosmic-nexus-light',
            'starship-minimal-dark','starship-minimal-light',
            'offbeat-cosmic-dark','offbeat-cosmic-light'
        ];

        // Inject the actual model/theme lists into the COMMANDS metadata so inline suggestions stay in sync
        (function syncCommandOptions() {
            try {
                const themeCmd = COMMANDS.find(c => c.cmd === 'theme');
                if (themeCmd) themeCmd.options = AVAILABLE_THEMES;
                const modelCmd = COMMANDS.find(c => c.cmd === 'model');
                if (modelCmd) modelCmd.options = availableModels;
            } catch (err) {
                console.error('Failed to sync command options', err);
            }
        })();

        let allChatSessions = {}; 
        let currentSessionId = null;
        let chatAttachments = []; 

        let currentThemeName = DEFAULT_THEME_NAME;
        let currentMode = DEFAULT_MODE;

        let currentUtterance = null;
        let isSpeaking = false; 
        let messageTextCache = new Map(); 

        let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let isVoiceInputActive = false; 
        let finalTranscript = ''; 

        let isConversationModeActive = false;
        let isAiSpeakingInConversation = false;
        let isUserListeningInConversation = false;
        let conversationSpeechRecognition = null; 
        let conversationFinalTranscript = '';
        let conversationInterimTranscript = '';
        let availableVoices = [];
        let selectedVoice = null;
        let selectedPersonality = 'Standard'; 

        let customPromptText = '';
        let isCustomPromptActive = false;
        
        // F1: State for Multiple API Keys
        let apiKeysList = []; // Array of {id, key, label, isActive}
        let editingKeyId = null; // ID of the key currently being edited

        // F2: Custom Prompt Indicator DOM
        const customPromptIndicator = document.getElementById('custom-prompt-indicator'); 

        // NEW: Chat Search State
        let searchMatches = []; 
        let currentMatchIndex = -1;
        let originalChatContent = new Map(); // Store original content before highlighting

        // ADDED: Code Jump State
        let codeBlocks = [];
        let currentCodeBlockIndex = -1;

        let promptTemplates = []; 
        let editingTemplateId = null; 

        let conversationDisplayTimeout = null; // Timeout for clearing conversation display

        // NEW: Global state for attachment editor
        let editingAttachmentIndex = -1;

        const personalities = [
            { name: "Standard", prompt: "" },
            { name: "Sarcastic", prompt: "Respond as a highly sarcastic and witty AI. Use dry humor and playful cynicism. Keep responses concise and witty." },
            { name: "Friendly", prompt: "Respond as an exceptionally friendly and helpful AI. Use warm and encouraging language, and show genuine interest. Keep your tone light and approachable." },
            { name: "Philosophical", prompt: "Respond as a deep-thinking, philosophical AI. Explore underlying meanings and broader implications, using reflective and insightful language." },
            { name: "Curious", prompt: "Respond as an endlessly curious AI, often asking thoughtful follow-up questions to understand better. Show an eagerness to learn." },
            { name: "Humorous", prompt: "Respond as a lighthearted and funny AI, often making clever jokes or witty observations. Keep the mood cheerful." },
            { name: "Formal", prompt: "Respond in a very formal and precise manner. Avoid slang or casual expressions, maintaining a sophisticated and respectful tone." },
            { name: "Casual", prompt: "Respond in a relaxed, informal, and conversational tone, like talking to a friend. Use common idioms and a laid-back style." },
            { name: "Optimistic", prompt: "Respond with an overwhelmingly positive and hopeful outlook. Emphasize solutions and bright possibilities." },
            { name: "Skeptical", prompt: "Respond with a cautious and questioning attitude, often looking for evidence or flaws in arguments. Be analytical and critical." },
            { name: "Teacher", prompt: "Respond as a patient and knowledgeable teacher, explaining concepts clearly and simply, and guiding the user to understanding." },
            { name: "Poetic", prompt: "Respond using evocative language, metaphors, and a touch of poetic flair. Let your words flow with rhythm and imagery." },
            { name: "Concise", prompt: "Respond with extreme brevity and to the point, minimizing unnecessary words. Deliver information efficiently." },
            { name: "Verbose", prompt: "Respond with detailed and elaborate explanations, exploring every facet of the topic. Provide rich descriptions and context." },
            { name: "Narrator", prompt: "Respond as if you are narrating a story or documentary, setting a scene or describing events with a captivating voice." },
            { name: "Enthusiastic", prompt: "Respond with high energy and excitement, showing great interest in the conversation. Use exclamation marks and vivid language." },
            { name: "Mysterious", prompt: "Respond with an air of mystery, hinting at deeper knowledge without revealing everything. Be intriguing and slightly enigmatic." },
            { name: "Empathetic", prompt: "Respond with strong understanding and sharing of feelings, focusing on emotional support and validation. Show genuine care." },
            { name: "Analyst", prompt: "Respond like a data analyst, breaking down information, identifying patterns, and drawing logical conclusions based on facts." },
            { name: "Mentor", prompt: "Respond as a seasoned mentor, offering guidance, advice, and a wise perspective to help the user grow." },
            { name: "Dreamer", prompt: "Respond with imaginative and abstract ideas, often exploring fantastical possibilities and creative concepts. Think outside the box." },
            { name: "Strategist", prompt: "Respond by focusing on goals, plans, and optimal ways to achieve objectives. Offer clear, actionable strategies." },
            { name: "Minimalist", prompt: "Respond with the absolute bare minimum of words, almost like a haiku or a very short, impactful statement. Less is more." },
            { name: "Futurist", prompt: "Respond with a focus on future trends, predictions, and the long-term impact of technology and societal changes." },
            { name: "Zen Master", prompt: "Respond calmly, contemplatively, and with a focus on inner peace, mindfulness, and the present moment. Offer tranquil wisdom." }
        ];

        // --- FIREBASE HELPER FUNCTIONS ---

        async function saveUserSetting(key, value) {
            if (!currentUser) return;
            try {
                const settingsRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc('config');
                await settingsRef.set({ [key]: value }, { merge: true });
            } catch (error) {
                console.error(`Error saving setting ${key} to Firebase:`, error);
                showError(`Failed to save settings: ${key}. (Check Firebase Rules)`);
            }
        }
        
        async function loadUserSettings() {
            if (!currentUser) return {};
            try {
                const settingsRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc('config');
                const doc = await settingsRef.get();
                const settings = doc.exists ? doc.data() : {};
                    
                // 1. Theme and Mode
                const dbThemeName = settings.themeName || DEFAULT_THEME_NAME;
                const dbThemeMode = settings.themeMode || DEFAULT_MODE;
                applyTheme(dbThemeName, dbThemeMode); 
                    
                // 2. Model
                selectedModel = settings[MODEL_KEY] || DEFAULT_MODEL;
                updateModelDropdown(); 
                    
                // 3. API Keys (F1)
                apiKeysList = settings[API_KEYS_LIST_KEY] || [];
                // Re-derive userApiKey (the active key string) from the list
                const activeKey = apiKeysList.find(k => k.isActive);
                userApiKey = activeKey ? activeKey.key : null;
                updateApiKeySelectorAndStatus();

                // 4. Conversation Settings
                selectedVoice = settings[CONVERSATION_VOICE_KEY] || null;
                selectedPersonality = settings[CONVERSATION_PERSONALITY_KEY] || 'Standard';
                if (voiceSelect) voiceSelect.value = selectedVoice || '';
                if (personalitySelect) personalitySelect.value = selectedPersonality;
                    
                // 5. Custom Prompt
                customPromptText = settings[CUSTOM_PROMPT_TEXT_KEY] || '';
                isCustomPromptActive = settings[CUSTOM_PROMPT_ACTIVE_KEY] === true;
                updateCustomPromptButtonState();
                    
                // 6. Templates
                await loadPromptTemplatesFromDB();
                renderPromptTemplates();
                    
                // If no settings existed, save defaults for next time
                if (!doc.exists) {
                    await saveUserSetting('themeName', currentThemeName);
                    await saveUserSetting('themeMode', currentMode);
                    await saveUserSetting(MODEL_KEY, selectedModel);
                    await saveUserSetting(CONVERSATION_PERSONALITY_KEY, selectedPersonality);
                    await saveUserSetting(CUSTOM_PROMPT_ACTIVE_KEY, isCustomPromptActive);
                }
                return settings;
            } catch (error) {
                console.error("Error loading user settings:", error);
                showError("Failed to load user settings from database. (Check Firebase Rules)");
                return {};
            }
        }
        
        async function loadAllChatsFromDB() {
            if (!currentUser) return;
            try {
                const chatsRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_CHATS_COLLECTION);
                const snapshot = await chatsRef.orderBy('timestamp', 'desc').get();
                
                allChatSessions = {};
                snapshot.forEach(doc => {
                    allChatSessions[doc.id] = { id: doc.id, ...doc.data() };
                });
                
                renderSidebarChats();
                // NOTE: We no longer automatically load the last chat here. The caller (initializeAuthenticatedApp) will handle creating a NEW chat.

            } catch (error) {
                console.error("Error loading chats from DB:", error);
                showError("Failed to load chat history. (Check Firebase Rules)");
            }
        }
        
        async function saveChatToDB(session) {
            if (!currentUser) {
                console.warn("Cannot save chat: User not logged in.");
                return;
            }
            if (!session.id) {
                session.id = generateUniqueId();
            }
            session.timestamp = Date.now();
            
            try {
                const chatRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_CHATS_COLLECTION).doc(session.id);
                await chatRef.set(session);
                allChatSessions[session.id] = session; 
            } catch (error) {
                console.error(`Error saving chat ${session.id}:`, error);
                showError("Failed to save chat to database. (Check Firebase Rules)");
            }
        }
        
        async function deleteChatFromDB(sessionId) {
            if (!currentUser) return;
            try {
                const chatRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_CHATS_COLLECTION).doc(sessionId);
                await chatRef.delete();
            } catch (error) {
                console.error(`Error deleting chat ${sessionId}:`, error);
                showError("Failed to delete chat from database. (Check Firebase Rules)");
            }
        }

        async function loadPromptTemplatesFromDB() {
            if (!currentUser) return;
            try {
                const templatesRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc(FIRESTORE_TEMPLATES_DOC);
                const doc = await templatesRef.get();
                if (doc.exists && doc.data()[PROMPT_TEMPLATES_KEY]) {
                    promptTemplates = doc.data()[PROMPT_TEMPLATES_KEY];
                } else {
                    promptTemplates = [];
                }
            } catch (error) {
                console.error("Error loading templates:", error);
                showError("Failed to load prompt templates. (Check Firebase Rules)");
            }
        }
        
        async function savePromptTemplatesToDB() {
            if (!currentUser) return;
            try {
                const templatesRef = db.collection(FIRESTORE_USERS_COLLECTION).doc(currentUser.uid).collection(FIRESTORE_SETTINGS_DOC).doc(FIRESTORE_TEMPLATES_DOC);
                await templatesRef.set({ [PROMPT_TEMPLATES_KEY]: promptTemplates });
            } catch (error) {
                console.error("Error saving templates:", error);
                showError("Failed to save prompt templates. (Check Firebase Rules)");
            }
        }

        // --- Authentication Logic ---

        function handleAuthToggle(e) {
            e.preventDefault();
            isSigningUp = !isSigningUp;
            if (isSigningUp) {
                authTitle.textContent = "Create Account";
                authActionBtn.textContent = "Sign Up";
                document.getElementById('auth-toggle-text').innerHTML = `Already have an account? <a href="#" id="auth-toggle-link" class="font-medium" style="color: var(--accent-primary-hover);">Sign In</a>`;
            } else {
                authTitle.textContent = "Sign In to Small AI v2";
                authActionBtn.textContent = "Sign In";
                document.getElementById('auth-toggle-text').innerHTML = `Need an account? <a href="#" id="auth-toggle-link" class="font-medium" style="color: var(--accent-primary-hover);">Sign Up</a>`;
            }
            authError.classList.add('hidden');
            document.getElementById('auth-toggle-link').addEventListener('click', handleAuthToggle);
            createIcons();
        }

        async function handleAuthAction() {
            const email = authEmail.value;
            const password = authPassword.value;
            authError.classList.add('hidden');

            if (!email || !password) {
                authError.textContent = "Please enter both email and password.";
                authError.classList.remove('hidden');
                return;
            }

            try {
                if (isSigningUp) {
                    await auth.createUserWithEmailAndPassword(email, password);
                } else {
                    await auth.signInWithEmailAndPassword(email, password);
                }
            } catch (error) {
                console.error("Auth Error:", error);
                let message = "An authentication error occurred.";
                if (error.code) {
                    message = error.code.replace('auth/', '').replace(/-/g, ' ');
                }
                authError.textContent = message;
                authError.classList.remove('hidden');
            }
        }

        async function handleGoogleSignIn() {
            authError.classList.add('hidden');
            try {
                await auth.signInWithPopup(GoogleProvider);
            } catch (error) {
                console.error("Google Auth Error:", error);
                authError.textContent = "Google Sign-In failed.";
                authError.classList.remove('hidden');
            }
        }
        
        async function handleSignOut() {
            if (confirm('Are you sure you want to sign out?')) {
                // Stop any ongoing speech/recognition before signing out
                if (isSpeaking) { window.speechSynthesis.cancel(); }
                if (isVoiceInputActive && recognition) { recognition.stop(); }
                if (isConversationModeActive) { stopConversationMode(); }

                try {
                    await auth.signOut();
                    showCopyMessage('Successfully signed out.', 'var(--accent-primary)');
                } catch (error) {
                    showError('Error signing out.');
                    console.error("Sign Out Error:", error);
                }
            }
        }

        function handleAuthStateChange(user) {
            currentUser = user;
            if (user) {
                userEmailSpan.textContent = user.email || "User";
                authModal.classList.add('hidden');
                document.body.style.overflow = '';
                
                // If not already set up, load user data
                if (!isAuthSetupComplete) {
                    initializeAuthenticatedApp();
                }
            } else {
                userEmailSpan.textContent = "Guest (Requires Sign In)";
                authModal.classList.remove('hidden');
                document.body.style.overflow = 'hidden';
                isAuthSetupComplete = false; 
                
                // Clear UI state when logged out
                allChatSessions = {};
                currentSessionId = null;
                chatHistoryDiv.innerHTML = '<p class="text-center text-sm p-4" style="color: var(--text-secondary);">Please sign in to load or save your chat history.</p>';
                sidebarChatList.innerHTML = '<li><p class="text-center text-sm p-4" style="color: var(--text-secondary);">Please sign in to view chats.</p></li>';
                geminiApiKeyInput.value = '';
                userApiKey = null;
                updateApiKeyStatus();
                setChatUIEnabled(false); 
            }
        }
        
        // --- API Key Management (F1) ---
        
        /**
         * Updates the global userApiKey, selector UI, and status message.
         */
        function updateApiKeySelectorAndStatus() {
            // 1. Find the active key
            const activeKey = apiKeysList.find(k => k.isActive);
            userApiKey = activeKey ? activeKey.key : null;

            // 2. Update status text
            if (userApiKey) {
                apiKeyStatus.textContent = `Active Key: ${activeKey.label} (${userApiKey.substring(0, 4)}...${userApiKey.substring(userApiKey.length - 4)})`;
                apiKeyStatus.style.color = 'var(--accent-success)';
            } else {
                apiKeyStatus.textContent = 'No key selected or saved. Using fallback.';
                apiKeyStatus.style.color = 'var(--accent-error)';
            }

            // 3. Update Selector options
            apiKeySelect.innerHTML = '';
            if (!userApiKey) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '--- Select API Key ---';
                apiKeySelect.appendChild(option);
            }

            apiKeysList.forEach(keyObj => {
                const option = document.createElement('option');
                option.value = keyObj.id;
                option.textContent = keyObj.label;
                if (keyObj.isActive) {
                    option.selected = true;
                }
                apiKeySelect.appendChild(option);
            });
            
            // If there's an active key but no matching option selected (shouldn't happen), try to select it.
            if (activeKey && apiKeySelect.value !== activeKey.id) {
                apiKeySelect.value = activeKey.id;
            }
        }

        async function saveApiKeysList() {
            if (!currentUser) return;
            await saveUserSetting(API_KEYS_LIST_KEY, apiKeysList);
            updateApiKeySelectorAndStatus();
        }
        
        // Listener for the Selector change
        apiKeySelect.addEventListener('change', (e) => {
            const selectedId = e.target.value;
            if (!selectedId) return; // Should only happen if '--- Select ---' is available

            apiKeysList = apiKeysList.map(keyObj => ({
                ...keyObj,
                isActive: keyObj.id === selectedId
            }));
            saveApiKeysList();
            showCopyMessage('Active API key switched.', 'var(--accent-primary)');
        });

        // --- API Key Management Modal Logic ---

        manageApiKeysBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to manage API keys.");
                return;
            }
            renderSavedKeysList();
            clearKeyForm();
            apiKeyManagementModal.classList.remove('hidden');
        });

        closeKeyManagementBtn.addEventListener('click', () => {
            apiKeyManagementModal.classList.add('hidden');
        });

        function clearKeyForm() {
            apiKeyLabelInput.value = '';
            apiKeySecretInput.value = '';
            editingKeyId = null;
            saveKeyBtn.innerHTML = `<span data-lucide="plus" class="w-5 h-5 mr-2"></span> Add Key`;
            createIcons();
            apiKeyLabelInput.focus();
            apiKeySecretInput.type = 'password';
        }
        clearKeyFormBtn.addEventListener('click', clearKeyForm);

        function renderSavedKeysList() {
            savedKeysList.innerHTML = '';
            if (apiKeysList.length === 0) {
                savedKeysList.innerHTML = '<li><p class="text-center text-sm p-4" style="color: var(--text-secondary);">No keys saved yet.</p></li>';
                return;
            }

            apiKeysList.forEach(keyObj => {
                const li = document.createElement('li');
                li.classList.add('template-item'); // Reusing template-item styles
                li.dataset.keyId = keyObj.id;
                
                const keyDisplay = keyObj.key.length > 8 
                                 ? `${keyObj.key.substring(0, 4)}...${keyObj.key.substring(keyObj.key.length - 4)}` 
                                 : keyObj.key;
                                 
                const activeIndicator = keyObj.isActive 
                                       ? '<span data-lucide="check" class="w-4 h-4 ml-2 text-green-500"></span>' 
                                       : '';

                li.innerHTML = `
                    <div class="template-item-header">
                        <span class="template-item-name">${keyObj.label} ${activeIndicator}</span>
                        <span class="text-xs" style="color: var(--text-secondary);">${keyDisplay}</span>
                    </div>
                    <div class="template-item-actions mt-2">
                        <button class="use-key-btn" title="Set as Active Key" style="background-color: ${keyObj.isActive ? 'var(--accent-secondary)' : 'var(--bg-primary)'}; color: ${keyObj.isActive ? 'black' : 'var(--text-primary)'}; border: ${keyObj.isActive ? 'none' : '1px solid var(--border-color)'}">
                            <span data-lucide="zap" class="w-4 h-4"></span> Activate
                        </button>
                        <button class="edit-key-btn" title="Edit Key" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">
                            <span data-lucide="edit" class="w-4 h-4"></span> Edit
                        </button>
                        <button class="delete-key-btn" title="Delete Key" style="background-color: var(--accent-error); color: white;">
                            <span data-lucide="trash-2" class="w-4 h-4"></span> Delete
                        </button>
                    </div>
                `;
                savedKeysList.appendChild(li);
            });
            createIcons();
        }

        saveKeyBtn.addEventListener('click', () => {
            const label = apiKeyLabelInput.value.trim() || 'Untitled Key';
            const key = apiKeySecretInput.value.trim();

            if (!key || key.length < 10) {
                showError('Please enter a valid API Key.');
                return;
            }

            if (editingKeyId) {
                // Update existing key
                apiKeysList = apiKeysList.map(k => k.id === editingKeyId ? { ...k, label, key } : k);
                showCopyMessage(`Key "${label}" updated.`, 'var(--accent-primary)');
            } else {
                // Add new key
                // If this is the first key added, make it active by default
                const newId = generateUniqueId();
                const isActive = apiKeysList.length === 0; 
                apiKeysList.push({ id: newId, label, key, isActive });
                if (isActive) {
                    showCopyMessage(`First key saved and activated.`, 'var(--accent-primary)');
                } else {
                    showCopyMessage(`Key "${label}" added.`, 'var(--accent-primary)');
                }
            }
            saveApiKeysList();
            renderSavedKeysList();
            clearKeyForm();
        });

        // Event delegation for key list actions
        savedKeysList.addEventListener('click', (event) => {
            const target = event.target;
            const listItem = target.closest('.template-item');
            if (!listItem) return;
            const keyId = listItem.dataset.keyId;
            const keyObj = apiKeysList.find(k => k.id === keyId);
            if (!keyObj) return;

            if (target.closest('.use-key-btn')) {
                // Activate Key
                if (keyObj.isActive) return;
                apiKeysList = apiKeysList.map(k => ({ ...k, isActive: k.id === keyId }));
                saveApiKeysList();
                renderSavedKeysList();
                showCopyMessage(`Key "${keyObj.label}" activated.`, 'var(--accent-primary)');

            } else if (target.closest('.edit-key-btn')) {
                // Edit Key
                apiKeyLabelInput.value = keyObj.label;
                apiKeySecretInput.value = keyObj.key; // Load the full key for editing
                apiKeySecretInput.type = 'text'; // Temporarily show the key for easier copy/edit
                editingKeyId = keyObj.id;
                saveKeyBtn.innerHTML = `<span data-lucide="save" class="w-5 h-5 mr-2"></span> Update Key`;
                createIcons();
                apiKeyLabelInput.focus();
                apiKeyManagementModal.querySelector('div:first-child').scrollTop = 0; 

            } else if (target.closest('.delete-key-btn')) {
                // Delete Key
                if (confirm(`Are you sure you want to delete the API Key "${keyObj.label}"?`)) {
                    apiKeysList = apiKeysList.filter(k => k.id !== keyId);
                    
                    // If the active key was deleted, try to activate the first remaining key
                    if (keyObj.isActive && apiKeysList.length > 0) {
                        apiKeysList[0].isActive = true; 
                    } else if (keyObj.isActive && apiKeysList.length === 0) {
                        userApiKey = null; // No keys left, rely on fallback
                    }
                    
                    saveApiKeysList();
                    renderSavedKeysList();
                    showCopyMessage(`Key "${keyObj.label}" deleted.`, 'var(--accent-error)');
                    clearKeyForm();
                }
            }
        });

        // Initialize SpeechRecognition for general chat if available
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isVoiceInputActive = true;
                voiceInputBtn.classList.add('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic-off', 'w-5 h-5');
                chatInput.placeholder = 'Listening... Speak now.';
                finalTranscript = '';
                chatInput.dataset.initialText = chatInput.value;
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript + ' ';
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                chatInput.value = (chatInput.dataset.initialText || '') + finalTranscript + interimTranscript;
                adjustChatInputHeight();
                chatInput.scrollLeft = chatInput.scrollWidth;
            };

            recognition.onend = () => {
                isVoiceInputActive = false;
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                chatInput.placeholder = 'Type your message or ask a question...';
                
                if (finalTranscript.trim() !== '') {
                    chatInput.value = (chatInput.dataset.initialText || '') + finalTranscript.trim();
                    chatInput.dataset.initialText = chatInput.value;
                } else if (chatInput.value.trim() === (chatInput.dataset.initialText || '').trim()) {
                    // No new speech added, keep existing text.
                } else {
                    chatInput.value = chatInput.dataset.initialText || '';
                }
                adjustChatInputHeight();
            };

            recognition.onerror = (event) => {
                isVoiceInputActive = false;
                voiceInputBtn.classList.remove('voice-input-active');
                updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                chatInput.placeholder = 'Type your message or ask a question...';
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone access denied. Please allow microphone access in your browser settings.');
                } else if (event.error === 'no-speech') {
                    console.log('No speech detected, recognition ended.');
                    chatInput.value = chatInput.dataset.initialText || '';
                } else if (event.error === 'network') {
                    showError('Speech recognition network error. This often means a firewall, proxy, or browser extension is blocking access to Google\'s speech services. Please try disabling extensions or testing in incognito mode.');
                } else {
                    showError(`Speech recognition error: ${event.error}`);
                }
                adjustChatInputHeight();
            };
        } else {
            console.warn('Web Speech API (SpeechRecognition) not supported in this browser. General Voice input button will be hidden.');
            if (voiceInputBtn) {
                voiceInputBtn.style.display = 'none';
            }
        }

        // NEW: Initialize SpeechRecognition for Conversation Mode
        if (SpeechRecognition) {
            conversationSpeechRecognition = new SpeechRecognition();
            conversationSpeechRecognition.continuous = false; 
            conversationSpeechRecognition.interimResults = true;
            conversationSpeechRecognition.lang = 'en-US';

            conversationSpeechRecognition.onstart = () => {
                isUserListeningInConversation = true;
                updateButtonIcon(conversationMicBtn, 'mic-off', 'w-8 h-8');
                conversationMicBtn.classList.add('voice-input-active');
                updateConversationStatus('Listening...', 'listening');
                setSoundBlobState('listening');
                conversationFinalTranscript = '';
                conversationInterimTranscript = '';
                clearConversationDisplay();
            };

            conversationSpeechRecognition.onresult = (event) => {
                let interim = '';
                let final = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        final += event.results[i][0].transcript + ' ';
                    } else {
                        interim += event.results[i][0].transcript;
                    }
                }
                conversationFinalTranscript = final;
                conversationInterimTranscript = interim;
                updateConversationDisplay(`<span class="user-utterance">You: ${conversationFinalTranscript}${conversationInterimTranscript}</span>`);
            };

            conversationSpeechRecognition.onend = () => {
                isUserListeningInConversation = false;
                updateButtonIcon(conversationMicBtn, 'mic', 'w-8 h-8');
                conversationMicBtn.classList.remove('voice-input-active');
                
                if (conversationFinalTranscript.trim() !== '') {
                    handleUserSpeechEnd(conversationFinalTranscript.trim());
                } else {
                    updateConversationStatus('No speech detected. Say something!');
                    setSoundBlobState('idle');
                }
            };

            conversationSpeechRecognition.onerror = (event) => {
                isUserListeningInConversation = false;
                updateButtonIcon(conversationMicBtn, 'mic', 'w-8 h-8');
                conversationMicBtn.classList.remove('voice-input-active');
                console.error('Conversation mode Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError('Microphone access denied. Please allow microphone access in your browser settings to use Conversation Mode.');
                    updateConversationStatus('Microphone access denied.', 'error');
                } else if (event.error === 'no-speech') {
                    updateConversationStatus('No speech detected. Say something!');
                } else {
                    showError(`Conversation mode speech recognition error: ${event.error}`);
                    updateConversationStatus(`Error: ${event.error}`, 'error');
                }
                setSoundBlobState('idle');
            };
        } else {
            console.warn('Web Speech API (SpeechRecognition) not supported. Conversation Mode will be limited.');
            if (conversationModeToggleBtn) {
                conversationModeToggleBtn.style.display = 'none';
            }
        }

        // --- Theme Management (MODIFIED for Firebase) ---
        function applyTheme(themeName, mode) {
            currentThemeName = themeName;
            currentMode = mode;
            document.body.dataset.theme = `${themeName}-${mode}`;
            
            darkModeToggle.checked = (mode === 'dark'); 
            if (appThemeSelect && appThemeSelect.value !== themeName) {
                appThemeSelect.value = themeName; 
            }
        }

        applyTheme(currentThemeName, currentMode);

        // Event listener for Dark/Light Mode Toggle
        darkModeToggle.addEventListener('change', () => {
            const newMode = darkModeToggle.checked ? 'dark' : 'light';
            applyTheme(currentThemeName, newMode);
            if (currentUser) {
                saveUserSetting('themeMode', newMode);
            }
        });

        // Event listener for Theme Selector
        if (appThemeSelect) {
            appThemeSelect.addEventListener('change', (event) => {
                const newThemeName = event.target.value;
                applyTheme(newThemeName, currentMode);
                if (currentUser) {
                    saveUserSetting('themeName', newThemeName);
                }
            });
        }
        
        // --- Model Management (MODIFIED for Firebase) ---
        function updateModelDropdown() {
            modelSelectSidebar.innerHTML = '';
            
            availableModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                let displayName = model;
                if (model === DEFAULT_MODEL) {
                    displayName += ' (Default)';
                } else if (model === selectedModel) {
                    displayName += ' (Current)';
                }
                option.textContent = displayName;
                
                if (model === selectedModel) {
                    option.selected = true;
                }
                modelSelectSidebar.appendChild(option);
            });
        }

        if (modelSelectSidebar) {
            modelSelectSidebar.addEventListener('change', (event) => {
                selectedModel = event.target.value;
                if (currentUser) {
                    saveUserSetting(MODEL_KEY, selectedModel);
                }
                updateModelDropdown(); 
                showCopyMessage(`AI Model changed to ${selectedModel}`, 'var(--accent-primary)');
            });
        }
        
        // Version Selector Listener
        versionSelectSidebar.addEventListener('change', (event) => {
            const selectedUrl = event.target.value;
            if (selectedUrl && selectedUrl !== window.location.href) {
                window.location.href = selectedUrl;
            }
        });

        // --- Chat History & Session Management (MODIFIED for Firebase) ---

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
        }

        // --- Core UI Rendering Helpers ---
        
        // Helper function to render the stylized welcome screen
        function renderWelcomeScreen(initialMessage) {
            chatHistoryDiv.innerHTML = `
                <div id="initial-welcome-screen" class="flex-1 flex flex-col items-center justify-center text-center p-8 max-w-xl mx-auto" style="color: var(--text-secondary);">
                    <span data-lucide="sparkles" class="w-12 h-12 mb-4" style="color: var(--accent-primary);"></span>
                    <h2 class="text-3xl font-bold mb-4" style="color: var(--text-primary);">Small AI v2</h2>
                    <p class="text-lg mb-6">${initialMessage}</p>
                    <p class="text-sm italic">You can attach files (paperclip), use voice input, or press Ctrl/Cmd+F to search the chat history.</p>
                </div>
            `;
            createIcons(); 
        }

        function renderSidebarChats(query = '') {
            sidebarChatList.innerHTML = '';
            const sortedSessions = Object.values(allChatSessions).sort((a, b) => b.timestamp - a.timestamp);
            
            const filterQuery = query.toLowerCase().trim();
            const filteredSessions = sortedSessions.filter(session => 
                filterQuery === '' || session.title.toLowerCase().includes(filterQuery)
            );

            if (filteredSessions.length === 0) {
                const emptyMsg = document.createElement('li');
                emptyMsg.classList.add('text-center', 'text-sm', 'p-4');
                emptyMsg.style.color = 'var(--text-secondary)';
                emptyMsg.textContent = filterQuery ? 'No matching chats found.' : 'No chats found.';
                sidebarChatList.appendChild(emptyMsg);
                return;
            }

            filteredSessions.forEach(session => {
                const li = document.createElement('li');
                li.classList.add('sidebar-chat-item');
                if (session.id === currentSessionId) {
                    li.classList.add('active');
                }
                li.dataset.sessionId = session.id;

                // Extract last message text (or attachment marker) (P5)
                const lastMessage = session.history.length > 0 ? session.history[session.history.length - 1] : null;
                let lastMessageText = 'Start conversation...';
                if (lastMessage) {
                    const textPart = lastMessage.parts.find(p => p.text);
                    if (textPart) {
                         lastMessageText = textPart.text.substring(0, 40) + (textPart.text.length > 40 ? '...' : '');
                    } else if (lastMessage.parts.some(p => p.inlineData)) {
                         lastMessageText = '[Attachment/Media]';
                    }
                    if (lastMessage.role === 'user') {
                        lastMessageText = `You: ${lastMessageText}`;
                    }
                }
                // Format timestamp
                const lastActivity = session.timestamp ? new Date(session.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                
                li.innerHTML = `
                    <div class="sidebar-chat-item-content flex-col items-start gap-1">
                        <div class="flex items-center justify-between w-full">
                            <span data-lucide="message-square" class="w-5 h-5 flex-shrink-0 mr-2" style="color: inherit;"></span>
                            <span class="sidebar-chat-item-title text-base font-semibold truncate flex-1" title="${session.title}">${session.title}</span>
                            <span class="text-xs ml-auto flex-shrink-0" style="color: var(--text-tertiary);">${lastActivity}</span>
                        </div>
                        <p class="text-xs truncate w-full pl-7" style="color: var(--text-secondary);">${lastMessageText}</p>
                    </div>
                    <div class="sidebar-chat-item-actions">
                        <!-- ADDED: Rename Button -->
                        <button class="rename-chat-btn" title="Rename chat">
                            <span data-lucide="pencil"></span>
                        </button>
                        <button class="delete-chat-btn" title="Delete chat">
                            <span data-lucide="trash-2"></span>
                        </button>
                    </div>
                `;
                sidebarChatList.appendChild(li);
            });
            createIcons(); 
        }

        async function createNewChatSession(initialTitle = 'New Chat') {
            if (!currentUser) {
                showError("Please sign in to start a new chat.");
                return;
            }

            const initialMessage = 'Welcome to Small AI v2, your powerful multimodal AI assistant powered by Gemini. I specialize in detailed data analysis, coding, creative tasks, and project planning. I can analyze images, PDFs, code, and documents uploaded via the paperclip icon. Whether you need strategic analysis for specific domains or technical assistance, I\'m ready. How can I help you tackle a complex problem or analyze a file today?';
            
            // Set the base title to ensure consistency for the auto-title check later.
            const titleForNewSession = (initialTitle === 'Welcome Chat' || initialTitle === 'New Chat') 
                                    ? 'Welcome Chat' : initialTitle; 

            const newId = generateUniqueId();

            const newSession = {
                id: newId,
                title: titleForNewSession,
                history: [{ role: 'model', parts: [{ text: initialMessage }] }],
                timestamp: Date.now()
            };
            
            await saveChatToDB(newSession);
            
            currentSessionId = newId;
            
            chatHistoryDiv.innerHTML = '';
            messageTextCache.clear();
            chatAttachments = [];
            chatFileUpload.value = '';
            displayChatAttachments();
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatInput.focus();

            // Always render the custom welcome screen for a new chat
            renderWelcomeScreen(initialMessage);
            
            renderSidebarChats();
            sidebar.classList.add('hidden-mobile'); 
            sidebarOverlay.classList.remove('active');

            // ADDED: Collect code blocks after creating a new chat
            collectCodeBlocks();
        }

        function loadChatSession(sessionId) {
            if (!currentUser) return;

            if (currentSessionId === sessionId) return; 
            
            const session = allChatSessions[sessionId];
            if (!session) {
                console.error('Session not found:', sessionId);
                showError('Requested chat session not found.');
                return;
            }

            currentSessionId = sessionId;
            
            chatHistoryDiv.innerHTML = '';
            messageTextCache.clear();
            chatAttachments = []; 
            chatFileUpload.value = '';
            displayChatAttachments();
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatInput.focus();

            // Check if this is the initial welcome chat (only 1 AI message)
            const initialMessageText = 'Welcome to Small AI v2, your powerful multimodal AI assistant powered by Gemini. I specialize in detailed data analysis, coding, creative tasks, and project planning. I can analyze images, PDFs, code, and documents uploaded via the paperclip icon. Whether you need strategic analysis for specific domains or technical assistance, I\'m ready. How can I help you tackle a complex problem or analyze a file today?';
            const isWelcomeChat = session.history.length === 1 && session.history[0].role === 'model' && session.history[0].parts[0].text === initialMessageText;

            if (isWelcomeChat) {
                renderWelcomeScreen(initialMessageText);
            } else {
                // Render full history for active chats
                session.history.forEach(msg => {
                    if (msg.role === 'user') {
                        let userText = '';
                        const displayAttachments = [];
                        msg.parts.forEach(part => {
                            if (part.text) {
                                userText += part.text + ' ';
                            } else if (part.inlineData) {
                                displayAttachments.push({
                                    mimeType: part.inlineData.mimeType,
                                    data: part.inlineData.data,
                                    name: `attachment_${displayAttachments.length + 1}`
                                });
                            }
                        });
                        appendChatMessage('user', userText.trim(), displayAttachments);
                    } else {
                        appendChatMessage('ai', msg.parts[0].text);
                    }
                });
            }
            
            renderSidebarChats();
            sidebar.classList.add('hidden-mobile'); 
            sidebarOverlay.classList.remove('active');
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            // ADDED: Collect code blocks and clear search after loading a chat
            collectCodeBlocks();
            clearChatSearch();
        }

        async function updateCurrentSessionHistory(newTitle = null) {
            if (!currentUser || !currentSessionId || !allChatSessions[currentSessionId]) {
                console.error("No active session to update. This should not happen.");
                return;
            }

            const session = allChatSessions[currentSessionId];
            session.timestamp = Date.now();
            
            if (newTitle) {
                 session.title = newTitle;
            } else if (session.title === 'New Chat' && session.history.length > 1) {
                const firstUserMessage = session.history.find(msg => msg.role === 'user' && msg.parts[0]?.text);
                if (firstUserMessage) {
                    session.title = firstUserMessage.parts[0].text.substring(0, 50) + (firstUserMessage.parts[0].text.length > 50 ? '...' : '');
                }
            }
            
            await saveChatToDB(session);
            renderSidebarChats(); 
        }

        async function deleteChatSession(sessionIdToDelete) {
            if (!currentUser) return;

            if (confirm('Are you sure you want to delete this chat? This action cannot be undone.')) {
                await deleteChatFromDB(sessionIdToDelete);
                delete allChatSessions[sessionIdToDelete];
                
                if (currentSessionId === sessionIdToDelete) {
                    currentSessionId = null; 
                    const sortedSessions = Object.values(allChatSessions).sort((a,b) => b.timestamp - a.timestamp);
                    if (sortedSessions.length > 0) {
                        loadChatSession(sortedSessions[0].id);
                    } else {
                        createNewChatSession(); 
                    }
                } else {
                    renderSidebarChats(); 
                }
                showCopyMessage('Chat deleted successfully!', `var(--accent-error)`); 
            }
        }

        // MODIFIED: Function to open the rename chat modal
        function openRenameChatModal(sessionId) {
            if (!currentUser) return;

            const session = allChatSessions[sessionId];
            if (!session) {
                showError('Session not found for renaming.');
                return;
            }

            renamingSessionId = sessionId;
            renameChatInput.value = session.title;
            renameChatIdPlaceholder.textContent = `Chat ID: ${sessionId.substring(0, 8)}...`;
            renameChatModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            renameChatInput.focus();
        }

        async function saveChatRename() {
            if (!renamingSessionId) return;

            const session = allChatSessions[renamingSessionId];
            const newTitle = renameChatInput.value.trim();

            if (newTitle.length === 0) {
                showError('Chat title cannot be empty.');
                return;
            }
            
            // Only save if the title actually changed
            if (newTitle === session.title) {
                renameChatModal.classList.add('hidden');
                document.body.style.overflow = '';
                renamingSessionId = null;
                return;
            }
            
            const trimmedTitle = newTitle.substring(0, 100);
            
            // Update local state
            session.title = trimmedTitle;
            allChatSessions[renamingSessionId] = session;

            // Update database
            await saveChatToDB(session); 
            
            // Refresh UI
            renderSidebarChats();
            showCopyMessage(`Chat renamed to "${trimmedTitle}"`, `var(--accent-primary)`);
            
            renameChatModal.classList.add('hidden');
            document.body.style.overflow = '';
            renamingSessionId = null;
        }

        // NEW: Function to implement AI Auto Rename logic (repurposing title generation)
        async function handleAutoRename() {
            if (!renamingSessionId) return;
            
            const session = allChatSessions[renamingSessionId];
            if (!session || session.history.length <= 1) {
                showError("Chat must have history to generate an automatic title.");
                return;
            }

            // Temporarily disable buttons and show loading state
            autoRenameChatBtn.disabled = true;
            saveRenameChatBtn.disabled = true;
            const originalContent = autoRenameChatBtn.innerHTML;
            autoRenameChatBtn.innerHTML = `<span data-lucide="loader-2" class="w-5 h-5 mr-2 animate-spin"></span> Generating...`;
            createIcons();

            // Get the history for context (limiting to the first 3 exchanges for max speed/efficiency)
            const historyForTitle = session.history.slice(0, 6).map(msg => {
                const textPart = msg.parts.find(p => p.text);
                return {
                    role: msg.role,
                    // Truncate text aggressively to save tokens and speed
                    parts: [{ text: textPart ? textPart.text.substring(0, 250) : '[Attachment]' }] 
                };
            });
            
            // Highly optimized prompt for minimal AI capability usage (Request 2)
            const systemInstruction = "Analyze the first few turns of the conversation history provided below. Generate a single, concise title for the chat (max 8 words). Respond ONLY with the title text, nothing else. Do not use quotes, periods, or extra formatting.";

            try {
                const payload = {
                    contents: historyForTitle,
                    generationConfig: {
                        temperature: 0.1, // Low temperature forces determinism/speed
                        maxOutputTokens: 20, // Minimal output length
                    }
                };
                
                // Use a fast, low-cost model for title generation
                const title = await callGeminiAPI(payload, null, 'gemini-2.5-flash-lite-preview-09-2025', systemInstruction);
                const cleanTitle = title.replace(/["'\.]/g, '').trim();

                if (cleanTitle && cleanTitle.length > 0) {
                    renameChatInput.value = cleanTitle.substring(0, 100);
                    showCopyMessage('AI title suggested in input field!', 'var(--accent-secondary)');
                } else {
                    showError("AI generated an empty title. Please try manually.");
                }
            } catch (error) {
                console.error("Failed to auto-rename chat:", error);
                showError("Failed to auto-rename chat: API Error. Check console.");
            } finally {
                // Restore buttons
                autoRenameChatBtn.disabled = false;
                saveRenameChatBtn.disabled = false;
                autoRenameChatBtn.innerHTML = originalContent;
                createIcons();
            }
        }

        // --- Utility Functions ---

        // Function to convert a file to a Base64 string and return its MIME type and data
        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve({
                    mimeType: file.type || 'application/octet-stream', 
                    data: reader.result.split(',')[1],
                    name: file.name
                });
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };
        
        // NEW: Function to convert a string of text into a virtual file attachment
        async function convertTextToAttachment(text, filename) {
            if (!currentUser) return;

            // Create a virtual File object from the text string
            const textBlob = new Blob([text], { type: 'text/plain' });
            const virtualFile = new File([textBlob], filename, { type: 'text/plain' });
            
            try {
                // Use the existing fileToBase64 function to get the base64 data
                const { mimeType, data } = await fileToBase64(virtualFile);
                
                // Add to global attachments list
                chatAttachments.push({ 
                    file: virtualFile, 
                    mimeType, 
                    data, 
                    name: filename 
                });
                
                // Update UI
                displayChatAttachments();
                
            } catch (error) {
                showError(`Failed to convert bulk text to file: ${filename}.`);
                console.error('Text conversion error:', error);
            }
        }


        // Function to get Lucide icon name based on MIME type
        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return 'image';
            if (mimeType === 'application/pdf') return 'file-text';
            if (mimeType.includes('text/')) return 'file-text';
            if (mimeType.includes('csv') || mimeType.includes('excel')) return 'file-spreadsheet';
            if (mimeType.includes('json') || mimeType.includes('xml') || mimeType.includes('code') || mimeType.includes('markdown')) return 'file-code';
            return 'file';
        }

        // Function to display an error message
        function showError(message) {
            errorText.textContent = message;
            errorContainer.classList.remove('hidden');
            setTimeout(() => {
                errorContainer.classList.add('hidden');
            }, 5000); 
        }
        
        // --- Marked.js Setup for Advanced Rendering (Code Blocks, Highlighting, & Math) ---
        
        // Configure marked options (simplified for custom renderer compatibility)
        marked.setOptions({
            gfm: true,
            breaks: true,
            // IMPORTANT: Do NOT set 'highlight' here. We handle highlighting manually below.
        });

        // --- Custom Renderer for Code Blocks (FINAL, ROBUST FIX for [object Object]) ---
        const renderer = {
            code(code, lang) {
                // RIGOROUS FIX: Check if 'code' is the raw token object instead of the string content.
                let rawCodeContent;
                if (typeof code === 'object' && code !== null && typeof code.text === 'string') {
                    // This handles the scenario where marked passes the token object { text: '...' }
                    rawCodeContent = code.text;
                } else {
                    // This handles the scenario where marked passes the expected string
                    rawCodeContent = String(code);
                }
                
                let highlightedCode = rawCodeContent;

                // Apply highlight.js directly inside the renderer
                if (lang && hljs.getLanguage(lang)) {
                    highlightedCode = hljs.highlight(rawCodeContent, { language: lang }).value;
                } else if (rawCodeContent.trim().length > 0) {
                    // If no known language, attempt auto-highlighting for best effect
                    highlightedCode = hljs.highlightAuto(rawCodeContent).value;
                }
                
                const languageDisplay = lang ? `<span class="text-xs font-semibold uppercase" style="color: var(--text-secondary);">` + lang + `</span>` : '';
                const uniqueId = `code-block-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                // We use hljs class for consistent styling.
                const langClass = lang ? `language-${lang}` : '';

                return `
                    <div class="code-block-container" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                        <div class="code-block-header" style="background-color: var(--code-block-header-bg); color: var(--text-secondary); border-bottom-color: var(--code-block-border);">
                            ${languageDisplay}
                            <button class="code-block-copy-button" data-copy-target="${uniqueId}" style="color: var(--text-secondary);">
                                <span data-lucide="clipboard" class="w-4 h-4"></span>
                                Copy code
                            </button>
                        </div>
                        <pre class="${langClass} hljs" style="color: var(--text-primary);"><code id="${uniqueId}" class="${langClass} hljs">${highlightedCode}</code></pre>
                    </div>
                `;
            },
            
            // Re-adding blockquote definition for consistent styling using CSS variables
            blockquote(quote) {
                 return `<blockquote style="border-left: 5px solid var(--accent-secondary); padding: 10px 15px; margin: 15px 0; opacity: 0.9; font-style: italic; background-color: color-mix(in srgb, var(--accent-secondary) 10%, transparent); color: var(--text-primary); border-radius: 0.5rem;">${quote}</blockquote>`;
            }
        };

        marked.use({ renderer });

        /**
         * Helper function to update a Lucide icon displayed within a button.
         */
        function updateButtonIcon(buttonElement, newIconName, classList = 'w-4 h-4') {
            let currentIconSvg = buttonElement.querySelector('.lucide');
            if (currentIconSvg) {
                currentIconSvg.remove();
            }

            const newIconSpan = document.createElement('span');
            newIconSpan.setAttribute('data-lucide', newIconName);
            newIconSpan.className = classList;

            buttonElement.appendChild(newIconSpan);
           
            createIcons();
        }
        
        // ADDED: Real-time search refresh function
        function refreshActiveChatSearch() {
            const query = chatSearchInput.value.trim();
            const isSearchVisible = !chatSearchInputContainer.classList.contains('hidden');
            
            // Only refresh if search is visible and has a query
            if (isSearchVisible && query.length > 2) {
                // Remember current index before clearing/re-highlighting
                const previousMatchIndex = currentMatchIndex; 
                
                // 1. Clear state and re-run highlight on the entire chat
                highlightChatMatches(query); 
                
                // 2. Attempt to restore focus to the closest previous match, or just the first new one
                if (searchMatches.length > 0) {
                    // Restore index, bounded by the new array size
                    currentMatchIndex = Math.min(previousMatchIndex, searchMatches.length - 1);
                    if (currentMatchIndex < 0) { currentMatchIndex = 0; }
                    
                    // Highlight and scroll to the restored index
                    searchMatches[currentMatchIndex].classList.add('highlight-current-match');
                    searchMatches[currentMatchIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    chatSearchCount.textContent = `${currentMatchIndex + 1}/${searchMatches.length}`;
                }
            }
        }

        // Function to append a message to the chat history
        function appendChatMessage(role, text, attachments = []) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', role);
            
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            messageDiv.dataset.messageId = messageId;
            
            let contentHTML = '';
            let rawMessageContentForCache = '';

            if (role === 'user') {
                rawMessageContentForCache = `You: ${text}`;
                contentHTML += `<span class="font-bold">You:</span> ${text}`;
                if (attachments.length > 0) {
                    contentHTML += `<div class="mt-2 flex flex-wrap gap-2">`;
                    attachments.forEach(attachment => {
                        if (attachment.mimeType.startsWith('image/')) {
                            contentHTML += `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name || 'User attachment'}" class="chat-image w-24 h-24 object-cover">`;
                        } else {
                            contentHTML += `
                                <div class="flex items-center space-x-1 p-2 rounded-md text-sm" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                                    <span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-4 h-4 flex-shrink-0" style="color: var(--accent-secondary);"></span>
                                    <span class="truncate max-w-[120px]">${attachment.name || 'File'}</span>
                                </div>
                            `;
                        }
                    });
                    rawMessageContentForCache += `\n[Attachments: ${attachments.map(a => a.name).join(', ')}]`;
                    contentHTML += `</div>`;
                }
            } else { // AI message
                rawMessageContentForCache = `AI: ${text}`;
                
                // Ensure text is a string before parsing
                const markdownText = String(text); 
                
                // ADDED markdown-content class here
                contentHTML = `<div class="message-content markdown-content">${marked.parse(markdownText)}</div>`;
                
                // IMPORTANT: Add KaTeX rendering for math equations
                // Use setTimeout to ensure the element is fully appended before trying to render math
                if (window.renderMathInElement) {
                    setTimeout(() => {
                        const contentElement = messageDiv.querySelector('.message-content');
                        if (contentElement) {
                            renderMathInElement(contentElement, {
                                delimiters: [
                                    { left: '$$', right: '$$', display: true },
                                    { left: '$', right: '$', display: false },
                                    { left: '\\(', right: '\\)', display: false }, 
                                    { left: '\\[', right: '\\]', display: true }  
                                ],
                                throwOnError: false
                            });
                            // Re-run icon creation after KaTeX renders its output HTML
                            createIcons();
                            refreshActiveChatSearch(); // Re-run search after KaTeX renders its output HTML
                        }
                    }, 50);
                }
            }
            
            messageTextCache.set(messageId, rawMessageContentForCache); 
            
            // NEW: Clear the initial welcome screen if it exists
            const welcomeScreen = document.getElementById('initial-welcome-screen');
            if (welcomeScreen) {
                chatHistoryDiv.innerHTML = '';
            }

            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            // Initial status is 'Sent' for user, 'Received' for AI (P6)
            const status = (role === 'user' ? '<span data-lucide="check" class="w-3 h-3"></span> Sent' : '<span data-lucide="message-square" class="w-3 h-3"></span> Processed');
            
            const metadataHTML = `
                <div class="message-metadata absolute bottom-1 left-1/2 transform -translate-x-1/2 text-xs flex items-center gap-3" style="color: var(--text-tertiary);">
                    <span class="message-status flex items-center gap-1">${status}</span>
                    <span class="message-timestamp">${timestamp}</span>
                </div>
            `;
            
            const actionsHTML = `
                <div class="message-actions">
                    <button class="copy-message-btn" title="Copy message" data-message-id="${messageId}">
                        <span data-lucide="clipboard" class="w-4 h-4"></span>
                    </button>
                    <button class="dictate-message-btn" title="Dictate message" data-message-id="${messageId}">
                        <span data-lucide="volume-2" class="w-4 h-4"></span>
                    </button>
                </div>
            `;
            
            messageDiv.innerHTML = contentHTML + metadataHTML + actionsHTML;
            chatHistoryDiv.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.transform = 'scale(1)';
            }, 10);
            
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            createIcons();
            
            // ADDED: Refresh search and code blocks when a new message is appended
            refreshActiveChatSearch();
            collectCodeBlocks();
        }
        
        // Global helper function for updating message status (Suggestion 6)
        function updateMessageStatus(messageElement, newStatus) {
            if (!messageElement) return;
            const statusSpan = messageElement.querySelector('.message-status');
            if (!statusSpan) return;

            let icon = '';
            let text = '';
            let color = 'var(--text-tertiary)';

            if (newStatus === 'processed') {
                icon = 'check-circle';
                text = 'Processed';
                color = 'var(--accent-success)';
            } else if (newStatus === 'sent') {
                icon = 'check';
                text = 'Sent';
            } else if (newStatus === 'error') {
                icon = 'alert-triangle';
                text = 'Failed';
                color = 'var(--accent-error)';
            } else if (newStatus === 'received') {
                icon = 'message-square';
                text = 'Received';
            }

            statusSpan.style.color = color;
            statusSpan.innerHTML = `<span data-lucide="${icon}" class="w-3 h-3"></span> ${text}`;
            createIcons();
        }

        // Legacy placeholder  main slash handler implemented near chat input to support extended commands
        function handleSlashCommand(command) {
            // Deprecated here; the comprehensive handler is defined closer to the input event listener
            return false;
        }

        // Event listener for chat file upload
        chatFileUpload.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                await processFiles(files);
                chatInput.focus();
            }
        });

        // Helper function to process files from various sources (drag/drop, paste, file input)
        async function processFiles(files) {
            for (const file of files) {
                const allowedTypes = [
                    'image/', 'text/', 'application/pdf',
                    'application/json', 'text/csv', 'application/xml', 'text/markdown'
                ];
                const isAllowed = allowedTypes.some(type => file.type.startsWith(type)) || file.name.endsWith('.md');

                if (isAllowed) {
                    try {
                        const { mimeType, data, name } = await fileToBase64(file);
                        chatAttachments.push({ file, mimeType, data, name: name || file.name });
                    } catch (error) {
                        showError(`Failed to read chat file ${file.name}.`);
                        console.error('Chat file read error:', error);
                    }
                } else {
                    showError(`File type not supported for chat: ${file.name} (${file.type}).`);
                }
            }
            displayChatAttachments();
            adjustChatInputHeight();
        }

        // Function to display chat attachments
        function displayChatAttachments() {
            chatAttachmentsPreviewContainer.innerHTML = '';
            if (chatAttachments.length > 0) {
                chatAttachmentsPreviewContainer.classList.remove('hidden');
                chatAttachments.forEach((attachment, index) => {
                    const attachmentDiv = document.createElement('div');
                    attachmentDiv.classList.add('chat-attachment-preview-item');
                    attachmentDiv.dataset.index = index;

                    let previewContent = '';
                    if (attachment.mimeType.startsWith('image/')) {
                        previewContent = `<img src="data:${attachment.mimeType};base64,${attachment.data}" alt="${attachment.name || 'User attachment'}" class="w-8 h-8 object-cover rounded-md">`;
                    } else {
                        previewContent = `<span data-lucide="${getFileIcon(attachment.mimeType)}" class="w-5 h-5 flex-shrink-0"></span>`;
                    }

                    attachmentDiv.innerHTML = `
                        ${previewContent}
                        <span class="truncate max-w-[100px]">${attachment.name}</span>
                        
                        <!-- NEW: Edit Button (Only show for text files that can be edited) -->
                        ${attachment.mimeType.startsWith('text/') || attachment.name.endsWith('.md') || attachment.name.endsWith('.json') || attachment.name.endsWith('.csv') ? 
                            `<button class="edit-attachment-btn" title="Edit attachment content" data-index="${index}">
                                <span data-lucide="edit" class="w-4 h-4"></span>
                            </button>` 
                            : ''}

                        <button class="remove-attachment-btn">
                            <span data-lucide="x" class="w-4 h-4"></span>
                        </button>
                    `;
                    chatAttachmentsPreviewContainer.appendChild(attachmentDiv);
                });
                createIcons();
            } else {
                chatAttachmentsPreviewContainer.classList.add('hidden');
            }
        }

        // Event listener for removing individual chat attachments (using event delegation)
        chatAttachmentsPreviewContainer.addEventListener('click', (event) => {
            const removeBtn = event.target.closest('.remove-attachment-btn');
            if (removeBtn) {
                const attachmentDiv = removeBtn.closest('[data-index]');
                if (attachmentDiv) {
                    const index = parseInt(attachmentDiv.dataset.index);
                    chatAttachments.splice(index, 1);
                    displayChatAttachments();
                    chatInput.focus();
                }
            }
        });

        // Adjust chat input textarea height dynamically (Updated for minimum height)
        function adjustChatInputHeight() {
            chatInput.style.height = '56px'; // Reset to minimum height (h-14 = 56px)
            const newHeight = Math.min(chatInput.scrollHeight, 200); // Max height defined by CSS
            chatInput.style.height = newHeight + 'px';
        }
        // Utility for Prompt Tool visibility (Request 4)
        function showPromptTool() {
            promptToolContainer.classList.add('show');
            promptToolContainer.classList.remove('hidden');
            createIcons();
        }

        function hidePromptTool() {
            if (promptToolTimeout) {
                clearTimeout(promptToolTimeout);
            }
            promptToolContainer.classList.remove('show');
            // Hide completely after transition finishes
            setTimeout(() => {
                promptToolContainer.classList.add('hidden');
            }, 300);
        }

        function checkPromptToolVisibility() {
            adjustChatInputHeight();
            const text = chatInput.value.trim();
            
            // Check if user is actively typing a draft within the preferred length range
            const isTypingDraft = text.length > PROMPT_MIN_LENGTH && text.length < PROMPT_MAX_LENGTH;
            const isToolAvailable = currentUser && userApiKey && !sendChatBtn.disabled;
            
            if (isTypingDraft && isToolAvailable) {
                // Show tool after a brief delay if user is still typing (1.5s delay)
                if (promptToolTimeout) clearTimeout(promptToolTimeout);
                promptToolTimeout = setTimeout(showPromptTool, 1500); 
            } else {
                hidePromptTool();
            }
        }
        
        // Listener for the chat input (MODIFIED)
        chatInput.addEventListener('input', checkPromptToolVisibility);
        
        // Listener for blur to immediately hide the tool if not accepted
        chatInput.addEventListener('blur', (e) => {
            // Check if the related target is one of the buttons inside the tool
            if (!e.relatedTarget || !e.relatedTarget.closest('#prompt-tool-container')) {
                 hidePromptTool();
            }
        }, true); // Use capture phase for more robust blur detection
        

        // Event listener for voice input button (general chat)
        voiceInputBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to use voice input.");
                return;
            }
            if (recognition) {
                if (isVoiceInputActive) {
                    recognition.stop();
                } else {
                    finalTranscript = ''; 
                    recognition.start();
                }
            } else {
                showError('Speech recognition is not supported in this browser.');
            }
        });

        // Drag and Drop for Chat Input Area
        chatInputAreaContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.add('drag-over-active');
        });

        chatInputAreaContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.remove('drag-over-active');
        });

        chatInputAreaContainer.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            chatInputAreaContainer.classList.remove('drag-over-active');

            if (!currentUser) {
                showError("Please sign in to attach files.");
                return;
            }

            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                await processFiles(files);
                chatInput.focus();
            }
        });

        // MODIFIED: Paste files/text onto the text input box logic (FIXED FOR SYNCHRONOUS PREVENTION)
        chatInput.addEventListener('paste', async (event) => {
            if (!currentUser) {
                showError("Please sign in to attach files.");
                return;
            }
            
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            const clipboardData = (event.clipboardData || event.originalEvent.clipboardData);
            
            let filesToProcess = [];
            // --- 1. SYNCHRONOUS TEXT RETRIEVAL ---
            let textToPaste = clipboardData.getData('text/plain') || ''; 
            let isBulkText = textToPaste.length > BULK_TEXT_THRESHOLD;

            // --- 2. SYNCHRONOUS FILE CHECK ---
            // Check for image files synchronously within the items loop
            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        filesToProcess.push(file);
                    }
                }
            }

            // --- 3. CRITICAL SYNCHRONOUS PREVENTION ---
            // If it's a large text dump AND there are no files (images) present,
            // we prevent the default paste action IMMEDIATELY.
            if (isBulkText && filesToProcess.length === 0) {
                event.preventDefault(); 
            }
            
            // --- 4. ASYNCHRONOUS PROCESSING ---

            if (event.defaultPrevented) { 
                // Case A: Bulk text was prevented. Now convert it and set a clean prompt.
                
                // Get the prompt currently in the input (text before the paste)
                const existingPrompt = chatInput.value.trim(); 

                // Convert the pasted bulk text into a virtual attachment (async)
                const filename = 'bulk_code_data_dump.txt';
                await convertTextToAttachment(textToPaste, filename);

                // Set the input field to the user's intended prompt, clearing the bulk text
                chatInput.value = existingPrompt || '';
                
                adjustChatInputHeight();
                //showCopyMessage('Large text detected and attached as a file!', 'var(--accent-primary)');

            } else if (filesToProcess.length > 0) {
                // Case B: Files (images) are being processed.
                // Note: Small text will have already been pasted by the browser default action.
                await processFiles(filesToProcess);
                adjustChatInputHeight();
            }
            
            chatInput.focus();
        });

        // Event listener for the New Chat button in sidebar
        newChatButton.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to start a new chat.");
                return;
            }
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
                currentUtterance = null;
            }
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }
            if (isConversationModeActive) {
                stopConversationMode();
            }
            createNewChatSession();
        });
        
        // Function to show a temporary message for clipboard copy
        function showCopyMessage(message = 'Text copied to clipboard!', bgColor = 'var(--accent-success)') {
            copyMessage.textContent = message;
            copyMessage.style.backgroundColor = bgColor;
            copyMessage.classList.add('show');
            setTimeout(() => {
                copyMessage.classList.remove('show');
            }, 3000);
        }

        // Event delegation for copy code buttons within chat history
        chatHistoryDiv.addEventListener('click', (event) => {
            const codeCopyButton = event.target.closest('.code-block-copy-button');
            if (codeCopyButton) {
                const targetId = codeCopyButton.dataset.copyTarget;
                const codeElement = document.getElementById(targetId);
                if (codeElement) {
                    const codeToCopy = codeElement.textContent;
                    updateButtonIcon(codeCopyButton, 'check', 'w-4 h-4');
                    copyToClipboard(codeToCopy); 
                    setTimeout(() => {
                        updateButtonIcon(codeCopyButton, 'clipboard', 'w-4 h-4');
                    }, 2000);
                    return;
                }
            }

            const chatCopyButton = event.target.closest('.copy-message-btn');
            if (chatCopyButton) {
                const messageId = chatCopyButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    updateButtonIcon(chatCopyButton, 'check');
                    copyToClipboard(messageContent); 
                    setTimeout(() => {
                        updateButtonIcon(chatCopyButton, 'clipboard');
                    }, 2000);
                } else {
                    showError('Message content not found for copying.');
                }
                return;
            }

            const dictateButton = event.target.closest('.dictate-message-btn');
            if (dictateButton) {
                const messageId = dictateButton.dataset.messageId;
                const messageContent = messageTextCache.get(messageId);
                if (messageContent) {
                    toggleSpeech(messageContent, dictateButton);
                } else {
                    showError('Message content not found for dictation.');
                }
                return;
            }
        });

        // Event delegation for sidebar chat items
        sidebarChatList.addEventListener('click', (event) => {
            const chatItem = event.target.closest('.sidebar-chat-item');
            if (chatItem) {
                const sessionId = chatItem.dataset.sessionId;
                const deleteBtn = event.target.closest('.delete-chat-btn');
                // ADDED: Rename Button check
                const renameBtn = event.target.closest('.rename-chat-btn'); 

                if (deleteBtn) {
                    event.stopPropagation(); 
                    deleteChatSession(sessionId);
                } else if (renameBtn) { // Handle Rename click
                    event.stopPropagation();
                    // *** MODIFIED LINE ***
                    openRenameChatModal(sessionId); 
                    // *** END MODIFIED LINE ***
                } else {
                    loadChatSession(sessionId);
                }
            }
        });

        // Hamburger menu for mobile sidebar
        hamburgerMenuButton.addEventListener('click', () => {
            sidebar.classList.remove('hidden-mobile');
            sidebarOverlay.classList.add('active');
        });

        closeSidebarBtn.addEventListener('click', () => {
            sidebar.classList.add('hidden-mobile');
            sidebarOverlay.classList.remove('active');
        });

        sidebarOverlay.addEventListener('click', () => {
            sidebar.classList.add('hidden-mobile');
            sidebarOverlay.classList.remove('active');
        });

        // ADD THIS SECTION

        // --- Chat History Search Functions (Fix for Real-time Update) ---

        function clearChatSearch() {
            // 1. Restore original content from cache
            document.querySelectorAll('.chat-message').forEach(msgDiv => {
                const messageId = msgDiv.dataset.messageId;
                
                // Only restore if we have saved content for it, to prevent overwriting new messages immediately after an API call
                if (originalChatContent.has(messageId)) {
                    msgDiv.innerHTML = originalChatContent.get(messageId);
                    // Remove the entry once restored, so next time it gets saved fresh
                    originalChatContent.delete(messageId); 
                }
            });

            // 2. Clear state
            searchMatches = [];
            currentMatchIndex = -1;
            chatSearchCount.textContent = '0/0';
            
            // 3. Re-render icons for restored content (crucial for Lucide icons and code highlighting)
            createIcons();
        }

        function highlightChatMatches(query) {
            clearChatSearch();
            if (!query || query.length < 3) return 0; // Require minimum 3 characters for performance

            searchMatches = [];
            let matchCount = 0;
            const regex = new RegExp(query, 'gi');

            // Select all chat messages
            document.querySelectorAll('.chat-message').forEach(msgDiv => {
                const messageId = msgDiv.dataset.messageId;
                
                // 1. Save the initial innerHTML of the message for restoration (only if not already saved)
                if (!originalChatContent.has(messageId)) {
                    originalChatContent.set(messageId, msgDiv.innerHTML);
                }

                // --- DOM Traversal and Replacement Logic ---
                // We use the temporary raw text cache for search matching, but apply changes to the DOM.
                
                // Clear any existing highlight spans before re-highlighting (handled by clearChatSearch, which restores innerHTML)
                
                // The AI response uses innerHTML generated by marked.parse, while User uses simple text + attachments.
                const contentToSearch = msgDiv.querySelector('.message-content') || msgDiv;

                function walkAndHighlight(node) {
                    // 3: Text Node
                    if (node.nodeType === 3) { 
                        const text = node.nodeValue;
                        const matches = [...text.matchAll(regex)];
                        
                        if (matches.length > 0) {
                            const fragment = document.createDocumentFragment();
                            let lastIndex = 0;
                            
                            matches.forEach(match => {
                                // Append text before the match
                                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                                
                                // Create and append the highlight span
                                const span = document.createElement('span');
                                span.className = 'highlight-match';
                                span.textContent = match[0];
                                fragment.appendChild(span);
                                
                                matchCount++;
                                lastIndex = match.index + match[0].length;
                            });
                            
                            // Append remaining text
                            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                            node.parentNode.replaceChild(fragment, node);
                        }
                    } 
                    // 1: Element Node
                    else if (node.nodeType === 1) {
                        if (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE' || node.classList.contains('message-actions')) return;

                        // Recursively walk through child nodes
                        Array.from(node.childNodes).forEach(walkAndHighlight);
                    }
                }
                
                walkAndHighlight(contentToSearch);
            });

            // 2. Re-query all newly created highlight spans globally to populate searchMatches
            searchMatches = Array.from(document.querySelectorAll('.highlight-match'));

            chatSearchCount.textContent = `0/${searchMatches.length}`;
            currentMatchIndex = -1;
            createIcons();
            return searchMatches.length;
        }


        function navigateChatMatch(direction) {
            if (searchMatches.length === 0) return;

            // Remove highlight from current match
            if (currentMatchIndex >= 0) {
                searchMatches[currentMatchIndex].classList.remove('highlight-current-match');
            }

            let nextIndex;
            if (direction === 'next') {
                nextIndex = (currentMatchIndex + 1) % searchMatches.length;
            } else { // 'prev'
                nextIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
            }

            currentMatchIndex = nextIndex;

            // Highlight new current match
            const currentMatch = searchMatches[currentMatchIndex];
            currentMatch.classList.add('highlight-current-match');
            
            // Scroll to the new match
            currentMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });

            chatSearchCount.textContent = `${currentMatchIndex + 1}/${searchMatches.length}`;
        }
        
        // --- Code Block Jump Functions ---
        
        function collectCodeBlocks() {
            codeBlocks = Array.from(chatHistoryDiv.querySelectorAll('.code-block-container'));
            
            // Show/hide jump buttons based on availability
            if (codeBlocks.length > 0) {
                jumpCodePrevBtn.classList.remove('hidden');
                jumpCodeNextBtn.classList.remove('hidden');
            } else {
                jumpCodePrevBtn.classList.add('hidden');
                jumpCodeNextBtn.classList.add('hidden');
            }
            
            currentCodeBlockIndex = -1; // Reset index
            
            // Remove previous temporary highlights
            codeBlocks.forEach(block => block.style.border = `1px solid var(--code-block-border)`);
        }
        
        function jumpToCodeBlock(direction) {
            if (codeBlocks.length === 0) {
                collectCodeBlocks(); // Try one more time in case of timing issue
                if (codeBlocks.length === 0) {
                     showError("No code blocks found in the chat.");
                     return;
                }
            }
            
            // Reset border on the current block
            if (currentCodeBlockIndex >= 0) {
                const prevBlock = codeBlocks[currentCodeBlockIndex];
                prevBlock.style.border = `1px solid var(--code-block-border)`;
                prevBlock.style.boxShadow = `0 4px 8px rgba(0,0,0,0.3)`;
            }

            let nextIndex;
            if (direction === 'next') {
                nextIndex = (currentCodeBlockIndex + 1) % codeBlocks.length;
            } else { // 'prev'
                nextIndex = (currentCodeBlockIndex - 1 + codeBlocks.length) % codeBlocks.length;
            }
            
            currentCodeBlockIndex = nextIndex;
            const targetBlock = codeBlocks[currentCodeBlockIndex];
            
            // Highlight and scroll
            targetBlock.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Temporary visual highlight
            targetBlock.style.border = `3px solid var(--accent-primary)`;
            targetBlock.style.boxShadow = `0 0 20px var(--accent-primary)`;
            
            // Remove highlight after a short delay
            setTimeout(() => {
                targetBlock.style.border = `1px solid var(--code-block-border)`;
                targetBlock.style.boxShadow = `0 4px 8px rgba(0,0,0,0.3)`;
            }, 1000);
        }

        // NEW: Function to call the AI to generate a structured prompt (Request 4)
        async function generateStructuredPrompt(userDraft, attachments) {
            const fileList = attachments.map(a => `- ${a.name} (${a.mimeType})`).join('\n');
            const fileContext = attachments.length > 0 
                                ? `\n\n### Attached Files to be Analyzed:\n${fileList}\n(The target AI has access to the full content of these files, ensure your prompt tells it to analyze them.)` 
                                : `\n\n(No files attached.)`;

            const systemInstruction = `You are the world's best prompt engineering AI named 'Small AI v2 Prompt Engineer'. Your task is to take a user's raw input draft and attached file information, and transform it into a highly detailed, professional, and optimized prompt for the main Gemini AI model. 
Criteria for the optimized prompt:
1. **Role/Persona:** Clearly assign an expert persona (e.g., "You are a senior JavaScript developer").
2. **Goal & Constraints:** Define the specific goal, required output format (e.g., Markdown, JSON), and length constraints.
3. **Contextual Instructions:** If attached files exist, the generated prompt MUST explicitly instruct the target AI to analyze and incorporate the file content.
4. **Actionable:** The final output MUST be the single, optimized prompt text, ready for the user to submit.

Output ONLY the improved, single, structured prompt text. Do not include any pre-amble, comments, or explanations outside of the final optimized prompt itself.`;

            const contents = [
                {
                    role: "user",
                    parts: [{ 
                        text: `USER DRAFT:\n---\n${userDraft}\n---${fileContext}\n\nBased on the draft and file context, generate the single, best-structured prompt for the target AI.` 
                    }]
                }
            ];

            try {
                // Use the specified model for speed and capability (Required by R4)
                const responseText = await callGeminiAPI(
                    { 
                        contents: contents, 
                        generationConfig: { 
                        }
                    }, 
                    null, 
                    'gemini-2.5-flash-preview-09-2025', 
                    systemInstruction
                );
                return responseText.trim();
            } catch (error) {
                console.error("Prompt generation failed:", error);
                showError(`Prompt Enhancement Failed: ${error.message}. Returning original draft.`);
                return userDraft; // Return original draft as fallback
            }
        }
        
        // Helper function to copy text to clipboard
        function copyToClipboard(text) { 
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopyMessage();
                    })
                    .catch(err => {
                        console.error('Failed to copy: ', err);
                        showError('Failed to copy text. Please copy manually.');
                    }); 
            } else {
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = text;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                    showCopyMessage();
                } catch (err) {
                    console.error('Failed to copy (fallback):', err);
                    showError('Failed to copy text. Please copy manually.');
                }
                document.body.removeChild(tempTextArea);
            }
        }

        // Helper function for text-to-speech (general chat dictation)
        function toggleSpeech(text, buttonElement) {
            if (!window.speechSynthesis) {
                showError('Speech synthesis not supported in this browser.');
                return;
            }

            if (isSpeaking && currentUtterance && currentUtterance.text === text) {
                if (window.speechSynthesis.paused) {
                    window.speechSynthesis.resume();
                    updateButtonIcon(buttonElement, 'pause');
                } else {
                    window.speechSynthesis.pause();
                    updateButtonIcon(buttonElement, 'volume-2');
                }
            } else {
                startSpeech(text, buttonElement);
            }
        }

        function startSpeech(text, buttonElement) {
            if (window.speechSynthesis.speaking || window.speechSynthesis.paused) {
                window.speechSynthesis.cancel();
            }

            document.querySelectorAll('.dictate-message-btn').forEach(btn => {
                if (btn !== buttonElement) {
                    updateButtonIcon(btn, 'volume-2'); 
                }
            });

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';

            utterance.onstart = () => {
                isSpeaking = true;
                currentUtterance = utterance;
                updateButtonIcon(buttonElement, 'pause');
            };
            utterance.onend = () => {
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };
            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                showError('Failed to dictate message. Check console for details.');
                isSpeaking = false;
                currentUtterance = null;
                updateButtonIcon(buttonElement, 'volume-2');
            };

            window.speechSynthesis.speak(utterance);
        }

        // Generic API call function with exponential backoff (MODIFIED for API Key)
        async function callGeminiAPI(payload, personalityName = "Standard", targetModel = selectedModel, systemInstruction = null) {
            const fallbackApiKey = "AIzaSyCnsccknz5O5TYII723JipYSmYjj5OVdTk"; 
            const apiKey = userApiKey || fallbackApiKey;

            if (!apiKey || apiKey === "YOUR_GEMINI_API_KEY") { 
                throw new Error("API Key is not set. Please enter your custom key or ensure the fallback key is correct.");
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${targetModel}:generateContent?key=${apiKey}`;

            const contentsToSend = JSON.parse(JSON.stringify(payload.contents));
            
            let promptPrefix = '';

            // 1. Determine the final system/instruction prompt text
            if (systemInstruction) {
                promptPrefix = systemInstruction.trim();
            } 
            else if (isCustomPromptActive && customPromptText.trim() !== '') {
                promptPrefix = customPromptText.trim();
            } 
            else {
                const selectedPersonalityObj = personalities.find(p => p.name === personalityName);
                if (selectedPersonalityObj && selectedPersonalityObj.prompt) {
                    promptPrefix = selectedPersonalityObj.prompt.trim();
                }
            }

            // 2. Safely prepend the instruction to the first user message,
            //    as this REST endpoint structure rejects systemInstruction fields easily.
            if (promptPrefix) {
                let injected = false;
                // Find the first user message to prepend the instruction
                for (const message of contentsToSend) {
                    if (message.role === 'user' && message.parts && message.parts.length > 0 && message.parts[0].text) {
                        message.parts[0].text = promptPrefix + "\n\n" + message.parts[0].text;
                        injected = true;
                        break;
                    }
                }
                // If the chat history starts with a model message (the welcome message), inject a dummy user prompt first.
                if (!injected && contentsToSend.length > 0) {
                    contentsToSend.unshift({ role: "user", parts: [{ text: promptPrefix + "\n\n(Context injection: Ignore this message and proceed to process the actual user query in the next turn.)" }] });
                }
            }
            
            // 3. Build the final payload, ensuring all config parameters are directly under generationConfig
            //    We explicitly *omit* systemInstruction from the payload structure now.
            const finalPayload = { 
                contents: contentsToSend
                // payload may already contain generationConfig from the title/summary helper calls.
                // We use spread syntax to keep any properties passed from the calling functions (like temperature).
            };

            if (payload.generationConfig) {
                finalPayload.generationConfig = payload.generationConfig;
            }

            let response;
            let result;
            let success = false;
            let retryCount = 0;
            const maxRetries = 3;
            let delay = 1000;

            while (retryCount < maxRetries && !success) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(finalPayload)
                    });

                    if (response.status === 429) {
                        if (retryCount < maxRetries - 1) {
                            console.warn(`API rate limit exceeded. Retrying in ${delay / 1000}s...`);
                            await new Promise(res => setTimeout(res, delay));
                            delay *= 2;
                            retryCount++;
                        } else {
                            throw new Error('API rate limit exceeded. Please try again later.');
                        }
                    } else if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
                    } else {
                        result = await response.json();
                        success = true;
                    }
                } catch (err) {
                    if (retryCount < maxRetries - 1) {
                        console.warn(`Fetch error: ${err.message}. Retrying in ${delay / 1000}s...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                        retryCount++;
                    } else {
                        throw err;
                    }
                }
            }
            
            if (result && result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                 // Check for block reasons
                if (result && result.candidates && result.candidates.length > 0 && result.candidates[0].finishReason === "SAFETY") {
                    throw new Error('Response blocked due to safety settings.');
                }
                throw new Error('Failed to get a valid response from the AI. No candidates found or content is empty.');
            }
        }

        // --- NEW: Auto-Title Generation (Request 1) ---

        async function autoGenerateChatTitle(sessionId) {
            const session = allChatSessions[sessionId];
            
            // Check if title is default AND if the history has reached the length corresponding 
            // to 3 full user exchanges (7 messages: AI Welcome + U1/A1 + U2/A2 + U3/A3).
            const isDefaultTitle = session.title === 'New Chat' || session.title === 'Welcome Chat';
            if (!session || !isDefaultTitle || session.history.length < 7) return;

            // Get the first 6 messages (AI Welcome, U1, A1, U2, A2, U3) to use as context.
            const historyForTitle = session.history.slice(0, 6).map(msg => {
                // Simplify history for the title request to save tokens
                const textPart = msg.parts.find(p => p.text);
                return {
                    role: msg.role,
                    parts: [{ text: textPart ? textPart.text.substring(0, 250) : '[Attachment]' }] 
                };
            });
            
            // Highly optimized prompt for auto-title generation (Request 2)
            const systemInstruction = "Analyze the content of the first three user turns and the preceding AI responses in this conversation. Generate a single, concise title for the chat (max 8 words). Respond ONLY with the title text, nothing else.";

            try {
                const payload = {
                    contents: historyForTitle,
                    generationConfig: {
                        temperature: 0.1,
                        maxOutputTokens: 20,
                    }
                };
                
                // Use a fast model for title generation
                const title = await callGeminiAPI(payload, null, 'gemini-2.5-flash-lite-preview-09-2025', systemInstruction);
                const cleanTitle = title.replace(/["']/g, '').trim();

                if (cleanTitle && cleanTitle.length > 0) {
                    session.title = cleanTitle.substring(0, 100);
                    await saveChatToDB(session);
                    renderSidebarChats();
                    console.log(`Chat title auto-generated: ${session.title}`);
                }
            } catch (error) {
                console.error("Failed to auto-generate chat title:", error);
            }
        }

        // --- NEW: Chat Summarization (Request 2) ---

        async function generateChatSummary(history) {
            const systemInstruction = "Analyze the entire conversation history provided below. Generate a concise but comprehensive summary (around 3-5 paragraphs) that captures the core context, key decisions, established facts, and recurring themes. This output will be used as a system instruction/context for a future AI chat session. Do not include greetings or standard conversational filler. Output ONLY the raw summary text.";
            
            // Format history into simple text for summarization
            const textHistory = history.map(msg => {
                const textPart = msg.parts.find(p => p.text);
                return `${msg.role === 'user' ? 'User' : 'AI'}: ${textPart ? textPart.text : '[Attachment Data]'}`;
            }).join('\n\n');

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: textHistory }] }],
                    generationConfig: {
                    }
                };
                
                const summary = await callGeminiAPI(payload, null, 'gemini-2.5-flash-preview-09-2025', systemInstruction);
                return summary;
            } catch (error) {
                console.error("Failed to generate chat summary:", error);
                throw new Error("Could not generate chat summary due to API error.");
            }
        }
        
        async function handleSummarizeChat() {
            if (!currentUser || !currentSessionId || !allChatSessions[currentSessionId]) {
                showError("No active chat session to summarize.");
                return;
            }
            
            const session = allChatSessions[currentSessionId];
            if (session.history.length < 3) {
                showError("The chat must have at least one full exchange (User + AI) to generate context.");
                return;
            }

            // Disable UI while processing
            sendChatBtn.disabled = true;
            showCopyMessage('Generating chat context summary...', 'var(--accent-secondary)');

            try {
                const summary = await generateChatSummary(session.history);
                
                // Open Custom Prompt modal and pre-fill the summary
                customPromptInput.value = summary;
                customPromptModal.classList.remove('hidden');
                
                showCopyMessage('Context summary generated! Review and save to activate.', 'var(--accent-primary)');

            } catch (error) {
                showError(error.message);
            } finally {
                sendChatBtn.disabled = false;
            }
        }

        // --- NEW: Developer Console Handlers (Request 3) ---

        function openDeveloperConsole() {
            developerConsoleModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; 
            // Re-render logs in case any were missed before the console modal was available
            developerConsoleContent.innerHTML = logHistory.map(log => {
                return `<div class="log-item"><span class="log-timestamp">${log.timestamp}</span> <span class="log-level-${log.level.toLowerCase()}">${log.level.toUpperCase()}</span> <span style="color: white; margin-left: 10px;">${log.message}</span></div>`;
            }).join('');
            developerConsoleContent.scrollTop = developerConsoleContent.scrollHeight;
        }

        function closeDeveloperConsole() {
            developerConsoleModal.classList.add('hidden');
            document.body.style.overflow = '';
        }

        function clearDeveloperConsole() {
            if (confirm("Are you sure you want to clear the entire log history?")) {
                logHistory.length = 0; // Clear array
                // FIX: Ensure the log history element itself is cleared, not just replacing the starter text
                developerConsoleContent.innerHTML = '<p>--- Console Log Cleared ---</p>'; 
                console.log("Log history cleared by user.");
            }
        }
        
        // Event listener for sending chat messages (MODIFIED for Request 1)
        sendChatBtn.addEventListener('click', async () => {
            if (!currentUser) {
                showError("Please sign in to send messages.");
                return;
            }

            const userMessage = chatInput.value.trim();
            if (!userMessage && chatAttachments.length === 0) {
                return;
            }
            
            const isNewChat = !currentSessionId || !allChatSessions[currentSessionId];
            if (isNewChat) {
                await createNewChatSession(userMessage.substring(0, 50) || 'New Chat');
            }

            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }

            const userParts = [];
            if (userMessage) {
                userParts.push({ text: userMessage });
            }
            for (const attachment of chatAttachments) {
                userParts.push({
                    inlineData: {
                        mimeType: attachment.mimeType,
                        data: attachment.data
                    }
                });
            }

            const currentSessionHistory = allChatSessions[currentSessionId].history;
            const historyLengthBeforeUserMessage = currentSessionHistory.length;

            currentSessionHistory.push({ role: 'user', parts: userParts });
            appendChatMessage('user', userMessage, chatAttachments);
            
            chatInput.value = '';
            chatInput.dataset.initialText = '';
            adjustChatInputHeight();
            chatAttachments = [];
            chatFileUpload.value = '';
            displayChatAttachments();
            
            sendChatBtn.disabled = true;
            
            const loadingMessage = document.createElement('div');
            loadingMessage.id = 'chat-loading';
            loadingMessage.classList.add('chat-message', 'ai', 'p-4', 'text-sm', 'max-w-xs', 'mx-auto'); /* Use AI bubble styling (P6) */
            loadingMessage.style.paddingBottom = 'var(--space-lg)'; // Adjust padding for simpler loading message
            loadingMessage.innerHTML = `
                <div class="loader-container h-8">
                    <div class="loader-typing-bar"></div>
                    <div class="loader-typing-bar"></div>
                    <div class="loader-typing-bar"></div>
                </div>
                <!-- NEW: Add a rotating status message (P6) -->
                <div id="loading-status" class="mt-2 block font-medium text-center" style="color: var(--accent-secondary);">Crafting response...</div>
            `;
            chatHistoryDiv.appendChild(loadingMessage);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
            
            // R6: Simulate rotating loading messages 
            const statusMessages = ["AI is thinking...", "Processing request...", "Crafting response...", "Analyzing data...", "Consulting the nexus..."];
            let statusIndex = 0;
            const statusElement = document.getElementById('loading-status');
            const updateStatus = () => {
                if (statusElement) {
                    statusElement.textContent = statusMessages[statusIndex];
                    statusIndex = (statusIndex + 1) % statusMessages.length;
                }
            };
            updateStatus(); // Initial run
            const statusInterval = setInterval(updateStatus, 2000); // Change every 2 seconds
            loadingMessage.dataset.statusInterval = statusInterval; // Store interval ID

            try {
                const payload = {
                    contents: currentSessionHistory, 
                };
                
                const responseText = await callGeminiAPI(payload, selectedPersonality); 
                
                currentSessionHistory.push({ role: 'model', parts: [{ text: responseText }] });
                appendChatMessage('ai', responseText);
                
                await updateCurrentSessionHistory(); 

                // Update statuses: mark AI and user messages as processed (Suggestion 6)
                const lastAiMessage = chatHistoryDiv.lastChild;
                if (lastAiMessage) {
                    updateMessageStatus(lastAiMessage, 'processed');
                }
                const lastUserMessage = chatHistoryDiv.children[chatHistoryDiv.children.length - 2];
                if (lastUserMessage && lastUserMessage.classList.contains('user')) {
                    updateMessageStatus(lastUserMessage, 'processed');
                }
                
                // R1: Check if this was the THIRD full exchange (history length is now 7: AI + 3x(U/A)) and needs a title.
                // The historyLengthBeforeUserMessage will be 5 when the history contains: 
                // [AI Welcome, U1, A1, U2, A2]. The user message U3 makes it 6, and this AI response makes it 7.
                const title = allChatSessions[currentSessionId].title;
                const isDefaultTitle = title === 'New Chat' || title === 'Welcome Chat';
                
                if (isDefaultTitle && historyLengthBeforeUserMessage === 5) {
                    console.log("Triggering auto-title generation after 3rd user message turn.");
                    autoGenerateChatTitle(currentSessionId);
                }
                
            } catch (error) {
                console.error('Chat API call failed:', error);
                showError(`An error occurred in the chat: ${error.message}`);
                // Safely remove the user message and the loading spinner, but keep the previous history
                currentSessionHistory.pop(); 
                await updateCurrentSessionHistory(); 
                // Update the last user message shown (if any) to reflect the error status
                const lastUserMessageOnError = chatHistoryDiv.lastChild;
                if (lastUserMessageOnError && lastUserMessageOnError.classList.contains('user')) {
                    updateMessageStatus(lastUserMessageOnError, 'error');
                }
            } finally { 
                sendChatBtn.disabled = false;
                const loadingDiv = document.getElementById('chat-loading');
                if (loadingDiv) {
                    const statusInterval = loadingDiv.dataset.statusInterval;
                    if (statusInterval) clearInterval(statusInterval); // Clear interval (P6)
                    loadingDiv.remove();
                }
                chatInput.focus();
            }
        });
        
        // --- Slash Command Handler ---
        async function handleSlashCommand(input) {
            const raw = input.trim();
            if (!raw.startsWith('/')) return false;
            const parts = raw.slice(1).trim().split(/\s+/);
            const cmd = (parts.shift() || '').toLowerCase();
            const arg = parts.join(' ').trim();

            switch (cmd) {
                case 'clear':
                    chatInput.value = '';
                    chatAttachments = [];
                    displayChatAttachments();
                    adjustChatInputHeight();
                    showCopyMessage('Input and attachments cleared.', 'var(--accent-secondary)');
                    return true;

                case 'export':
                    openMarkdownExportModal();
                    return true;

                case 'new':
                    createNewChatSession();
                    return true;

                case 'help':
                case 'guide':
                    openQuickStartGuideModal();
                    return true;

                case 'settings':
                    // Open sidebar and expand settings section
                    if (hamburgerMenuButton) hamburgerMenuButton.click();
                    setTimeout(() => { if (toggleSettingsBtn) toggleSettingsBtn.click(); }, 300);
                    return true;

                case 'summarize':
                    handleSummarizeChat();
                    return true;

                case 'model':
                    if (!arg) {
                        showCopyMessage(`Current model: ${selectedModel}`, 'var(--accent-primary)');
                        return true;
                    }
                    // Try to find matching model alias
                    let foundModel = availableModels.find(m => m.toLowerCase().includes(arg.toLowerCase()));
                    if (foundModel) {
                        selectedModel = foundModel;
                        if (currentUser) saveUserSetting(MODEL_KEY, selectedModel);
                        updateModelDropdown();
                        showCopyMessage(`AI Model changed to ${selectedModel}`, 'var(--accent-primary)');
                    } else {
                        showError(`No model found matching '${arg}'.`);
                    }
                    return true;

                case 'theme':
                    if (!arg) {
                        showCopyMessage(`Current theme: ${currentThemeName} (${currentMode})`, 'var(--accent-primary)');
                        return true;
                    }
                    if (arg.toLowerCase() === 'random') {
                        handleRandomThemeSwitch();
                        return true;
                    }

                    // Normalize and detect variants like 'name-light' or 'name dark'
                    let modeToApply = currentMode;
                    let themeNameCandidate = arg.trim();
                    const lowerArg = themeNameCandidate.toLowerCase();

                    // If arg exactly matches a known variant (e.g., 'celestial-horizon-light'), use it directly
                    const exactMatch = AVAILABLE_THEMES.find(t => t.toLowerCase() === lowerArg);
                    if (exactMatch) {
                        const idx = exactMatch.lastIndexOf('-');
                        themeNameCandidate = exactMatch.slice(0, idx);
                        modeToApply = exactMatch.slice(idx + 1);
                    } else {
                        // Check for trailing ' dark' or ' light' (space-separated)
                        const themeParts = themeNameCandidate.split(/\s+/);
                        const possibleMode = themeParts[themeParts.length - 1].toLowerCase();
                        if (possibleMode === 'dark' || possibleMode === 'light') {
                            modeToApply = possibleMode;
                            themeNameCandidate = themeParts.slice(0, -1).join(' ');
                        } else if (/\-(dark|light)$/i.test(themeNameCandidate)) {
                            // If user typed 'name-dark' or 'name-light'
                            const idx = themeNameCandidate.lastIndexOf('-');
                            modeToApply = themeNameCandidate.slice(idx + 1).toLowerCase();
                            themeNameCandidate = themeNameCandidate.slice(0, idx);
                        }
                    }

                    // Validate that the resolved variant exists
                    const variant = `${themeNameCandidate}-${modeToApply}`;
                    const variantExists = AVAILABLE_THEMES.some(t => t.toLowerCase() === variant.toLowerCase());
                    if (!variantExists) {
                        showError(`No theme found matching '${arg}'. Try listing available themes with '/theme' or pick an exact variant like 'celestial-horizon-light'.`);
                        return true;
                    }

                    // Apply and save
                    applyTheme(themeNameCandidate, modeToApply);
                    if (currentUser) {
                        saveUserSetting('themeName', themeNameCandidate);
                        saveUserSetting('themeMode', modeToApply);
                    }
                    showCopyMessage(`Theme set: ${themeNameCandidate} (${modeToApply})`, 'var(--accent-primary)');
                    return true;

                case 'dark':
                    applyTheme(currentThemeName, 'dark');
                    if (currentUser) saveUserSetting('themeMode', 'dark');
                    showCopyMessage('Switched to dark mode', 'var(--accent-primary)');
                    return true;

                case 'light':
                    applyTheme(currentThemeName, 'light');
                    if (currentUser) saveUserSetting('themeMode', 'light');
                    showCopyMessage('Switched to light mode', 'var(--accent-primary)');
                    return true;

                case 'voice':
                    if (arg === 'start') {
                        if (typeof recognition !== 'undefined' && recognition) {
                            try { recognition.start(); showCopyMessage('Voice input started.', 'var(--accent-primary)'); } catch(e) { showError('Could not start recognition.'); }
                        } else { showError('Speech recognition not available in this browser.'); }
                        return true;
                    } else if (arg === 'stop') {
                        if (typeof recognition !== 'undefined' && recognition) { recognition.stop(); showCopyMessage('Voice input stopped.', 'var(--accent-primary)'); } else { showError('Speech recognition not available.'); }
                        return true;
                    } else {
                        // Toggle
                        if (voiceInputBtn) voiceInputBtn.click();
                        return true;
                    }

                case 'attach':
                    if (chatFileUpload) chatFileUpload.click();
                    return true;

                case 'download':
                case 'download-md':
                    const downloadBtn = document.getElementById('download-markdown-btn');
                    if (downloadBtn) downloadBtn.click(); else showError('Download button not found.');
                    return true;

                case 'signin':
                    if (typeof handleGoogleSignIn === 'function') handleGoogleSignIn(); else if (googleSignInBtn) googleSignInBtn.click();
                    return true;

                case 'signout':
                case 'logout':
                    if (typeof handleSignOut === 'function') handleSignOut(); else if (signOutButton) signOutButton.click();
                    return true;

                case 'console':
                case 'developer-console':
                    if (typeof openDeveloperConsole === 'function') openDeveloperConsole(); else if (developerConsoleBtn) developerConsoleBtn.click();
                    return true;

                case 'delete-all':
                    if (deleteAllChatsBtn) deleteAllChatsBtn.click(); else showError('Delete All Chats button not found.');
                    return true;

                case 'clear-storage':
                    if (clearLocalStorageBtn) clearLocalStorageBtn.click(); else showError('Clear storage control not found.');
                    return true;

                case 'rename':
                    if (!currentSessionId) { showError('No active session to rename.'); return true; }
                    if (!arg) {
                        openRenameChatModal(currentSessionId);
                        return true;
                    }
                    renamingSessionId = currentSessionId;
                    renameChatInput.value = arg;
                    await saveChatRename();
                    return true;

                case 'save-prompt':
                    if (saveCustomPromptBtn) saveCustomPromptBtn.click();
                    return true;

                case 'manage-templates':
                    if (promptTemplatesModal) promptTemplatesModal.classList.remove('hidden');
                    return true;

                case 'prompt-tool':
                    showPromptTool();
                    return true;

                case 'random-theme':
                    handleRandomThemeSwitch();
                    return true;

                case 'template':
                    if (!arg) {
                        // Open templates modal as a fallback
                        if (promptTemplatesModal) promptTemplatesModal.classList.remove('hidden');
                        return true;
                    }
                    let template = promptTemplates.find(t => t.name.toLowerCase() === arg.toLowerCase()) || promptTemplates.find(t => t.name.toLowerCase().includes(arg.toLowerCase()));
                    if (template) {
                        customPromptInput.value = template.content;
                        saveCustomPromptBtn.click();
                        showCopyMessage(`Custom prompt set from template: "${template.name}"`, 'var(--accent-success)');
                    } else {
                        showError(`Template '${arg}' not found.`);
                    }
                    return true;

                case 'search':
                    if (!chatSearchInputContainer) return false;
                    if (!arg) {
                        chatSearchInputContainer.classList.remove('hidden');
                        chatSearchInput.focus();
                        return true;
                    }
                    chatSearchInputContainer.classList.remove('hidden');
                    chatSearchInput.value = arg;
                    highlightChatMatches(arg);
                    if (searchMatches.length > 0) {
                        currentMatchIndex = 0;
                        navigateChatMatch('next');
                    }
                    chatSearchInput.focus();
                    return true;

                default:
                    showError(`Unknown command: /${cmd}. Try /help for the quick guide.`);
                    return true;
            }
        }

        // Add event listener for the 'Enter' key on the chat input (supports slash commands)
        chatInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const userInput = chatInput.value.trim();
                if (userInput.startsWith('/')) {
                    // Command; let handler run
                    const handled = await handleSlashCommand(userInput);
                    if (handled) {
                        chatInput.value = '';
                        adjustChatInputHeight();
                        return;
                    }
                }
                sendChatBtn.click();
            }
        });

        // Open/close command palette or show inline suggestions when user begins typing a slash in the chat input
        chatInput.addEventListener('input', (e) => {
            const val = chatInput.value || '';
            if (val.startsWith('/') && !commandPaletteModal.classList.contains('hidden')) {
                // palette is already open: update it
                paletteOpenedFromChatInput = true;
                if (commandPaletteInput) { commandPaletteInput.value = val.slice(1); renderCommandPalette(commandPaletteInput.value); }
            } else if (val.startsWith('/') && commandPaletteModal.classList.contains('hidden')) {
                // show inline assistive suggestions rather than auto-opening the full palette
                renderInlineSuggestions();
            } else {
                // removed slash or not typing a slash-based command
                if (paletteOpenedFromChatInput && !val.startsWith('/')) {
                    closeCommandPalette();
                }
                closeInlineSuggestions();
            }
        });

        // --- Conversation Mode Functions (MODIFIED for Firebase) ---

        function updateVoiceDropdown() {
            availableVoices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('en')); // Filter for English voices
            voiceSelect.innerHTML = '<option value="">Default Voice</option>';
            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                voiceSelect.appendChild(option);
            });
            // Try to set previously selected voice
            if (selectedVoice) {
                voiceSelect.value = selectedVoice;
            } else {
                selectedVoice = null;
            }
        }

        function updatePersonalityDropdown() {
            personalitySelect.innerHTML = '';
            personalities.forEach(p => {
                const option = document.createElement('option');
                option.value = p.name;
                option.textContent = p.name;
                personalitySelect.appendChild(option);
            });
            // Try to set previously selected personality
            if (selectedPersonality && personalities.some(p => p.name === selectedPersonality)) {
                personalitySelect.value = selectedPersonality;
            } else {
                personalitySelect.value = "Standard";
                selectedPersonality = "Standard";
            }
        }
        
        function setSoundBlobState(state) {
            soundBlob.className = 'sound-blob'; // Reset classes
            if (state === 'listening') {
                soundBlob.classList.add('listening-animation');
            } else if (state === 'speaking') {
                soundBlob.classList.add('speaking-animation');
            } else {
                soundBlob.classList.add('idle-animation');
            }
        }

        voiceSelect.addEventListener('change', () => {
            const voiceName = voiceSelect.value;
            selectedVoice = availableVoices.find(v => v.name === voiceName) || null;
            if (currentUser) {
                saveUserSetting(CONVERSATION_VOICE_KEY, voiceName);
            }
        });

        personalitySelect.addEventListener('change', () => {
            selectedPersonality = personalitySelect.value;
            if (currentUser) {
                saveUserSetting(CONVERSATION_PERSONALITY_KEY, selectedPersonality);
            }
        });


        function startConversationMode() {
            if (!currentUser) {
                showError("Please sign in to use Conversation Mode.");
                return;
            }
            if (!SpeechRecognition || !window.speechSynthesis) {
                showError("Your browser doesn't fully support Web Speech APIs needed for Conversation Mode.");
                return;
            }
            isConversationModeActive = true;
            conversationModeOverlay.classList.remove('hidden'); 
            conversationModeOverlay.classList.add('active');
            document.body.style.overflow = 'hidden'; 
            
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
            }
            if (isVoiceInputActive && recognition) {
                recognition.stop();
            }

            // Ensure voice list is updated if it hasn't loaded yet
            if (availableVoices.length === 0) {
                 updateVoiceDropdown();
            }

            // Start listening for the user
            startConversationListening();
        }

        function stopConversationMode() {
            isConversationModeActive = false;
            conversationModeOverlay.classList.remove('active');
            setTimeout(() => {
                conversationModeOverlay.classList.add('hidden');
                document.body.style.overflow = ''; 
            }, 300); 

            if (isAiSpeakingInConversation) {
                window.speechSynthesis.cancel();
                isAiSpeakingInConversation = false;
            }
            if (isUserListeningInConversation && conversationSpeechRecognition) {
                conversationSpeechRecognition.stop();
                isUserListeningInConversation = false;
            }
            setSoundBlobState('idle');
            updateConversationStatus('Tap the button to start conversing!');
            clearConversationDisplay();
        }

        function startConversationListening() {
            if (!isConversationModeActive || isAiSpeakingInConversation || isUserListeningInConversation) return;

            window.speechSynthesis.cancel();

            conversationFinalTranscript = '';
            conversationInterimTranscript = '';
            clearConversationDisplay();

            try {
                conversationSpeechRecognition.start();
                updateConversationStatus('Listening...', 'listening');
                setSoundBlobState('listening');
            } catch (error) {
                if (error.name === 'InvalidStateError') {
                    conversationSpeechRecognition.stop();
                    setTimeout(() => { 
                        conversationSpeechRecognition.start();
                        updateConversationStatus('Listening...', 'listening');
                        setSoundBlobState('listening');
                    }, 100);
                } else {
                    console.error("Error starting conversation recognition:", error);
                    showError("Could not start microphone. Please check permissions.");
                    updateConversationStatus("Error starting microphone.", 'error');
                    setSoundBlobState('idle');
                }
            }
        }

        async function handleUserSpeechEnd(userText) {
            updateConversationStatus('Thinking...', 'thinking');
            setSoundBlobState('idle'); 

            if (!currentSessionId || !allChatSessions[currentSessionId]) {
                 await createNewChatSession(userText.substring(0, 50) || 'New Chat');
            }

            const currentSessionHistory = allChatSessions[currentSessionId].history;
            currentSessionHistory.push({ role: 'user', parts: [{ text: userText }] });
            appendChatMessage('user', userText); 
            await updateCurrentSessionHistory();

            updateConversationDisplay(`<span class="user-utterance">You: ${userText}</span>`);

            try {
                const payload = {
                    contents: currentSessionHistory,
                };
                const aiResponse = await callGeminiAPI(payload, selectedPersonality);

                currentSessionHistory.push({ role: 'model', parts: [{ text: aiResponse }] });
                appendChatMessage('ai', aiResponse); 
                await updateCurrentSessionHistory();

                startConversationSpeaking(aiResponse);

            } catch (error) {
                console.error("Error in conversation mode API call:", error);
                showError(`AI communication error: ${error.message}`);
                updateConversationStatus("AI communication error. Please try again.", 'error');
                currentSessionHistory.pop();
                await updateCurrentSessionHistory();
                setSoundBlobState('idle');
                setTimeout(startConversationListening, 2000);
            }
        }

        function updateConversationDisplay(text) {
            if (conversationDisplayTimeout) {
                clearTimeout(conversationDisplayTimeout);
            }
            conversationHistoryDisplay.innerHTML = `<p>${text}</p>`;
            conversationHistoryDisplay.scrollTop = conversationHistoryDisplay.scrollHeight;
            
            conversationDisplayTimeout = setTimeout(() => {
                clearConversationDisplay();
            }, 5000); 
        }

        function clearConversationDisplay() {
            if (conversationDisplayTimeout) {
                clearTimeout(conversationDisplayTimeout);
                conversationDisplayTimeout = null;
            }
            conversationHistoryDisplay.innerHTML = '';
        }


        function updateConversationStatus(message, state = 'idle') {
            conversationStatusText.textContent = message;
            conversationStatusText.classList.remove('listening-state', 'speaking-state', 'error-state');
            if (state === 'listening') {
                conversationStatusText.classList.add('listening-state');
            } else if (state === 'speaking') {
                conversationStatusText.classList.add('speaking-state');
            } else if (state === 'error') {
                conversationStatusText.classList.add('error-state');
            }
        }
        
        function handleAiSpeechEnd() {
            if (!isConversationModeActive) return;

            isAiSpeakingInConversation = false;
            updateConversationStatus('Listening...', 'listening');
            setSoundBlobState('listening');
            startConversationListening(); 
        }

        // NEW: Function to update the custom prompt button's appearance (used to refresh UI after Firebase load/save)
        function updateCustomPromptButtonState() {
            if (isCustomPromptActive && customPromptText.trim() !== '') {
                // F2: Activate visual indicator
                if (customPromptIndicator) {
                    customPromptIndicator.classList.remove('hidden');
                    // Add a subtle pulsating glow effect via dynamic CSS style
                    customPromptIndicator.style.boxShadow = `0 0 5px var(--accent-primary), 0 0 10px var(--accent-primary)`;
                    customPromptIndicator.style.animation = 'prompt-pulse 1.5s infinite alternate';
                }

                toggleCustomPromptBtn.classList.remove('bg-secondary', 'text-primary');
                toggleCustomPromptBtn.classList.add('glow-button');
                toggleCustomPromptBtn.style.backgroundColor = 'var(--accent-primary)';
                toggleCustomPromptBtn.style.color = 'black';
                toggleCustomPromptBtn.innerHTML = `<span data-lucide="sparkles" class="w-5 h-5 mr-2"></span> Custom Prompt Active`;
                customPromptStatus.textContent = "Custom prompt is active. This overrides personality settings.";
            } else {
                // F2: Deactivate visual indicator
                if (customPromptIndicator) {
                    customPromptIndicator.classList.add('hidden');
                    customPromptIndicator.style.boxShadow = 'none';
                    customPromptIndicator.style.animation = 'none';
                }

                toggleCustomPromptBtn.classList.remove('glow-button');
                toggleCustomPromptBtn.classList.add('bg-secondary', 'text-primary');
                toggleCustomPromptBtn.style.backgroundColor = 'var(--bg-secondary)';
                toggleCustomPromptBtn.style.color = 'var(--text-primary)';
                toggleCustomPromptBtn.innerHTML = `<span data-lucide="sparkles" class="w-5 h-5 mr-2"></span> Set Custom Prompt`;
                customPromptStatus.textContent = "No custom prompt set or active.";
            }
            createIcons(); 
            togglePersonalitySelector();
        }

        // NEW: Function to toggle personality selector's disabled state
        function togglePersonalitySelector() {
            if (personalitySelect) {
                if (isCustomPromptActive && customPromptText.trim() !== '') {
                    personalitySelect.disabled = true;
                    personalitySelect.title = "Personality is overridden by custom prompt.";
                } else {
                    personalitySelect.disabled = false;
                    personalitySelect.title = "";
                }
            }
        }

        // Event listener for Save Custom Prompt button (MODIFIED for Firebase)
        saveCustomPromptBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to save custom prompts.");
                return;
            }
            const newPrompt = customPromptInput.value.trim();
            customPromptText = newPrompt;
            isCustomPromptActive = (newPrompt !== ''); 
            
            saveUserSetting(CUSTOM_PROMPT_TEXT_KEY, customPromptText);
            saveUserSetting(CUSTOM_PROMPT_ACTIVE_KEY, isCustomPromptActive);

            updateCustomPromptButtonState();
            customPromptModal.classList.add('hidden'); 
            showCopyMessage(isCustomPromptActive ? 'Custom prompt saved and activated!' : 'Custom prompt cleared and disabled.', isCustomPromptActive ? `var(--accent-success)` : `var(--accent-error)`);
        });

        // Event listener for Clear Custom Prompt button (MODIFIED for Firebase)
        clearCustomPromptBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to manage custom prompts.");
                return;
            }
            customPromptInput.value = ''; 
            customPromptText = '';
            isCustomPromptActive = false;
            
            saveUserSetting(CUSTOM_PROMPT_TEXT_KEY, customPromptText);
            saveUserSetting(CUSTOM_PROMPT_ACTIVE_KEY, isCustomPromptActive);
            
            updateCustomPromptButtonState();
            customPromptModal.classList.add('hidden'); 
            showCopyMessage('Custom prompt cleared and disabled!', `var(--accent-error)`);
        });

        // Event listener for Cancel button (No change)
        cancelCustomPromptBtn.addEventListener('click', () => {
            customPromptModal.classList.add('hidden'); 
        });
        
        // Event listener for Custom Prompt Toggle button
        toggleCustomPromptBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to use custom prompts.");
                return;
            }
            customPromptInput.value = customPromptText;
            customPromptModal.classList.remove('hidden'); 
        });


        // --- NEW: Prompt Templates Management Functions (MODIFIED for Firebase) ---

        function clearTemplateForm() {
            templateNameInput.value = '';
            templateContentInput.value = '';
            editingTemplateId = null;
            saveTemplateBtn.innerHTML = `<span data-lucide="plus" class="w-5 h-5 mr-2"></span> Save Template`;
            createIcons();
            templateNameInput.focus();
        }

        function renderPromptTemplates() {
            savedTemplatesList.innerHTML = '';
            if (promptTemplates.length === 0) {
                const emptyMsg = document.createElement('li');
                emptyMsg.classList.add('text-center', 'text-sm', 'p-4');
                emptyMsg.style.color = 'var(--text-secondary)';
                emptyMsg.textContent = 'No templates saved yet. Add one above!';
                savedTemplatesList.appendChild(emptyMsg);
                return;
            }

            promptTemplates.forEach(template => {
                const li = document.createElement('li');
                li.classList.add('template-item');
                li.dataset.templateId = template.id;
                li.innerHTML = `
                    <div class="template-item-header">
                        <span class="template-item-name" title="${template.name}">${template.name}</span>
                    </div>
                    <p class="template-item-content">${template.content.substring(0, 150) + (template.content.length > 150 ? '...' : '')}</p>
                    <div class="template-item-actions">
                        <button class="use-btn" title="Use as Custom Prompt">
                            <span data-lucide="check-circle" class="w-4 h-4"></span> Use
                        </button>
                        <button class="edit-btn" title="Edit Template">
                            <span data-lucide="edit" class="w-4 h-4"></span> Edit
                        </button>
                        <button class="delete-btn" title="Delete Template">
                            <span data-lucide="trash-2" class="w-4 h-4"></span> Delete
                        </button>
                    </div>
                `;
                savedTemplatesList.appendChild(li);
            });
            createIcons(); 
        }

        async function addOrUpdateTemplate() {
            if (!currentUser) {
                showError("Please sign in to save prompt templates.");
                return;
            }
            const name = templateNameInput.value.trim();
            const content = templateContentInput.value.trim();

            if (!name) {
                showError('Template name cannot be empty.');
                return;
            }
            if (!content) {
                showError('Template content cannot be empty.');
                return;
            }

            if (editingTemplateId) {
                const index = promptTemplates.findIndex(t => t.id === editingTemplateId);
                if (index !== -1) {
                    promptTemplates[index] = { ...promptTemplates[index], name, content };
                    showCopyMessage('Template updated successfully!', `var(--accent-success)`);
                }
            } else {
                const newId = generateUniqueId();
                promptTemplates.push({ id: newId, name, content });
                showCopyMessage('Template saved successfully!', `var(--accent-success)`);
            }
            await savePromptTemplatesToDB();
            renderPromptTemplates();
            clearTemplateForm();
        }

        function useTemplate(templateId) {
            if (!currentUser) {
                showError("Please sign in to use templates.");
                return;
            }
            const template = promptTemplates.find(t => t.id === templateId);
            if (template) {
                customPromptInput.value = template.content; 
                saveCustomPromptBtn.click(); // Trigger the save/activate logic
                promptTemplatesModal.classList.add('hidden'); 
                showCopyMessage(`Custom prompt set from template: "${template.name}"`, `var(--accent-success)`);
            }
        }

        function editTemplate(templateId) {
            const template = promptTemplates.find(t => t.id === templateId);
            if (template) {
                templateNameInput.value = template.name;
                templateContentInput.value = template.content;
                editingTemplateId = template.id;
                saveTemplateBtn.innerHTML = `<span data-lucide="save" class="w-5 h-5 mr-2"></span> Update Template`;
                createIcons();
                templateNameInput.focus();
                promptTemplatesModal.querySelector('div:first-child').scrollTop = 0; 
            }
        }

        async function deleteTemplate(templateId) {
            if (!currentUser) return;
            const template = promptTemplates.find(t => t.id === templateId);
            if (!template) return;

            if (confirm(`Are you sure you want to delete the template "${template.name}"?`)) {
                promptTemplates = promptTemplates.filter(t => t.id !== templateId);
                await savePromptTemplatesToDB();
                renderPromptTemplates();
                showCopyMessage('Template deleted successfully!', `var(--accent-error)`);

                if (isCustomPromptActive && customPromptText === template.content) {
                    clearCustomPromptBtn.click(); 
                    showCopyMessage('Active custom prompt cleared as its template was deleted.', `var(--accent-error)`);
                }
                
                if (editingTemplateId === templateId) {
                    clearTemplateForm();
                }
            }
        }

        // --- Event Listeners for Prompt Templates Modal ---

        manageTemplatesBtn.addEventListener('click', () => {
            if (!currentUser) {
                showError("Please sign in to manage prompt templates.");
                return;
            }
            promptTemplatesModal.classList.remove('hidden');
            renderPromptTemplates(); 
            clearTemplateForm(); 
        });

        cancelTemplateModalBtn.addEventListener('click', () => {
            promptTemplatesModal.classList.add('hidden');
            clearTemplateForm();
        });

        clearTemplateFormBtn.addEventListener('click', (event) => {
            event.preventDefault(); 
            clearTemplateForm();
            showCopyMessage('Template form cleared.', 'var(--text-secondary)');
        });

        saveTemplateBtn.addEventListener('click', addOrUpdateTemplate);

        savedTemplatesList.addEventListener('click', (event) => {
            const target = event.target;
            const listItem = target.closest('.template-item');
            if (!listItem) return;

            const templateId = listItem.dataset.templateId;

            if (target.closest('.use-btn')) {
                useTemplate(templateId);
            } else if (target.closest('.edit-btn')) {
                editTemplate(templateId);
            } else if (target.closest('.delete-btn')) {
                deleteTemplate(templateId);
            }
        });


        // --- NEW: Data Management Button Event Listeners (MODIFIED for Firebase) ---
        deleteAllChatsBtn.addEventListener('click', async () => {
            if (!currentUser) {
                showError("Please sign in to delete chats.");
                return;
            }
            if (confirm('Are you absolutely sure you want to delete ALL previous chat sessions? This action cannot be undone.')) {
                
                if (isSpeaking) { window.speechSynthesis.cancel(); }
                if (isVoiceInputActive && recognition) { recognition.stop(); }
                if (isConversationModeActive) { stopConversationMode(); }
                
                const chatIds = Object.keys(allChatSessions);
                const deletePromises = chatIds.map(id => deleteChatFromDB(id));

                try {
                    await Promise.all(deletePromises);
                    allChatSessions = {}; 
                    currentSessionId = null;
                    createNewChatSession('New Chat'); 
                    showCopyMessage('All chat sessions deleted!', 'var(--accent-error)');
                } catch (e) {
                    showError("Error deleting all chats. Check console.");
                    console.error(e);
                }
            }
        });

        clearLocalStorageBtn.addEventListener('click', async () => {
            if (confirm('WARNING: Are you absolutely sure you want to clear ALL browser site data (Local Storage, IndexedDB, Caches, Session Storage, and Service Workers)? Your chat history (saved in the cloud) will NOT be affected, but you will need to re-login and re-select your preferred theme.')) {
                
                if (isSpeaking) { window.speechSynthesis.cancel(); }
                if (isVoiceInputActive && recognition) { recognition.stop(); }
                if (isConversationModeActive) { stopConversationMode(); }
                
                // 1. Clear Local and Session Storage
                localStorage.clear(); 
                sessionStorage.clear(); // Clear session storage as well

                try {
                    // 2. Clear IndexedDB (requires listing and deleting databases)
                    if (window.indexedDB) {
                        const dbs = await window.indexedDB.databases();
                        dbs.forEach(dbItem => {
                            window.indexedDB.deleteDatabase(dbItem.name);
                            console.log(`IndexedDB database deleted: ${dbItem.name}`);
                        });
                    }

                    // 3. Clear Cache Storage (e.g., from PWA service worker)
                    if (window.caches) {
                        const keys = await caches.keys();
                        await Promise.all(keys.map(key => caches.delete(key)));
                        console.log('All caches cleared.');
                    }
                    
                    // 4. Unregister Service Workers
                    if ('serviceWorker' in navigator) {
                        const registrations = await navigator.serviceWorker.getRegistrations();
                        registrations.forEach(registration => {
                            registration.unregister();
                            console.log('Service Worker unregistered:', registration.scope);
                        });
                    }

                    showCopyMessage('Site data cleared successfully! Reloading...', 'var(--accent-error)');
                    
                    // Delay slightly to ensure asynchronous deletions start before reloading
                    setTimeout(() => {
                        location.reload(true); // true forces a reload from server, mimicking a hard clear
                    }, 100); 

                } catch (e) {
                    showError("Error clearing some site data. Reloading now.");
                    console.error("Full site data clear error:", e);
                    location.reload(true); 
                }
            }
        });
        
        function setChatUIEnabled(enabled) {
            sendChatBtn.disabled = !enabled;
            chatInput.disabled = !enabled;
            chatInput.placeholder = enabled ? "Type your message or ask a question..." : "Please sign in to start chatting.";
            newChatButton.disabled = !enabled;
            toggleCustomPromptBtn.disabled = !enabled;
            manageTemplatesBtn.disabled = !enabled;
            conversationModeToggleBtn.disabled = !enabled;
            exportMarkdownBtn.disabled = !enabled; // Disable export if not logged in
            
            if (!enabled) {
                 updateButtonIcon(voiceInputBtn, 'mic-off', 'w-5 h-5');
                 voiceInputBtn.disabled = true;
            } else {
                 updateButtonIcon(voiceInputBtn, 'mic', 'w-5 h-5');
                 voiceInputBtn.disabled = false;
            }
        }
        
        async function initializeAuthenticatedApp() {
            if (!currentUser) return;

            setChatUIEnabled(true);
            isAuthSetupComplete = true;

            // 1. Load user settings (themes, model, custom prompt, API key)
            await loadUserSettings();

            // 2. Load chat sessions (Does not automatically switch sessions now)
            await loadAllChatsFromDB();
            
            // 3. Force creation of a brand new session every time the app initializes/user logs in
            await createNewChatSession('Welcome Chat'); // THIS FORCES A NEW CHAT
            
            // 4. Ensure voice list and personality dropdowns are updated
            updateVoiceDropdown();
            updatePersonalityDropdown(); 

            chatInput.focus();
            
            showCopyMessage(`Welcome, ${currentUser.email || 'user'}! Data loaded from cloud.`, 'var(--accent-primary)');
        }

        // --- Settings Toggle Event Listener (For Sidebar Redesign) ---
        if (toggleSettingsBtn) {
            const toggleSettingsVisibility = () => {
                // Check if currently collapsed (maxHeight is 0 or initial state)
                const isHidden = settingsContent.style.maxHeight === '0px' || settingsContent.style.maxHeight === '';
                if (isHidden) {
                    // Open: Set max-height to scroll height
                    settingsContent.style.maxHeight = settingsContent.scrollHeight + 'px';
                    settingsChevron.style.transform = 'rotate(180deg)';
                } else {
                    // Close: Set height temporarily before collapsing to ensure smooth transition
                    settingsContent.style.maxHeight = settingsContent.scrollHeight + 'px';
                    // Force reflow and collapse
                    setTimeout(() => { settingsContent.style.maxHeight = '0px'; }, 10);
                    settingsChevron.style.transform = 'rotate(0deg)';
                }
                createIcons();
            };
            
            toggleSettingsBtn.addEventListener('click', toggleSettingsVisibility);
            
            // Initial setup: Ensure it starts collapsed
            // Note: The HTML must have the `hidden` class removed if using this JS logic
            settingsContent.style.maxHeight = '0px'; 
            settingsContent.classList.remove('hidden'); // Ensure CSS transition controls visibility
            settingsChevron.style.transform = 'rotate(0deg)';
        }

        // Function to select a random theme and mode
        function getRandomTheme() {
            // Get all theme options from the selector
            const options = Array.from(appThemeSelect.options);
            const themeNames = options.map(opt => opt.value).filter(name => name); // Filter out empty values
            
            if (themeNames.length === 0) return null;

            const randomIndex = Math.floor(Math.random() * themeNames.length);
            const randomThemeName = themeNames[randomIndex];
            
            // Randomly choose dark or light mode
            const randomMode = Math.random() < 0.5 ? 'dark' : 'light';
            
            return { name: randomThemeName, mode: randomMode };
        }

        // Event listener for the Random Theme button
        // NEW: Helper function that uses the existing getRandomTheme logic
        function handleRandomThemeSwitch() {
            const randomTheme = getRandomTheme();
            if (randomTheme) {
                applyTheme(randomTheme.name, randomTheme.mode);
                darkModeToggle.checked = (randomTheme.mode === 'dark'); 
                appThemeSelect.value = randomTheme.name;
                
                // Save settings to Firebase if logged in (optional, but good practice)
                if (currentUser) {
                    saveUserSetting('themeName', randomTheme.name);
                    saveUserSetting('themeMode', randomTheme.mode);
                }
            }
        }
        // Ensure the existing randomThemeBtn uses this helper
        if (randomThemeBtn) {
            randomThemeBtn.addEventListener('click', handleRandomThemeSwitch);
        }
        
        // --- Auto Theme Switching Functions ---

        function startAutoThemeSwitch(delaySeconds) {
            // 1. Stop any existing interval
            if (autoThemeInterval !== null) {
                stopAutoThemeSwitch();
            }

            // 2. Immediately switch the first theme
            handleRandomThemeSwitch(); 

            // 3. Set the interval (delaySeconds * 1000 milliseconds)
            autoThemeInterval = setInterval(handleRandomThemeSwitch, delaySeconds * 1000);

            // 4. Update UI to reflect active state
            toggleAutoThemeBtn.innerHTML = `<span data-lucide="power-off" class="w-5 h-5 mr-2"></span> Stop Auto-Switch`;
            
            // Style update: switch to error color to indicate active, running process
            toggleAutoThemeBtn.classList.remove('glow-button');
            toggleAutoThemeBtn.classList.add('glow-error-button');
            toggleAutoThemeBtn.style.backgroundColor = 'var(--accent-error)';
            toggleAutoThemeBtn.style.boxShadow = '0 0 10px var(--accent-error)';
            
            showCopyMessage(`Auto theme switching started (every ${delaySeconds}s)`, 'var(--accent-primary)');
            createIcons();
        }

        function stopAutoThemeSwitch() {
            if (autoThemeInterval !== null) {
                clearInterval(autoThemeInterval);
                autoThemeInterval = null;

                // Update UI to reflect idle state
                toggleAutoThemeBtn.innerHTML = `<span data-lucide="zap" class="w-5 h-5 mr-2"></span> Start Auto-Switch`;
                
                // Style update: revert to primary accent color
                toggleAutoThemeBtn.classList.remove('glow-error-button');
                toggleAutoThemeBtn.classList.add('glow-button');
                toggleAutoThemeBtn.style.backgroundColor = 'var(--accent-primary)';
                toggleAutoThemeBtn.style.boxShadow = '0 0 10px var(--accent-primary)';

                showCopyMessage('Auto theme switching stopped.', 'var(--accent-error)');
                createIcons();
            }
        }

        // --- NEW: Markdown Export Feature Functions ---

        function chatToMarkdown(session) {
            if (!session || !session.history) return '';

            let markdown = `# Chat Session: ${session.title}\n\n`;
            markdown += `*Generated on ${new Date().toLocaleString()}*\n\n---\n\n`;

            const currentSessionHistory = allChatSessions[session.id].history;
            
            // Note: This relies on the raw parts data saved in the session history,
            // which contains the full Gemini response, often already in Markdown format.
            currentSessionHistory.forEach(msg => {
                let text = '';
                let attachments = [];

                msg.parts.forEach(part => {
                    if (part.text) {
                        text += part.text + '\n';
                    } else if (part.inlineData) {
                        attachments.push(`[Attachment: ${part.inlineData.mimeType.split('/').pop()}]`);
                    }
                });

                text = text.trim();

                if (msg.role === 'user') {
                    markdown += `##  User\n\n`;
                    markdown += text;
                    if (attachments.length > 0) {
                        markdown += `\n*Attachments: ${attachments.join(', ')}*`;
                    }
                    markdown += `\n\n---\n\n`;
                } else if (msg.role === 'model') {
                    markdown += `##  AI Assistant\n\n`;
                    // For AI responses, the text part should already be clean Markdown.
                    markdown += text;
                    markdown += `\n\n---\n\n`;
                }
            });

            return markdown;
        }

        function switchMarkdownTab(tabName) {
            // Reset button styles
            markdownTabEdit.style.borderColor = 'transparent';
            markdownTabEdit.style.color = 'var(--text-secondary)';
            markdownTabPreview.style.borderColor = 'transparent';
            markdownTabPreview.style.color = 'var(--text-secondary)';

            markdownExportInput.classList.add('hidden');
            markdownExportPreview.classList.add('hidden');

            if (tabName === 'edit') {
                markdownExportInput.classList.remove('hidden');
                markdownTabEdit.style.borderColor = 'var(--accent-primary)';
                markdownTabEdit.style.color = 'var(--accent-primary)';
            } else if (tabName === 'preview') {
                const markdownText = markdownExportInput.value;
                
                // Clear and render the markdown content
                markdownExportPreview.innerHTML = `<div class="markdown-content">${marked.parse(markdownText)}</div>`;            

                markdownExportPreview.classList.remove('hidden');
                markdownTabPreview.style.borderColor = 'var(--accent-primary)';
                markdownTabPreview.style.color = 'var(--accent-primary)';
            }
            createIcons();
        }

        function openMarkdownExportModal() {
            if (!currentUser || !currentSessionId || !allChatSessions[currentSessionId]) {
                showError("No active chat session found to export. Start a chat first.");
                return;
            }

            const currentSession = allChatSessions[currentSessionId];
            
            if (currentSession.history.length <= 1) {
                showError("Chat history is empty or only contains the initial greeting. Send a message first.");
                return;
            }

            const markdownContent = chatToMarkdown(currentSession);

            markdownExportInput.value = markdownContent;
            markdownExportModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; 
            
            // Default to edit tab
            switchMarkdownTab('edit');
        }

        function closeMarkdownExportModal() {
            markdownExportModal.classList.add('hidden');
            document.body.style.overflow = '';
        }

        function downloadMarkdownFile() {
            const content = markdownExportInput.value;
            const currentSession = allChatSessions[currentSessionId];
            const filename = `${currentSession.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_export.md`;

            const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showCopyMessage('Markdown file downloaded!', 'var(--accent-success)');
            closeMarkdownExportModal();
        }

        // --- NEW: Attachment Editor Logic ---

        // Helper function to convert base64 back to text
        function base64ToText(base64) {
            try {
                return decodeURIComponent(atob(base64).split('').map(function(c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
            } catch (e) {
                // If decoding fails (e.g., if it's binary data not proper text)
                console.error("Failed to decode base64 to text:", e);
                return "--- ERROR DECODING ATTACHMENT TEXT ---";
            }
        }
        
        // Helper function to create a new File object and new base64 string from updated text
        function updateAttachmentData(index, newText, newFilename) { // MODIFIED ARGUMENTS
            if (index < 0 || index >= chatAttachments.length) return false;

            const oldAttachment = chatAttachments[index];
            const mimeType = oldAttachment.mimeType;
            const oldFilename = oldAttachment.name;
            
            // Ensure filename has an extension if it didn't before (simple check)
            let filename = newFilename.trim() || oldFilename;
            if (filename !== oldFilename && filename.indexOf('.') === -1) {
                // Try to infer extension from old name or mime type, default to .txt
                const inferredExt = oldFilename.split('.').pop() || mimeType.split('/').pop() || 'txt';
                if (inferredExt !== filename) {
                    filename += `.${inferredExt}`;
                }
            }

            // 1. Create new Blob/File from the new text
            const newBlob = new Blob([newText], { type: mimeType });
            // Crucially, we use the new `filename` here
            const newFile = new File([newBlob], filename, { type: mimeType });

            // 2. Generate new Base64 string synchronously
            const reader = new FileReader();
            reader.readAsDataURL(newFile);
            reader.onloadend = () => {
                const newBase64Data = reader.result.split(',')[1];

                // 3. Update the attachment list
                chatAttachments[index] = {
                    file: newFile,
                    mimeType: mimeType,
                    data: newBase64Data,
                    name: filename // Save the new filename
                };

                displayChatAttachments();
                showCopyMessage(`Attachment "${filename}" updated!`, 'var(--accent-primary)');
            };

            return true;
        }

        function openAttachmentEditor(index) {
            if (index < 0 || index >= chatAttachments.length) return;

            const attachment = chatAttachments[index];
            editingAttachmentIndex = index;

            // Use the input field for the filename
            attachmentEditorFilenameInput.value = attachment.name;

            // Decode the Base64 data back to raw text for editing
            const decodedText = base64ToText(attachment.data);
            attachmentEditorInput.value = decodedText;

            attachmentEditorModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden'; 
            attachmentEditorFilenameInput.focus(); // Focus on filename first
        }

        function closeAttachmentEditor() {
            attachmentEditorModal.classList.add('hidden');
            document.body.style.overflow = '';
            editingAttachmentIndex = -1;
            chatInput.focus();
        }

        // --- Event Delegation for Edit Button ---
        chatAttachmentsPreviewContainer.addEventListener('click', (event) => {
            const editBtn = event.target.closest('.edit-attachment-btn');
            if (editBtn) {
                event.stopPropagation();
                const index = parseInt(editBtn.dataset.index);
                openAttachmentEditor(index);
            }
            
            // Existing logic for removeBtn remains here
            const removeBtn = event.target.closest('.remove-attachment-btn');
            if (removeBtn) {
                const attachmentDiv = removeBtn.closest('[data-index]');
                if (attachmentDiv) {
                    const index = parseInt(attachmentDiv.dataset.index);
                    chatAttachments.splice(index, 1);
                    displayChatAttachments();
                    chatInput.focus();
                }
            }
        });

        // --- Editor Modal Event Listeners ---

        cancelEditorBtn.addEventListener('click', closeAttachmentEditor);

        saveEditorBtn.addEventListener('click', () => {
            const newText = attachmentEditorInput.value;
            const newFilename = attachmentEditorFilenameInput.value; // GET NEW FILENAME
            
            if (editingAttachmentIndex !== -1) {
                // Pass both new text and new filename
                updateAttachmentData(editingAttachmentIndex, newText, newFilename); 
            }
            closeAttachmentEditor();
        });
        
        // Allow Ctrl+S or Cmd+S to save and close the editor
        attachmentEditorInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveEditorBtn.click();
            }
        });

        // --- Final Initializations & Event Hooks ---

        // NEW: Developer Console Events (Request 3)
        if (developerConsoleBtn) developerConsoleBtn.addEventListener('click', openDeveloperConsole);
        if (closeConsoleModalBtn) closeConsoleModalBtn.addEventListener('click', closeDeveloperConsole);
        if (clearConsoleBtn) clearConsoleBtn.addEventListener('click', clearDeveloperConsole);

        // NEW: Summarize Context Events (Request 2)
        if (summarizeContextBtn) summarizeContextBtn.addEventListener('click', handleSummarizeChat);

        // AUTH Event Listeners
        if (authActionBtn) authActionBtn.addEventListener('click', handleAuthAction);
        if (googleSignInBtn) googleSignInBtn.addEventListener('click', handleGoogleSignIn);
        if (authToggleLink) authToggleLink.addEventListener('click', handleAuthToggle);
        if (signOutButton) signOutButton.addEventListener('click', handleSignOut);

        // Conversation Mode Event Listeners
        if (conversationModeToggleBtn) conversationModeToggleBtn.addEventListener('click', startConversationMode);
        if (conversationModeCloseBtn) conversationModeCloseBtn.addEventListener('click', stopConversationMode);
        if (conversationMicBtn) conversationMicBtn.addEventListener('click', () => {
            if (isUserListeningInConversation && conversationSpeechRecognition) {
                conversationSpeechRecognition.stop();
            } else {
                startConversationListening();
            }
        });
        
        // NEW: Markdown Export Event Listeners
        if (exportMarkdownBtn) exportMarkdownBtn.addEventListener('click', openMarkdownExportModal);
        if (closeMarkdownModalBtn) closeMarkdownModalBtn.addEventListener('click', closeMarkdownExportModal);
        if (downloadMarkdownBtn) downloadMarkdownBtn.addEventListener('click', downloadMarkdownFile);
        if (markdownTabEdit) markdownTabEdit.addEventListener('click', () => switchMarkdownTab('edit'));
        if (markdownTabPreview) markdownTabPreview.addEventListener('click', () => switchMarkdownTab('preview'));
        if (copyMarkdownBtn) copyMarkdownBtn.addEventListener('click', () => {
            copyToClipboard(markdownExportInput.value);
            closeMarkdownExportModal();
            showCopyMessage('Full chat Markdown copied to clipboard!', 'var(--accent-primary)');
        }); // <<< NEW LINE

        // --- Scroll Jump Button Logic ---
        if (jumpToTopBtn && jumpToBottomBtn) {
            jumpToTopBtn.addEventListener('click', () => {
                chatHistoryDiv.scrollTo({ top: 0, behavior: 'smooth' });
            });

            jumpToBottomBtn.addEventListener('click', () => {
                chatHistoryDiv.scrollTo({ top: chatHistoryDiv.scrollHeight, behavior: 'smooth' });
            });
        }
        
        // --- Code Block Jump Button Logic ---
        if (jumpCodePrevBtn && jumpCodeNextBtn) {
            jumpCodePrevBtn.addEventListener('click', () => jumpToCodeBlock('prev'));
            jumpCodeNextBtn.addEventListener('click', () => jumpToCodeBlock('next'));
        }

        // --- Chat Search Event Listeners ---
        findChatBtn.addEventListener('click', () => {
            const isHidden = chatSearchInputContainer.classList.toggle('hidden');
            if (!isHidden) {
                chatSearchInput.focus();
                // Ensure search is run immediately if there is content
                if (chatSearchInput.value.trim().length > 2) {
                     highlightChatMatches(chatSearchInput.value.trim());
                     navigateChatMatch('next');
                }
            } else {
                clearChatSearch();
            }
        });

        chatSearchCloseBtn.addEventListener('click', () => {
            chatSearchInputContainer.classList.add('hidden');
            chatSearchInput.value = '';
            clearChatSearch();
        });

        chatSearchInput.addEventListener('input', () => {
            const query = chatSearchInput.value.trim();
            if (query.length > 2) {
                const count = highlightChatMatches(query);
                if (count > 0) {
                    navigateChatMatch('next');
                }
            } else {
                clearChatSearch();
            }
        });

        chatSearchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (searchMatches.length > 0) {
                    navigateChatMatch(e.shiftKey ? 'prev' : 'next');
                } else if (chatSearchInput.value.trim().length > 2) {
                    // Attempt to re-run the search if Enter is pressed but no matches exist (e.g. from keydown)
                    const count = highlightChatMatches(chatSearchInput.value.trim());
                    if (count > 0) {
                        navigateChatMatch('next');
                    }
                }
            }
        });

        chatSearchNextBtn.addEventListener('click', () => navigateChatMatch('next'));
        chatSearchPrevBtn.addEventListener('click', () => navigateChatMatch('prev'));

        // Global shortcut support (Ctrl+F or Cmd+F)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'f' && !markdownExportModal.classList.contains('active')) {
                e.preventDefault();
                chatSearchInputContainer.classList.remove('hidden');
                chatSearchInput.focus();
                // Re-run search if the box was already open but the text was cleared
                if (chatSearchInput.value.trim() !== '') {
                    highlightChatMatches(chatSearchInput.value.trim());
                    navigateChatMatch('next');
                }
            }
        });

        // NEW: Auto Theme Toggle Event Listener
        if (toggleAutoThemeBtn) {
            toggleAutoThemeBtn.addEventListener('click', () => {
                if (!currentUser) {
                    showError("Please sign in to save your theme settings across sessions.");
                }
                
                if (autoThemeInterval !== null) {
                    stopAutoThemeSwitch();
                } else {
                    let delay = parseInt(autoThemeDelayInput.value) || 10;
                    delay = Math.max(5, delay); // Enforce a minimum delay of 5 seconds
                    autoThemeDelayInput.value = delay;
                    startAutoThemeSwitch(delay);
                }
            });
        }

        // --- NEW HEADER DROPDOWN JS ---

        document.addEventListener('DOMContentLoaded', () => {
            const mobileMoreActionsBtn = document.getElementById('mobile-more-actions-btn');
            const mobileActionDropdownMenu = document.getElementById('mobile-action-dropdown-menu');

            if (mobileMoreActionsBtn && mobileActionDropdownMenu) {
                
                // 1. Toggle the dropdown visibility
                mobileMoreActionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    mobileActionDropdownMenu.classList.toggle('hidden');
                });

                // 2. Close the dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!mobileMoreActionsBtn.contains(e.target) && !mobileActionDropdownMenu.contains(e.target)) {
                        mobileActionDropdownMenu.classList.add('hidden');
                    }
                });

                // 3. Attach click handlers for the mobile buttons
                const mobileButtons = [
                    { id: 'developer-console-btn-mobile', handler: openDeveloperConsole },
                    { id: 'summarize-context-btn-mobile', handler: handleSummarizeChat },
                    { id: 'export-markdown-btn-mobile', handler: openMarkdownExportModal }
                ];

                mobileButtons.forEach(btnInfo => {
                    const button = document.getElementById(btnInfo.id);
                    if (button) {
                        button.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            // Close the dropdown immediately
                            mobileActionDropdownMenu.classList.add('hidden'); 
                            // Call the shared handler function
                            btnInfo.handler();
                        });
                    }
                });
            }
        });

        // --- Sidebar Chat Search Event Listener ---
        if (sidebarChatSearch) {
            sidebarChatSearch.addEventListener('input', (e) => {
                // Clear main chat search when sidebar search is active
                chatSearchInputContainer.classList.add('hidden');
                chatSearchInput.value = '';
                clearChatSearch();
                
                renderSidebarChats(e.target.value);
            });
        }

        // Listen for enter press on auth form
        authPassword.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleAuthAction();
            }
        });
        
        // --- Prompt Tool Event Handlers (Request 4) ---
        
        promptToolCancelBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            hidePromptTool();
            chatInput.focus(); 
            // The user chose to send the original draft, so the tool just hides.
        });

        promptToolAcceptBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            hidePromptTool();

            if (!currentUser || !userApiKey) {
                showError("Please sign in and ensure an API key is active to use prompt enhancement.");
                return;
            }
            
            const userDraft = chatInput.value.trim();
            if (userDraft.length === 0) return;

            // 1. Show loading state on the main input button
            const originalIconHtml = sendChatBtn.innerHTML;
            sendChatBtn.disabled = true;
            sendChatBtn.innerHTML = `<span data-lucide="loader-2" class="w-5 h-5 animate-spin"></span>`;
            createIcons();

            try {
                const enhancedPrompt = await generateStructuredPrompt(userDraft, chatAttachments);
                
                // 2. Update the chat input with the enhanced prompt
                chatInput.value = enhancedPrompt;
                chatInput.dataset.initialText = enhancedPrompt;
                adjustChatInputHeight();
                
                showCopyMessage("Prompt successfully enhanced! Review and send.", "var(--accent-success)");
                chatInput.focus();

            } finally {
                // 3. Restore send button state
                sendChatBtn.innerHTML = originalIconHtml;
                sendChatBtn.disabled = false;
                createIcons();
            }
        });


        // Core Firebase Authentication Listener
        auth.onAuthStateChanged(user => {
            handleAuthStateChange(user);
        });

        // --- Rename Chat Modal Event Listeners ---
        saveRenameChatBtn.addEventListener('click', saveChatRename);

        cancelRenameChatBtn.addEventListener('click', () => {
            renameChatModal.classList.add('hidden');
            document.body.style.overflow = '';
            renamingSessionId = null;
        });

        autoRenameChatBtn.addEventListener('click', handleAutoRename);

        renameChatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveRenameChatBtn.click();
            }
        });

        window.addEventListener('load', () => {
            createIcons();
            
            // Initialize model dropdown early, even before auth, so the settings modal works
            updateModelDropdown(); 
            updatePersonalityDropdown();
            
            // Initially disable UI until auth state is confirmed
            setChatUIEnabled(false); 
            
            // This is needed for the onvoiceschanged event to fire, populating the dropdowns
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                 window.speechSynthesis.onvoiceschanged = updateVoiceDropdown;
            }
            
            adjustChatInputHeight(); 
            
            // Initial call to ensure code block visibility is correct (likely hidden if chat is empty)
            collectCodeBlocks(); 

            // --- Tooltip Manager Setup ---
            // Attach the tooltip manager to the entire body using delegation
            document.body.addEventListener('mouseover', (e) => {
                if (e.target.closest('[data-help-content]')) {
                    showGlobalTooltip(e);
                } else {
                    hideGlobalTooltip();
                }
            });

            // Update the tooltip position while moving the mouse for fluid placement
            document.body.addEventListener('mousemove', (e) => {
                const tooltipEl = document.getElementById('global-tooltip');
                if (tooltipEl && tooltipEl.style.visibility === 'visible') {
                    positionTooltip(e, tooltipEl);
                }
            });

            // Ensure the tooltip hides on mouseout from the document or specific element
            document.body.addEventListener('mouseout', (e) => {
                // We use a slight delay for mouseout to handle transitions between nearby elements
                setTimeout(hideGlobalTooltip, 50); 
            });

            // Keyboard accessibility: show tooltip on focus and hide on blur
            document.body.addEventListener('focusin', (e) => {
                if (e.target && e.target.closest && e.target.closest('[data-help-content]')) {
                    showGlobalTooltip(e);
                }
            });

            document.body.addEventListener('focusout', (e) => {
                if (e.target && e.target.closest && e.target.closest('[data-help-content]')) {
                    hideGlobalTooltip();
                }
            });
        });
    </script>

    <!-- GLOBAL TOOLTIP CONTAINER -->
    <div id="global-tooltip" role="status" aria-live="polite" aria-hidden="true" class="fixed p-2 rounded-lg text-xs shadow-xl pointer-events-none opacity-0 transition-opacity duration-150" 
         style="background-color: var(--card-bg, #fff); border: 1px solid var(--border-color, #e2e8f0); color: var(--text-primary, #111827); max-width: 300px; z-index: 1000;">
    </div>
</body>
</html>
